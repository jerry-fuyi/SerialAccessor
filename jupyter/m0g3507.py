from seracc import BitField, RegisterBase, PeripheralBase, Subscriptor
from seracc import logging, wait_until_equal

class SA_I2C0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_I2C0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_I2C0_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_I2C0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_I2C0_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_I2C0_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUSCLK as clock source if enabled")

class SA_I2C0_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_I2C0_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "I2C Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC. 15h-1Fh = Reserved")

class SA_I2C0_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.MRXDONE = BitField(self, 0x00000001, "MRXDONE", "Master Receive Transaction completed Interrupt")
        self.TIMEOUTA = BitField(self, 0x00004000, "TIMEOUTA", "Timeout A Interrupt")
        self.MNACK = BitField(self, 0x00000080, "MNACK", "Address/Data NACK Interrupt")
        self.MSTART = BitField(self, 0x00000100, "MSTART", "START Detection Interrupt")
        self.MSTOP = BitField(self, 0x00000200, "MSTOP", "STOP Detection Interrupt")
        self.MARBLOST = BitField(self, 0x00000400, "MARBLOST", "Arbitration Lost Interrupt")
        self.MTXDONE = BitField(self, 0x00000002, "MTXDONE", "Master Transmit Transaction completed Interrupt")
        self.MRXFIFOFULL = BitField(self, 0x00000010, "MRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.MTXEMPTY = BitField(self, 0x00000020, "MTXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.MRXFIFOTRG = BitField(self, 0x00000004, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000008, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.MDMA_DONE1_2 = BitField(self, 0x00000800, "MDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.MDMA_DONE1_3 = BitField(self, 0x00001000, "MDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.SRXDONE = BitField(self, 0x00010000, "SRXDONE", "Slave Receive Data Interrupt. Signals that a byte has been received")
        self.STXDONE = BitField(self, 0x00020000, "STXDONE", "Slave Transmit Transaction completed Interrupt")
        self.SGENCALL = BitField(self, 0x01000000, "SGENCALL", "General Call Interrupt")
        self.STXEMPTY = BitField(self, 0x00200000, "STXEMPTY", "Slave Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.SRXFIFOFULL = BitField(self, 0x00100000, "SRXFIFOFULL", "RXFIFO full event. This interrupt is set if an Slave RX FIFO is full.")
        self.SRXFIFOTRG = BitField(self, 0x00040000, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00080000, "STXFIFOTRG", "Slave Transmit FIFO Trigger")
        self.SSTART = BitField(self, 0x00400000, "SSTART", "Start Condition Interrupt")
        self.SSTOP = BitField(self, 0x00800000, "SSTOP", "Stop Condition Interrupt")
        self.SDMA_DONE1_2 = BitField(self, 0x02000000, "SDMA_DONE1_2", "Slave DMA Done 1 on Event Channel 2")
        self.SDMA_DONE1_3 = BitField(self, 0x04000000, "SDMA_DONE1_3", "Slave DMA Done 1 on Event Channel 3")
        self.MPEC_RX_ERR = BitField(self, 0x00002000, "MPEC_RX_ERR", "Master RX Pec Error Interrupt")
        self.TIMEOUTB = BitField(self, 0x00008000, "TIMEOUTB", "Timeout B Interrupt")
        self.SPEC_RX_ERR = BitField(self, 0x08000000, "SPEC_RX_ERR", "Slave RX Pec Error Interrupt")
        self.STX_UNFL = BitField(self, 0x10000000, "STX_UNFL", "Slave TX FIFO underflow")
        self.SRX_OVFL = BitField(self, 0x20000000, "SRX_OVFL", "Slave RX FIFO overflow")
        self.SARBLOST = BitField(self, 0x40000000, "SARBLOST", "Slave Arbitration Lost")
        self.INTR_OVFL = BitField(self, 0x80000000, "INTR_OVFL", "Interrupt Overflow Interrupt Mask")
        self.SDMA_DONE1 = Subscriptor(self, "SDMA_DONE1_{}")
        self.MDMA_DONE1 = Subscriptor(self, "MDMA_DONE1_{}")

class SA_I2C0_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.MRXDONE = BitField(self, 0x00000001, "MRXDONE", "Master Receive Transaction completed Interrupt")
        self.TIMEOUTA = BitField(self, 0x00004000, "TIMEOUTA", "Timeout A Interrupt")
        self.MNACK = BitField(self, 0x00000080, "MNACK", "Address/Data NACK Interrupt")
        self.MSTART = BitField(self, 0x00000100, "MSTART", "START Detection Interrupt")
        self.MSTOP = BitField(self, 0x00000200, "MSTOP", "STOP Detection Interrupt")
        self.MARBLOST = BitField(self, 0x00000400, "MARBLOST", "Arbitration Lost Interrupt")
        self.MTXDONE = BitField(self, 0x00000002, "MTXDONE", "Master Transmit Transaction completed Interrupt")
        self.MRXFIFOFULL = BitField(self, 0x00000010, "MRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.MTXEMPTY = BitField(self, 0x00000020, "MTXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.MRXFIFOTRG = BitField(self, 0x00000004, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000008, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.MDMA_DONE1_2 = BitField(self, 0x00000800, "MDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.MDMA_DONE1_3 = BitField(self, 0x00001000, "MDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.SRXDONE = BitField(self, 0x00010000, "SRXDONE", "Slave Receive Data Interrupt. Signals that a byte has been received")
        self.STXDONE = BitField(self, 0x00020000, "STXDONE", "Slave Transmit Transaction completed Interrupt")
        self.SGENCALL = BitField(self, 0x01000000, "SGENCALL", "General Call Interrupt")
        self.STXEMPTY = BitField(self, 0x00200000, "STXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.SRXFIFOFULL = BitField(self, 0x00100000, "SRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.SRXFIFOTRG = BitField(self, 0x00040000, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00080000, "STXFIFOTRG", "Slave Transmit FIFO Trigger")
        self.SSTART = BitField(self, 0x00400000, "SSTART", "Start Condition Interrupt")
        self.SSTOP = BitField(self, 0x00800000, "SSTOP", "Stop Condition Interrupt")
        self.SDMA_DONE1_2 = BitField(self, 0x02000000, "SDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.SDMA_DONE1_3 = BitField(self, 0x04000000, "SDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.MPEC_RX_ERR = BitField(self, 0x00002000, "MPEC_RX_ERR", "Master RX Pec Error Interrupt")
        self.TIMEOUTB = BitField(self, 0x00008000, "TIMEOUTB", "Timeout B Interrupt")
        self.SPEC_RX_ERR = BitField(self, 0x08000000, "SPEC_RX_ERR", "Slave RX Pec Error Interrupt")
        self.STX_UNFL = BitField(self, 0x10000000, "STX_UNFL", "Slave TX FIFO underflow")
        self.SRX_OVFL = BitField(self, 0x20000000, "SRX_OVFL", "Slave RX FIFO overflow")
        self.SARBLOST = BitField(self, 0x40000000, "SARBLOST", "Slave Arbitration Lost")
        self.INTR_OVFL = BitField(self, 0x80000000, "INTR_OVFL", "Interrupt overflow interrupt. It is set when SSTART or SSTOP interrupts overflow i.e. occur twice without being serviced")
        self.SDMA_DONE1 = Subscriptor(self, "SDMA_DONE1_{}")
        self.MDMA_DONE1 = Subscriptor(self, "MDMA_DONE1_{}")

class SA_I2C0_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.MRXDONE = BitField(self, 0x00000001, "MRXDONE", "Master Receive Data Interrupt")
        self.TIMEOUTA = BitField(self, 0x00004000, "TIMEOUTA", "Timeout A Interrupt")
        self.MNACK = BitField(self, 0x00000080, "MNACK", "Address/Data NACK Interrupt")
        self.MSTART = BitField(self, 0x00000100, "MSTART", "START Detection Interrupt")
        self.MSTOP = BitField(self, 0x00000200, "MSTOP", "STOP Detection Interrupt")
        self.MARBLOST = BitField(self, 0x00000400, "MARBLOST", "Arbitration Lost Interrupt")
        self.MTXDONE = BitField(self, 0x00000002, "MTXDONE", "Master Transmit Transaction completed Interrupt")
        self.MRXFIFOFULL = BitField(self, 0x00000010, "MRXFIFOFULL", "RXFIFO full event. This interrupt is set if the RX FIFO is full.")
        self.MTXEMPTY = BitField(self, 0x00000020, "MTXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.MRXFIFOTRG = BitField(self, 0x00000004, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000008, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.MDMA_DONE1_2 = BitField(self, 0x00000800, "MDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.MDMA_DONE1_3 = BitField(self, 0x00001000, "MDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.SRXDONE = BitField(self, 0x00010000, "SRXDONE", "Slave Receive Data Interrupt. Signals that a byte has been received")
        self.STXDONE = BitField(self, 0x00020000, "STXDONE", "Slave Transmit Transaction completed Interrupt")
        self.SGENCALL = BitField(self, 0x01000000, "SGENCALL", "General Call Interrupt")
        self.STXEMPTY = BitField(self, 0x00200000, "STXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.SRXFIFOFULL = BitField(self, 0x00100000, "SRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.SRXFIFOTRG = BitField(self, 0x00040000, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00080000, "STXFIFOTRG", "Slave Transmit FIFO Trigger")
        self.SSTART = BitField(self, 0x00400000, "SSTART", "Slave START Detection Interrupt")
        self.SSTOP = BitField(self, 0x00800000, "SSTOP", "Slave STOP Detection Interrupt")
        self.SDMA_DONE1_2 = BitField(self, 0x02000000, "SDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.SDMA_DONE1_3 = BitField(self, 0x04000000, "SDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.MPEC_RX_ERR = BitField(self, 0x00002000, "MPEC_RX_ERR", "Master RX Pec Error Interrupt")
        self.TIMEOUTB = BitField(self, 0x00008000, "TIMEOUTB", "Timeout B Interrupt")
        self.SPEC_RX_ERR = BitField(self, 0x08000000, "SPEC_RX_ERR", "Slave RX Pec Error Interrupt")
        self.STX_UNFL = BitField(self, 0x10000000, "STX_UNFL", "Slave TX FIFO underflow")
        self.SRX_OVFL = BitField(self, 0x20000000, "SRX_OVFL", "Slave RX FIFO overflow")
        self.SARBLOST = BitField(self, 0x40000000, "SARBLOST", "Slave Arbitration Lost")
        self.INTR_OVFL = BitField(self, 0x80000000, "INTR_OVFL", "Interrupt overflow")
        self.SDMA_DONE1 = Subscriptor(self, "SDMA_DONE1_{}")
        self.MDMA_DONE1 = Subscriptor(self, "MDMA_DONE1_{}")

class SA_I2C0_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.MRXDONE = BitField(self, 0x00000001, "MRXDONE", "Master Receive Data Interrupt. Signals that a byte has been received")
        self.TIMEOUTA = BitField(self, 0x00004000, "TIMEOUTA", "Timeout A interrupt")
        self.MNACK = BitField(self, 0x00000080, "MNACK", "Address/Data NACK Interrupt")
        self.MSTART = BitField(self, 0x00000100, "MSTART", "START Detection Interrupt")
        self.MSTOP = BitField(self, 0x00000200, "MSTOP", "STOP Detection Interrupt")
        self.MARBLOST = BitField(self, 0x00000400, "MARBLOST", "Arbitration Lost Interrupt")
        self.MTXDONE = BitField(self, 0x00000002, "MTXDONE", "Master Transmit Transaction completed Interrupt")
        self.MRXFIFOFULL = BitField(self, 0x00000010, "MRXFIFOFULL", "RXFIFO full event.")
        self.MTXEMPTY = BitField(self, 0x00000020, "MTXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.MRXFIFOTRG = BitField(self, 0x00000004, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000008, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.MDMA_DONE1_2 = BitField(self, 0x00000800, "MDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.MDMA_DONE1_3 = BitField(self, 0x00001000, "MDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.SRXDONE = BitField(self, 0x00010000, "SRXDONE", "Slave Receive Data Interrupt. Signals that a byte has been received")
        self.STXDONE = BitField(self, 0x00020000, "STXDONE", "Slave Transmit Transaction completed Interrupt")
        self.SGENCALL = BitField(self, 0x01000000, "SGENCALL", "General Call Interrupt")
        self.STXEMPTY = BitField(self, 0x00200000, "STXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.SRXFIFOFULL = BitField(self, 0x00100000, "SRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.SRXFIFOTRG = BitField(self, 0x00040000, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00080000, "STXFIFOTRG", "Slave Transmit FIFO Trigger")
        self.SSTART = BitField(self, 0x00400000, "SSTART", "Start Condition Interrupt")
        self.SSTOP = BitField(self, 0x00800000, "SSTOP", "Stop Condition Interrupt")
        self.SDMA_DONE1_2 = BitField(self, 0x02000000, "SDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.SDMA_DONE1_3 = BitField(self, 0x04000000, "SDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.MPEC_RX_ERR = BitField(self, 0x00002000, "MPEC_RX_ERR", "Master RX Pec Error Interrupt")
        self.TIMEOUTB = BitField(self, 0x00008000, "TIMEOUTB", "Timeout B Interrupt")
        self.SPEC_RX_ERR = BitField(self, 0x08000000, "SPEC_RX_ERR", "Slave RX Pec Error Interrupt")
        self.STX_UNFL = BitField(self, 0x10000000, "STX_UNFL", "Slave TX FIFO underflow")
        self.SRX_OVFL = BitField(self, 0x20000000, "SRX_OVFL", "Slave RX FIFO overflow")
        self.SARBLOST = BitField(self, 0x40000000, "SARBLOST", "Slave Arbitration Lost")
        self.INTR_OVFL = BitField(self, 0x80000000, "INTR_OVFL", "Interrupt overflow")
        self.SDMA_DONE1 = Subscriptor(self, "SDMA_DONE1_{}")
        self.MDMA_DONE1 = Subscriptor(self, "MDMA_DONE1_{}")

class SA_I2C0_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.MRXDONE = BitField(self, 0x00000001, "MRXDONE", "Master Receive Data Interrupt. Signals that a byte has been received")
        self.TIMEOUTA = BitField(self, 0x00004000, "TIMEOUTA", "Timeout A interrupt")
        self.MNACK = BitField(self, 0x00000080, "MNACK", "Address/Data NACK Interrupt")
        self.MSTART = BitField(self, 0x00000100, "MSTART", "START Detection Interrupt")
        self.MSTOP = BitField(self, 0x00000200, "MSTOP", "STOP Detection Interrupt")
        self.MARBLOST = BitField(self, 0x00000400, "MARBLOST", "Arbitration Lost Interrupt")
        self.MTXDONE = BitField(self, 0x00000002, "MTXDONE", "Master Transmit Transaction completed Interrupt")
        self.MRXFIFOFULL = BitField(self, 0x00000010, "MRXFIFOFULL", "RXFIFO full event.")
        self.MTXEMPTY = BitField(self, 0x00000020, "MTXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.MRXFIFOTRG = BitField(self, 0x00000004, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000008, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.MDMA_DONE1_2 = BitField(self, 0x00000800, "MDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.MDMA_DONE1_3 = BitField(self, 0x00001000, "MDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.SRXDONE = BitField(self, 0x00010000, "SRXDONE", "Slave Receive Data Interrupt. Signals that a byte has been received")
        self.STXDONE = BitField(self, 0x00020000, "STXDONE", "Slave Transmit Transaction completed Interrupt")
        self.SGENCALL = BitField(self, 0x01000000, "SGENCALL", "General Call Interrupt")
        self.STXEMPTY = BitField(self, 0x00200000, "STXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.SRXFIFOFULL = BitField(self, 0x00100000, "SRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.SRXFIFOTRG = BitField(self, 0x00040000, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00080000, "STXFIFOTRG", "Slave Transmit FIFO Trigger")
        self.SSTART = BitField(self, 0x00400000, "SSTART", "Slave START Detection Interrupt")
        self.SSTOP = BitField(self, 0x00800000, "SSTOP", "Slave STOP Detection Interrupt")
        self.SDMA_DONE1_2 = BitField(self, 0x02000000, "SDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.SDMA_DONE1_3 = BitField(self, 0x04000000, "SDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.MPEC_RX_ERR = BitField(self, 0x00002000, "MPEC_RX_ERR", "Master RX Pec Error Interrupt")
        self.TIMEOUTB = BitField(self, 0x00008000, "TIMEOUTB", "Timeout B Interrupt")
        self.SPEC_RX_ERR = BitField(self, 0x08000000, "SPEC_RX_ERR", "Slave RX Pec Error Interrupt")
        self.STX_UNFL = BitField(self, 0x10000000, "STX_UNFL", "Slave TX FIFO underflow")
        self.SRX_OVFL = BitField(self, 0x20000000, "SRX_OVFL", "Slave RX FIFO overflow")
        self.SARBLOST = BitField(self, 0x40000000, "SARBLOST", "Slave Arbitration Lost")
        self.INTR_OVFL = BitField(self, 0x80000000, "INTR_OVFL", "Interrupt overflow")
        self.SDMA_DONE1 = Subscriptor(self, "SDMA_DONE1_{}")
        self.MDMA_DONE1 = Subscriptor(self, "MDMA_DONE1_{}")

class SA_I2C0_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "I2C Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC. 15h-1Fh = Reserved")

class SA_I2C0_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C0_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C0_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C0_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C0_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C0_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "I2C Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC. 15h-1Fh = Reserved")

class SA_I2C0_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C0_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C0_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C0_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C0_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C0_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.INT1_CFG = BitField(self, 0x0000000C, "INT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.INT_CFG = Subscriptor(self, "INT{}_CFG")

class SA_I2C0_INTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INTCTL", "Interrupt control register")
        self.INTEVAL = BitField(self, 0x00000001, "INTEVAL", "Writing a 1 to this field re-evaluates the interrupt sources.")

class SA_I2C0_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_I2C0_GFCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GFCTL", "I2C Glitch Filter Control")
        self.AGFSEL = BitField(self, 0x00000600, "AGFSEL", "Analog Glitch Suppression Pulse Width. This field controls the pulse width select for the analog glitch suppression on SCL and SDA lines. See device datasheet for exact values. (ULP I2C only)")
        self.DGFSEL = BitField(self, 0x00000007, "DGFSEL", "Glitch Suppression Pulse Width. This field controls the pulse width select for glitch suppression on the SCL and SDA lines. The following values are the glitch suppression values in terms of functional clocks. (Core Domain only)")
        self.AGFEN = BitField(self, 0x00000100, "AGFEN", "Analog Glitch Suppression Enable")
        self.CHAIN = BitField(self, 0x00000800, "CHAIN", "Analog and digital noise filters chaining enable.")

class SA_I2C0_TIMEOUT_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x20002, "TIMEOUT_CTL", "I2C Timeout Count Control Register")
        self.TCNTLA = BitField(self, 0x000000FF, "TCNTLA", "Timeout counter A load value. Counter A is used for SCL low detection. This field contains the upper 8 bits of a 12-bit pre-load value for the Timeout A count. NOTE: The value of CNTLA must be greater than 1h. Each count is equal to 520 times the timeout period of functional clock. For example, with 8MHz functional clock and a 100KHz operating I2C clock, one timeout period will be equal to (1 / 8MHz) * 520 or 65 us.")
        self.TCNTAEN = BitField(self, 0x00008000, "TCNTAEN", "Timeout Counter A Enable")
        self.TCNTLB = BitField(self, 0x00FF0000, "TCNTLB", "Timeout Count B Load: Counter B is used for SCL High Detection. This field contains the upper 8 bits of a 12-bit pre-load value for the Timeout B count. NOTE: The value of CNTLB must be greater than 1h. . Each count is equal to 1* clock period. For example, with 10MHz functional clock one timeout period will be equal to1*100ns.")
        self.TCNTBEN = BitField(self, 0x80000000, "TCNTBEN", "Timeout Counter B Enable")

class SA_I2C0_TIMEOUT_CNT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x20002, "TIMEOUT_CNT", "I2C Timeout Count Register")
        self.TCNTA = BitField(self, 0x000000FF, "TCNTA", "Timeout Count A Current Count: This field contains the upper 8 bits of a 12-bit current counter for timeout counter A")
        self.TCNTB = BitField(self, 0x00FF0000, "TCNTB", "Timeout Count B Current Count: This field contains the upper 8 bits of a 12-bit current counter for timeout counter B")

class SA_I2C0_MSA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MSA", "I2C Master Slave Address Register")
        self.DIR = BitField(self, 0x00000001, "DIR", "Receive/Send. The DIR bit specifies if the next master operation is a Receive (High) or Transmit (Low). 0h = Transmit 1h = Receive")
        self.SADDR = BitField(self, 0x000007FE, "SADDR", "I2C Slave Address This field specifies bits A9 through A0 of the slave address.. In 7-bit addressing mode as selected by MSA.MODE bit, the top 3 bits are don't care")
        self.MMODE = BitField(self, 0x00008000, "MMODE", "This bit selects the adressing mode to be used in master mode. When 0, 7-bit addressing is used. When 1, 10-bit addressing is used.")

class SA_I2C0_MCTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCTR", "I2C Master Control Register")
        self.BURSTRUN = BitField(self, 0x00000001, "BURSTRUN", "I2C Master Enable. and start transaction")
        self.START = BitField(self, 0x00000002, "START", "Generate START")
        self.STOP = BitField(self, 0x00000004, "STOP", "Generate STOP")
        self.ACK = BitField(self, 0x00000008, "ACK", "Data Acknowledge Enable.. Software needs to configure this bit to send the ACK or NACK. See field decoding in Table: MCTR Field decoding.")
        self.MBLEN = BitField(self, 0x0FFF0000, "MBLEN", "I2C transaction length. This field contains the programmed length of bytes of the Transaction.")
        self.MACKOEN = BitField(self, 0x00000010, "MACKOEN", "Master ACK overrride Enable")
        self.RD_ON_TXEMPTY = BitField(self, 0x00000020, "RD_ON_TXEMPTY", "Read on TX Empty")

class SA_I2C0_MSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MSR", "I2C Master Status Register")
        self.BUSY = BitField(self, 0x00000001, "BUSY", "I2C Master FSM Busy. The BUSY bit is set during an ongoing transaction, so is set during the transmit/receive of the amount of data set in MBLEN including START, RESTART, Address and STOP signal generation when required for the current transaction.")
        self.ERR = BitField(self, 0x00000002, "ERR", "Error. The error can be from the slave address not being acknowledged or the transmit data not being acknowledged.")
        self.ADRACK = BitField(self, 0x00000004, "ADRACK", "Acknowledge Address")
        self.DATACK = BitField(self, 0x00000008, "DATACK", "Acknowledge Data")
        self.ARBLST = BitField(self, 0x00000010, "ARBLST", "Arbitration Lost")
        self.IDLE = BitField(self, 0x00000020, "IDLE", "I2C Idle")
        self.BUSBSY = BitField(self, 0x00000040, "BUSBSY", "I2C Bus is Busy. Master State Machine will wait until this bit is cleared before starting a transaction. When first enabling the Master in multi master environments, FW should wait for one I2C clock period after setting ACTIVE high before writing to the MTCR register to start the transaction so that if SCL goes low it will trigger the BUSBSY.")
        self.MBCNT = BitField(self, 0x0FFF0000, "MBCNT", "I2C Master Transaction Count. This field contains the current count-down value of the transaction.")

class SA_I2C0_MRXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MRXDATA", "I2C Master RXData")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Received Data. . This field contains the last received data.")

class SA_I2C0_MTXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MTXDATA", "I2C Master TXData")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Transmit Data. This byte contains the data to be transferred during the next transaction.")

class SA_I2C0_MTPR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x1, "MTPR", "I2C Master Timer Period")
        self.TPR = BitField(self, 0x0000007F, "TPR", "Timer Period . This field is used in the equation to configure SCL_PERIOD : SCL_PERIOD = (1 + TPR ) * (SCL_LP + SCL_HP ) * INT_CLK_PRD where: SCL_PRD is the SCL line period (I2C clock). TPR is the Timer Period register value (range of 1 to 127). SCL_LP is the SCL Low period (fixed at 6). SCL_HP is the SCL High period (fixed at 4). CLK_PRD is the functional clock period in ns.")

class SA_I2C0_MCR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCR", "I2C Master Configuration")
        self.LPBK = BitField(self, 0x00000100, "LPBK", "I2C Loopback")
        self.MMST = BitField(self, 0x00000002, "MMST", "Multimaster mode. In Multimaster mode the SCL high time counts once the SCL line has been detected high. If this is not enabled the high time counts as soon as the SCL line has been set high by the I2C controller.")
        self.ACTIVE = BitField(self, 0x00000001, "ACTIVE", "Device Active After this bit has been set, it should not be set again unless it has been cleared by writing a 0 or by a reset, otherwise transfer failures may occur.")
        self.CLKSTRETCH = BitField(self, 0x00000004, "CLKSTRETCH", "Clock Stretching. This bit controls the support for clock stretching of the I2C bus.")

class SA_I2C0_MBMON(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x3, "MBMON", "I2C Master Bus Monitor")
        self.SCL = BitField(self, 0x00000001, "SCL", "I2C SCL Status")
        self.SDA = BitField(self, 0x00000002, "SDA", "I2C SDA Status")

class SA_I2C0_MFIFOCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MFIFOCTL", "I2C Master FIFO Control")
        self.TXTRIG = BitField(self, 0x00000007, "TXTRIG", "TX FIFO Trigger. Indicates at what fill level in the TX FIFO a trigger will be generated.")
        self.TXFLUSH = BitField(self, 0x00000080, "TXFLUSH", "TX FIFO Flush. Setting this bit will Flush the TX FIFO. Before reseting this bit to stop Flush the TXFIFOCNT should be checked to be 8 and indicating that the Flush has completed.")
        self.RXTRIG = BitField(self, 0x00000700, "RXTRIG", "RX FIFO Trigger. Indicates at what fill level in the RX FIFO a trigger will be generated. Note: Programming RXTRIG to 0x0 has no effect since no data is present to transfer out of RX FIFO.")
        self.RXFLUSH = BitField(self, 0x00008000, "RXFLUSH", "RX FIFO Flush. Setting this bit will Flush the RX FIFO. Before reseting this bit to stop Flush the RXFIFOCNT should be checked to be 0 and indicating that the Flush has completed.")

class SA_I2C0_MFIFOSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x800, "MFIFOSR", "I2C Master FIFO Status Register")
        self.RXFIFOCNT = BitField(self, 0x0000000F, "RXFIFOCNT", "Number of Bytes which could be read from the RX FIFO")
        self.TXFIFOCNT = BitField(self, 0x00000F00, "TXFIFOCNT", "Number of Bytes which could be put into the TX FIFO")
        self.RXFLUSH = BitField(self, 0x00000080, "RXFLUSH", "RX FIFO Flush. When this bit is set a Flush operation for the RX FIFO is active. Clear the RXFLUSH bit in the control register to stop.")
        self.TXFLUSH = BitField(self, 0x00008000, "TXFLUSH", "TX FIFO Flush. When this bit is set a Flush operation for the TX FIFO is active. Clear the TXFLUSH bit in the control register to stop.")

class SA_I2C0_MASTER_I2CPECCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MASTER_I2CPECCTL", "I2C master PEC control register")
        self.PECCNT = BitField(self, 0x000001FF, "PECCNT", "PEC Count. When this field is non zero, the number of I2C bytes are counted (Note that although the PEC is calculated on the I2C address it is not counted at a byte). When the byte count = PECCNT and the state machine is transmitting, the contents of the LSFR is loaded into the shift register instead of the byte received from the Tx FIFO. When the state machine is receiving, after the last bit of this byte is received the LSFR is checked and if it is non-zero, a PEC RX Error interrupt is generated. The I2C packet must be padded to include the PEC byte for both transmit and receive. In transmit mode the FIFO must be loaded with a dummy PEC byte. In receive mode the PEC byte will be passed to the Rx FIFO. In the normal Master use case, FW would set PECEN=1 and PECCNT=SMB packet length (Not including Slave Address byte, but including the PEC byte). FW would then configure DMA to allow the packet to complete unassisted and write MCTR to initiate the transaction. Note that when the byte count = PEC CNT, the byte count is reset to 0 and multiple PEC calculation can automatically occur within a single I2C transaction. Note that any write to the MASTER_I2CPECCTL Register will clear the current PEC Byte Count in the Master State Machine.")
        self.PECEN = BitField(self, 0x00001000, "PECEN", "PEC Enable. This bit enables the SMB Packet Error Checking (PEC). When enabled the PEC is calculated on all bits accept the Start, Stop, Ack and Nack. The PEC LSFR and the Byte Counter is set to 0 when the State Machine is in the IDLE state, which occur following a Stop or when a timeout occurs. The Counter is also set to 0 after the PEC byte is sent or received. Note that the NACK is automatically send following a PEC byte that results in a PEC error. The PEC Polynomial is x^8 + x^2 + x^1 + 1.")

class SA_I2C0_MASTER_PECSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MASTER_PECSR", "I2C master PEC status register")
        self.PECBYTECNT = BitField(self, 0x000001FF, "PECBYTECNT", "PEC Byte Count . This is the current PEC Byte Count of the Master State Machine.")
        self.PECSTS_CHECK = BitField(self, 0x00010000, "PECSTS_CHECK", "This status bit indicates if the PEC was checked in the transaction that occurred before the last Stop. Latched on Stop.")
        self.PECSTS_ERROR = BitField(self, 0x00020000, "PECSTS_ERROR", "This status bit indicates if a PEC check error occurred in the transaction that occurred before the last Stop. Latched on Stop.")

class SA_I2C0_SOAR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x4000, "SOAR", "I2C Slave Own Address")
        self.OAR = BitField(self, 0x000003FF, "OAR", "I2C Slave Own Address: This field specifies bits A9 through A0 of the slave address.. In 7-bit addressing mode as selected by I2CSOAR.MODE bit, the top 3 bits are don't care")
        self.OAREN = BitField(self, 0x00004000, "OAREN", "I2C Slave Own Address Enable")
        self.SMODE = BitField(self, 0x00008000, "SMODE", "This bit selects the adressing mode to be used in slave mode.. When 0, 7-bit addressing is used. When 1, 10-bit addressing is used.")

class SA_I2C0_SOAR2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SOAR2", "I2C Slave Own Address 2")
        self.OAR2 = BitField(self, 0x0000007F, "OAR2", "I2C Slave Own Address 2. This field specifies the alternate OAR2 address.")
        self.OAR2EN = BitField(self, 0x00000080, "OAR2EN", "I2C Slave Own Address 2 Enable")
        self.OAR2_MASK = BitField(self, 0x007F0000, "OAR2_MASK", "I2C Slave Own Address 2 Mask: This field specifies bits A6 through A0 of the slave address.. The bits with value 1 in SOAR2.OAR2_MASK field will make the corresponding incoming address bits to match by default regardless of the value inside SOAR2.OAR2 i.e. corresponding SOAR2.OAR2 bit is a dont care.")

class SA_I2C0_SCTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x404, "SCTR", "I2C Slave Control Register")
        self.ACTIVE = BitField(self, 0x00000001, "ACTIVE", "Device Active. Setting this bit enables the slave functionality.")
        self.GENCALL = BitField(self, 0x00000002, "GENCALL", "General call response enable. This bit is only available in UCBxI2COA0.. Modify only when UCSWRST = 1. 0b = Do not respond to a general call 1b = Respond to a general call")
        self.SCLKSTRETCH = BitField(self, 0x00000004, "SCLKSTRETCH", "Slave Clock Stretch Enable")
        self.TXEMPTY_ON_TREQ = BitField(self, 0x00000008, "TXEMPTY_ON_TREQ", "Tx Empty Interrupt on TREQ")
        self.TXTRIG_TXMODE = BitField(self, 0x00000010, "TXTRIG_TXMODE", "Tx Trigger when slave FSM is in Tx Mode")
        self.TXWAIT_STALE_TXFIFO = BitField(self, 0x00000020, "TXWAIT_STALE_TXFIFO", "Tx transfer waits when stale data in Tx FIFO.. This prevents stale bytes left in the TX FIFO from automatically being sent on the next I2C packet. Note: this should be used with TXEMPTY_ON_TREQ set to prevent the Slave State Machine from waiting for TX FIFO data without an interrupt notification when the FIFO data is stale.")
        self.RXFULL_ON_RREQ = BitField(self, 0x00000040, "RXFULL_ON_RREQ", "Rx full interrupt generated on RREQ condition as indicated in SSR")
        self.EN_DEFHOSTADR = BitField(self, 0x00000080, "EN_DEFHOSTADR", "Enable Default Host Address")
        self.EN_ALRESPADR = BitField(self, 0x00000100, "EN_ALRESPADR", "Enable Alert Response Address")
        self.EN_DEFDEVADR = BitField(self, 0x00000200, "EN_DEFDEVADR", "Enable Deault device address")
        self.SWUEN = BitField(self, 0x00000400, "SWUEN", "Slave Wakeup Enable")

class SA_I2C0_SSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SSR", "I2C Slave Status Register")
        self.RREQ = BitField(self, 0x00000001, "RREQ", "Receive Request")
        self.TREQ = BitField(self, 0x00000002, "TREQ", "Transmit Request")
        self.OAR2SEL = BitField(self, 0x00000008, "OAR2SEL", "OAR2 Address Matched. This bit gets reevaluated after every address comparison.")
        self.QCMDST = BitField(self, 0x00000010, "QCMDST", "Quick Command Status. Value Description: 0: The last transaction was a normal transaction or a transaction has not occurred. 1: The last transaction was a Quick Command transaction")
        self.QCMDRW = BitField(self, 0x00000020, "QCMDRW", "Quick Command Read / Write . This bit only has meaning when the QCMDST bit is set. Value Description: 0: Quick command was a write 1: Quick command was a read")
        self.RXMODE = BitField(self, 0x00000004, "RXMODE", "Slave FSM is in Rx MODE")
        self.BUSBSY = BitField(self, 0x00000040, "BUSBSY", "I2C bus is busy")
        self.TXMODE = BitField(self, 0x00000080, "TXMODE", "Slave FSM is in TX MODE")
        self.STALE_TXFIFO = BitField(self, 0x00000100, "STALE_TXFIFO", "Stale Tx FIFO")
        self.ADDRMATCH = BitField(self, 0x0007FE00, "ADDRMATCH", "Indicates the address for which slave address match happened")

class SA_I2C0_SRXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SRXDATA", "I2C Slave RXData")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Received Data. . This field contains the last received data.")

class SA_I2C0_STXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STXDATA", "I2C Slave TXData")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Transmit Data. This byte contains the data to be transferred during the next transaction.")

class SA_I2C0_SACKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SACKCTL", "I2C Slave ACK Control")
        self.ACKOEN = BitField(self, 0x00000001, "ACKOEN", "I2C Slave ACK Override Enable")
        self.ACKOVAL = BitField(self, 0x00000002, "ACKOVAL", "I2C Slave ACK Override Value. Note: for General Call this bit will be ignored if set to NACK and slave continues to receive data.")
        self.ACKOEN_ON_START = BitField(self, 0x00000004, "ACKOEN_ON_START", "When set this bit will automatically turn on the Slave ACKOEN field following a Start Condition.")
        self.ACKOEN_ON_PECNEXT = BitField(self, 0x00000008, "ACKOEN_ON_PECNEXT", "When set this bit will automatically turn on the Slave ACKOEN field following the ACK/NACK of the byte received just prior to the PEC byte.. Note that when ACKOEN is set the PEC byte will not automatically be ACKed/NACKed by the State Machine and FW must perform this function by writing SLAVE_SACKCTL.")
        self.ACKOEN_ON_PECDONE = BitField(self, 0x00000010, "ACKOEN_ON_PECDONE", "When set this bit will automatically turn on the Slave ACKOEN field following the ACK/NACK of the received PEC byte.")

class SA_I2C0_SFIFOCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SFIFOCTL", "I2C Slave FIFO Control")
        self.TXTRIG = BitField(self, 0x00000007, "TXTRIG", "TX FIFO Trigger. Indicates at what fill level in the TX FIFO a trigger will be generated.")
        self.TXFLUSH = BitField(self, 0x00000080, "TXFLUSH", "TX FIFO Flush. Setting this bit will Flush the TX FIFO. Before reseting this bit to stop Flush the TXFIFOCNT should be checked to be 8 and indicating that the Flush has completed.")
        self.RXFLUSH = BitField(self, 0x00008000, "RXFLUSH", "RX FIFO Flush. Setting this bit will Flush the RX FIFO. Before reseting this bit to stop Flush the RXFIFOCNT should be checked to be 0 and indicating that the Flush has completed.")
        self.RXTRIG = BitField(self, 0x00000700, "RXTRIG", "RX FIFO Trigger. Indicates at what fill level in the RX FIFO a trigger will be generated. Note: Programming RXTRIG to 0x0 has no effect since no data is present to transfer out of RX FIFO.")

class SA_I2C0_SFIFOSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x800, "SFIFOSR", "I2C Slave FIFO Status Register")
        self.RXFIFOCNT = BitField(self, 0x0000000F, "RXFIFOCNT", "Number of Bytes which could be read from the RX FIFO")
        self.TXFIFOCNT = BitField(self, 0x00000F00, "TXFIFOCNT", "Number of Bytes which could be put into the TX FIFO")
        self.TXFLUSH = BitField(self, 0x00008000, "TXFLUSH", "TX FIFO Flush. When this bit is set a Flush operation for the TX FIFO is active. Clear the TXFLUSH bit in the control register to stop.")
        self.RXFLUSH = BitField(self, 0x00000080, "RXFLUSH", "RX FIFO Flush. When this bit is set a Flush operation for the RX FIFO is active. Clear the RXFLUSH bit in the control register to stop.")

class SA_I2C0_SLAVE_PECCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SLAVE_PECCTL", "I2C Slave PEC control register")
        self.PECCNT = BitField(self, 0x000001FF, "PECCNT", "When this field is non zero, the number of I2C data bytes are counted. When the byte count = PECCNT and the state machine is transmitting, the contents of the LSFR is loaded into the shift register instead of the byte received from the Tx FIFO. When the state machine is receiving, after the last bit of this byte is received the LSFR is checked and if it is non-zero, a PEC RX Error interrupt is generated. The I2C packet must be padded to include the PEC byte for both transmit and receive. In transmit mode the FIFO must be loaded with a dummy PEC byte. In receive mode the PEC byte will be passed to the Rx FIFO.. In the normal Slave use case, FW would set PECEN=1 and PECCNT=0 and use the ACKOEN until the remaining SMB packet length is known. FW would then set the PECCNT to the remaining packet length (Including PEC bye). FW would then configure DMA to allow the packet to complete unassisted and exit NoAck mode. Note that when the byte count = PEC CNT, the byte count is reset to 0 and multiple PEC calculation can automatically occur within a single I2C transaction")
        self.PECEN = BitField(self, 0x00001000, "PECEN", "PEC Enable. This bit enables the SMB Packet Error Checking (PEC). When enabled the PEC is calculated on all bits accept the Start, Stop, Ack and Nack. The PEC LSFR and the Byte Counter is set to 0 when the State Machine is in the IDLE state, which occur following a Stop or when a timeout occurs. The Counter is also set to 0 after the PEC byte is sent or received. Note that the NACK is automatically send following a PEC byte that results in a PEC error. The PEC Polynomial is x^8 + x^2 + x^1 + 1.")

class SA_I2C0_SLAVE_PECSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SLAVE_PECSR", "I2C slave PEC status register")
        self.PECBYTECNT = BitField(self, 0x000001FF, "PECBYTECNT", "This is the current PEC Byte Count of the Slave State Machine.")
        self.PECSTS_CHECK = BitField(self, 0x00010000, "PECSTS_CHECK", "This status bit indicates if the PEC was checked in the transaction that occurred before the last Stop. Latched on Stop.")
        self.PECSTS_ERROR = BitField(self, 0x00020000, "PECSTS_ERROR", "This status bit indicates if a PEC check error occurred in the transaction that occurred before the last Stop. Latched on Stop.")

class SA_I2C0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_I2C0_PWREN(self, 0x800)
        self.RSTCTL = SA_I2C0_RSTCTL(self, 0x804)
        self.CLKCFG = SA_I2C0_CLKCFG(self, 0x808)
        self.STAT = SA_I2C0_STAT(self, 0x814)
        self.CLKDIV = SA_I2C0_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_I2C0_CLKSEL(self, 0x1004)
        self.PDBGCTL = SA_I2C0_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_I2C0_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_I2C0_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_I2C0_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_I2C0_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_I2C0_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_I2C0_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_I2C0_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_I2C0_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_I2C0_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_I2C0_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_I2C0_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_I2C0_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_I2C0_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_I2C0_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_I2C0_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_I2C0_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_I2C0_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_I2C0_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_I2C0_EVT_MODE(self, 0x10E0)
        self.INTCTL = SA_I2C0_INTCTL(self, 0x10E4)
        self.DESC = SA_I2C0_DESC(self, 0x10FC)
        self.GFCTL = SA_I2C0_GFCTL(self, 0x1200)
        self.TIMEOUT_CTL = SA_I2C0_TIMEOUT_CTL(self, 0x1204)
        self.TIMEOUT_CNT = SA_I2C0_TIMEOUT_CNT(self, 0x1208)
        self.MSA = SA_I2C0_MSA(self, 0x1210)
        self.MCTR = SA_I2C0_MCTR(self, 0x1214)
        self.MSR = SA_I2C0_MSR(self, 0x1218)
        self.MRXDATA = SA_I2C0_MRXDATA(self, 0x121C)
        self.MTXDATA = SA_I2C0_MTXDATA(self, 0x1220)
        self.MTPR = SA_I2C0_MTPR(self, 0x1224)
        self.MCR = SA_I2C0_MCR(self, 0x1228)
        self.MBMON = SA_I2C0_MBMON(self, 0x1234)
        self.MFIFOCTL = SA_I2C0_MFIFOCTL(self, 0x1238)
        self.MFIFOSR = SA_I2C0_MFIFOSR(self, 0x123C)
        self.MASTER_I2CPECCTL = SA_I2C0_MASTER_I2CPECCTL(self, 0x1240)
        self.MASTER_PECSR = SA_I2C0_MASTER_PECSR(self, 0x1244)
        self.SOAR = SA_I2C0_SOAR(self, 0x1250)
        self.SOAR2 = SA_I2C0_SOAR2(self, 0x1254)
        self.SCTR = SA_I2C0_SCTR(self, 0x1258)
        self.SSR = SA_I2C0_SSR(self, 0x125C)
        self.SRXDATA = SA_I2C0_SRXDATA(self, 0x1260)
        self.STXDATA = SA_I2C0_STXDATA(self, 0x1264)
        self.SACKCTL = SA_I2C0_SACKCTL(self, 0x1268)
        self.SFIFOCTL = SA_I2C0_SFIFOCTL(self, 0x126C)
        self.SFIFOSR = SA_I2C0_SFIFOSR(self, 0x1270)
        self.SLAVE_PECCTL = SA_I2C0_SLAVE_PECCTL(self, 0x1274)
        self.SLAVE_PECSR = SA_I2C0_SLAVE_PECSR(self, 0x1278)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

I2C0 = SA_I2C0(0x400F0000, "I2C0")

class SA_SYSCTL_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "SYSCTL interrupt index")
        self.STAT = BitField(self, 0x0000000F, "STAT", "The SYSCTL interrupt index (IIDX) register generates a value corresponding to the highest priority pending interrupt source. This value may be used as an address offset for fast, deterministic handling in the interrupt service routine. A read of the IIDX register will clear the corresponding interrupt status in the RIS and MIS registers.")

class SA_SYSCTL_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "SYSCTL interrupt mask")
        self.LFOSCGOOD = BitField(self, 0x00000001, "LFOSCGOOD", "Enable or disable the LFOSCGOOD interrupt. LFOSCGOOD indicates that the LFOSC has started successfully.")
        self.HFCLKGOOD = BitField(self, 0x00000020, "HFCLKGOOD", "HFCLK GOOD")
        self.SRAMSEC = BitField(self, 0x00000008, "SRAMSEC", "SRAM Single Error Correct")
        self.LFXTGOOD = BitField(self, 0x00000010, "LFXTGOOD", "LFXT GOOD")
        self.HSCLKGOOD = BitField(self, 0x00000080, "HSCLKGOOD", "HSCLK GOOD")
        self.SYSPLLGOOD = BitField(self, 0x00000040, "SYSPLLGOOD", "SYSPLL GOOD")
        self.ANACLKERR = BitField(self, 0x00000002, "ANACLKERR", "Analog Clocking Consistency Error")
        self.FLASHSEC = BitField(self, 0x00000004, "FLASHSEC", "Flash Single Error Correct")

class SA_SYSCTL_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "SYSCTL raw interrupt status")
        self.LFOSCGOOD = BitField(self, 0x00000001, "LFOSCGOOD", "Raw status of the LFOSCGOOD interrupt.")
        self.HFCLKGOOD = BitField(self, 0x00000020, "HFCLKGOOD", "HFCLK GOOD")
        self.SRAMSEC = BitField(self, 0x00000008, "SRAMSEC", "SRAM Single Error Correct")
        self.LFXTGOOD = BitField(self, 0x00000010, "LFXTGOOD", "LFXT GOOD")
        self.HSCLKGOOD = BitField(self, 0x00000080, "HSCLKGOOD", "HSCLK GOOD")
        self.SYSPLLGOOD = BitField(self, 0x00000040, "SYSPLLGOOD", "SYSPLL GOOD")
        self.ANACLKERR = BitField(self, 0x00000002, "ANACLKERR", "Analog Clocking Consistency Error")
        self.FLASHSEC = BitField(self, 0x00000004, "FLASHSEC", "Flash Single Error Correct")

class SA_SYSCTL_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "SYSCTL masked interrupt status")
        self.LFOSCGOOD = BitField(self, 0x00000001, "LFOSCGOOD", "Masked status of the LFOSCGOOD interrupt.")
        self.HFCLKGOOD = BitField(self, 0x00000020, "HFCLKGOOD", "HFCLK GOOD")
        self.SRAMSEC = BitField(self, 0x00000008, "SRAMSEC", "SRAM Single Error Correct")
        self.LFXTGOOD = BitField(self, 0x00000010, "LFXTGOOD", "LFXT GOOD")
        self.HSCLKGOOD = BitField(self, 0x00000080, "HSCLKGOOD", "HSCLK GOOD")
        self.SYSPLLGOOD = BitField(self, 0x00000040, "SYSPLLGOOD", "SYSPLL GOOD")
        self.ANACLKERR = BitField(self, 0x00000002, "ANACLKERR", "Analog Clocking Consistency Error")
        self.FLASHSEC = BitField(self, 0x00000004, "FLASHSEC", "Flash Single Error Correct")

class SA_SYSCTL_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "SYSCTL interrupt set")
        self.LFOSCGOOD = BitField(self, 0x00000001, "LFOSCGOOD", "Set the LFOSCGOOD interrupt.")
        self.HFCLKGOOD = BitField(self, 0x00000020, "HFCLKGOOD", "HFCLK GOOD")
        self.SRAMSEC = BitField(self, 0x00000008, "SRAMSEC", "SRAM Single Error Correct")
        self.LFXTGOOD = BitField(self, 0x00000010, "LFXTGOOD", "LFXT GOOD")
        self.HSCLKGOOD = BitField(self, 0x00000080, "HSCLKGOOD", "HSCLK GOOD")
        self.SYSPLLGOOD = BitField(self, 0x00000040, "SYSPLLGOOD", "SYSPLL GOOD")
        self.ANACLKERR = BitField(self, 0x00000002, "ANACLKERR", "Analog Clocking Consistency Error")
        self.FLASHSEC = BitField(self, 0x00000004, "FLASHSEC", "Flash Single Error Correct")

class SA_SYSCTL_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "SYSCTL interrupt clear")
        self.LFOSCGOOD = BitField(self, 0x00000001, "LFOSCGOOD", "Clear the LFOSCGOOD interrupt.")
        self.HFCLKGOOD = BitField(self, 0x00000020, "HFCLKGOOD", "HFCLK GOOD")
        self.SRAMSEC = BitField(self, 0x00000008, "SRAMSEC", "SRAM Single Error Correct")
        self.LFXTGOOD = BitField(self, 0x00000010, "LFXTGOOD", "LFXT GOOD")
        self.HSCLKGOOD = BitField(self, 0x00000080, "HSCLKGOOD", "HSCLK GOOD")
        self.SYSPLLGOOD = BitField(self, 0x00000040, "SYSPLLGOOD", "SYSPLL GOOD")
        self.ANACLKERR = BitField(self, 0x00000002, "ANACLKERR", "Analog Clocking Consistency Error")
        self.FLASHSEC = BitField(self, 0x00000004, "FLASHSEC", "Flash Single Error Correct")

class SA_SYSCTL_NMIIIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "NMIIIDX", "NMI interrupt index")
        self.STAT = BitField(self, 0x0000000F, "STAT", "The NMI interrupt index (NMIIIDX) register generates a value corresponding to the highest priority pending NMI source. This value may be used as an address offset for fast, deterministic handling in the NMI service routine. A read of the NMIIIDX register will clear the corresponding interrupt status in the NMIRIS register.")

class SA_SYSCTL_NMIRIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "NMIRIS", "NMI raw interrupt status")
        self.WWDT1 = BitField(self, 0x00000004, "WWDT1", "Watch Dog 0 Fault")
        self.SRAMDED = BitField(self, 0x00000020, "SRAMDED", "SRAM Double Error Detect")
        self.BORLVL = BitField(self, 0x00000001, "BORLVL", "Raw status of the BORLVL NMI")
        self.FLASHDED = BitField(self, 0x00000010, "FLASHDED", "Flash Double Error Detect")
        self.WWDT0 = BitField(self, 0x00000002, "WWDT0", "Watch Dog 0 Fault")
        self.LFCLKFAIL = BitField(self, 0x00000008, "LFCLKFAIL", "LFXT-EXLF Monitor Fail")
        self.WWDT = Subscriptor(self, "WWDT{}")

class SA_SYSCTL_NMIISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "NMIISET", "NMI interrupt set")
        self.WWDT1 = BitField(self, 0x00000004, "WWDT1", "Watch Dog 0 Fault")
        self.SRAMDED = BitField(self, 0x00000020, "SRAMDED", "SRAM Double Error Detect")
        self.BORLVL = BitField(self, 0x00000001, "BORLVL", "Set the BORLVL NMI")
        self.FLASHDED = BitField(self, 0x00000010, "FLASHDED", "Flash Double Error Detect")
        self.WWDT0 = BitField(self, 0x00000002, "WWDT0", "Watch Dog 0 Fault")
        self.LFCLKFAIL = BitField(self, 0x00000008, "LFCLKFAIL", "LFXT-EXLF Monitor Fail")
        self.WWDT = Subscriptor(self, "WWDT{}")

class SA_SYSCTL_NMIICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "NMIICLR", "NMI interrupt clear")
        self.WWDT1 = BitField(self, 0x00000004, "WWDT1", "Watch Dog 0 Fault")
        self.SRAMDED = BitField(self, 0x00000020, "SRAMDED", "SRAM Double Error Detect")
        self.BORLVL = BitField(self, 0x00000001, "BORLVL", "Clr the BORLVL NMI")
        self.FLASHDED = BitField(self, 0x00000010, "FLASHDED", "Flash Double Error Detect")
        self.WWDT0 = BitField(self, 0x00000002, "WWDT0", "Watch Dog 0 Fault")
        self.LFCLKFAIL = BitField(self, 0x00000008, "LFCLKFAIL", "LFXT-EXLF Monitor Fail")
        self.WWDT = Subscriptor(self, "WWDT{}")

class SA_SYSCTL_SYSOSCCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x20000, "SYSOSCCFG", "SYSOSC configuration")
        self.USE4MHZSTOP = BitField(self, 0x00000100, "USE4MHZSTOP", "USE4MHZSTOP sets the SYSOSC stop mode frequency policy. When entering STOP mode, the SYSOSC frequency may be automatically switched to 4MHz to reduce SYSOSC power consumption.")
        self.DISABLESTOP = BitField(self, 0x00000200, "DISABLESTOP", "DISABLESTOP sets the SYSOSC stop mode enable/disable policy. When operating in STOP mode, the SYSOSC may be automatically disabled. When set, ULPCLK will run from LFCLK in STOP mode and SYSOSC will be disabled to reduce power consumption.")
        self.BLOCKASYNCALL = BitField(self, 0x00010000, "BLOCKASYNCALL", "BLOCKASYNCALL may be used to mask block all asynchronous fast clock requests, preventing hardware from dynamically changing the active clock configuration when operating in a given mode.")
        self.DISABLE = BitField(self, 0x00000400, "DISABLE", "DISABLE sets the SYSOSC enable/disable policy. SYSOSC may be powered off in RUN, SLEEP, and STOP modes to reduce power consumption. When SYSOSC is disabled, MCLK and ULPCLK are sourced from LFCLK.")
        self.FASTCPUEVENT = BitField(self, 0x00020000, "FASTCPUEVENT", "FASTCPUEVENT may be used to assert a fast clock request when an interrupt is asserted to the CPU, reducing interrupt latency.")
        self.FREQ = BitField(self, 0x00000003, "FREQ", "Target operating frequency for the system oscillator (SYSOSC)")

class SA_SYSCTL_HSCLKEN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "HSCLKEN", "High-speed clock (HSCLK) source enable/disable")
        self.HFXTEN = BitField(self, 0x00000001, "HFXTEN", "HFXTEN enables or disables the high frequency crystal oscillator (HFXT).")
        self.USEEXTHFCLK = BitField(self, 0x00010000, "USEEXTHFCLK", "USEEXTHFCLK selects the HFCLK_IN digital clock input to be the source for HFCLK. When disabled, HFXT is the HFCLK source and HFXTEN may be set. Do not set HFXTEN and USEEXTHFCLK simultaneously.")
        self.SYSPLLEN = BitField(self, 0x00000100, "SYSPLLEN", "SYSPLLEN enables or disables the system phase-lock loop (SYSPLL).")

class SA_SYSCTL_SYSPLLCFG0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SYSPLLCFG0", "SYSPLL reference and output configuration")
        self.ENABLECLK0 = BitField(self, 0x00000010, "ENABLECLK0", "ENABLECLK0 enables or disables the SYSPLLCLK0 output.")
        self.ENABLECLK1 = BitField(self, 0x00000020, "ENABLECLK1", "ENABLECLK1 enables or disables the SYSPLLCLK1 output.")
        self.RDIVCLK1 = BitField(self, 0x0000F000, "RDIVCLK1", "RDIVCLK1 sets the final divider for the SYSPLLCLK1 output.")
        self.MCLK2XVCO = BitField(self, 0x00000002, "MCLK2XVCO", "MCLK2XVCO selects the SYSPLL output which is sent to the HSCLK mux for use by MCLK.")
        self.RDIVCLK2X = BitField(self, 0x000F0000, "RDIVCLK2X", "RDIVCLK2X sets the final divider for the SYSPLLCLK2X output.")
        self.RDIVCLK0 = BitField(self, 0x00000F00, "RDIVCLK0", "RDIVCLK0 sets the final divider for the SYSPLLCLK0 output.")
        self.SYSPLLREF = BitField(self, 0x00000001, "SYSPLLREF", "SYSPLLREF selects the system PLL (SYSPLL) reference clock source.")
        self.ENABLECLK2X = BitField(self, 0x00000040, "ENABLECLK2X", "ENABLECLK2X enables or disables the SYSPLLCLK2X output.")
        self.RDIVCLK = Subscriptor(self, "RDIVCLK{}")
        self.ENABLECLK = Subscriptor(self, "ENABLECLK{}")

class SA_SYSCTL_SYSPLLCFG1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SYSPLLCFG1", "SYSPLL reference and feedback divider")
        self.PDIV = BitField(self, 0x00000003, "PDIV", "PDIV selects the SYSPLL reference clock prescale divider.")
        self.QDIV = BitField(self, 0x00007F00, "QDIV", "QDIV selects the SYSPLL feedback path divider.")

class SA_SYSCTL_SYSPLLPARAM0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SYSPLLPARAM0", "SYSPLL PARAM0 (load from FACTORY region)")
        self.CPCURRENT = BitField(self, 0x003F0000, "CPCURRENT", "Charge pump current")
        self.CAPBOVERRIDE = BitField(self, 0x80000000, "CAPBOVERRIDE", "CAPBOVERRIDE controls the override for Cap B")
        self.STARTTIME = BitField(self, 0x0000003F, "STARTTIME", "Startup time from enable to locked clock, in 1us resolution")
        self.CAPBVAL = BitField(self, 0x1F000000, "CAPBVAL", "Override value for Cap B")
        self.STARTTIMELP = BitField(self, 0x00003F00, "STARTTIMELP", "Startup time from low power mode exit to locked clock, in 1us resolution")

class SA_SYSCTL_SYSPLLPARAM1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SYSPLLPARAM1", "SYSPLL PARAM1 (load from FACTORY region)")
        self.LPFCAPA = BitField(self, 0x0000001F, "LPFCAPA", "Loop filter Cap A")
        self.LPFRESC = BitField(self, 0xFF000000, "LPFRESC", "Loop filter Res C")
        self.LPFRESA = BitField(self, 0x0003FF00, "LPFRESA", "Loop filter Res A")

class SA_SYSCTL_GENCLKEN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GENCLKEN", "General clock enable control")
        self.EXCLKEN = BitField(self, 0x00000001, "EXCLKEN", "EXCLKEN enables the CLK_OUT external clock output block.")
        self.MFPCLKEN = BitField(self, 0x00000010, "MFPCLKEN", "MFPCLKEN enables the middle frequency precision clock (MFPCLK).")

class SA_SYSCTL_PMODECFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PMODECFG", "Power mode configuration")
        self.DSLEEP = BitField(self, 0x00000003, "DSLEEP", "DSLEEP selects the operating mode to enter upon a DEEPSLEEP request from the CPU.")

class SA_SYSCTL_FCC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FCC", "Frequency clock counter (FCC) count")
        self.DATA = BitField(self, 0x003FFFFF, "DATA", "Frequency clock counter (FCC) count value.")

class SA_SYSCTL_SYSOSCTRIMUSER(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SYSOSCTRIMUSER", "SYSOSC user-specified trim")
        self.RESCOARSE = BitField(self, 0x00003F00, "RESCOARSE", "RESCOARSE specifies the resister coarse trim. This value changes with the target frequency.")
        self.RESFINE = BitField(self, 0x000F0000, "RESFINE", "RESFINE specifies the resister fine trim. This value changes with the target frequency.")
        self.RDIV = BitField(self, 0x1FF00000, "RDIV", "RDIV specifies the frequency correction loop (FCL) resistor trim. This value changes with the target frequency.")
        self.FREQ = BitField(self, 0x00000003, "FREQ", "FREQ specifies the target user-trimmed frequency for SYSOSC.")
        self.CAP = BitField(self, 0x00000070, "CAP", "CAP specifies the SYSOSC capacitor trim. This value changes with the target frequency.")

class SA_SYSCTL_SRAMBOUNDARY(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SRAMBOUNDARY", "SRAM Write Boundary")
        self.ADDR = BitField(self, 0x000FFFE0, "ADDR", "SRAM boundary configuration. The value configured into this acts such that: SRAM accesses to addresses less than or equal value will be RW only. SRAM accesses to addresses greater than value will be RX only. Value of 0 is not valid (system will have no stack). If set to 0, the system acts as if the entire SRAM is RWX. Any non-zero value can be configured, including a value = SRAM size.")

class SA_SYSCTL_SYSTEMCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x6, "SYSTEMCFG", "System configuration")
        self.KEY = BitField(self, 0xFF000000, "KEY", "The key value of 1Bh (27) must be written to KEY together with contents to be updated. Reads as 0")
        self.FLASHECCRSTDIS = BitField(self, 0x00000004, "FLASHECCRSTDIS", "FLASHECCRSTDIS specifies whether a flash ECC double error detect (DED) will trigger a SYSRST or an NMI.")
        self.WWDTLP0RSTDIS = BitField(self, 0x00000001, "WWDTLP0RSTDIS", "WWDTLP0RSTDIS specifies whether a WWDT Error Event will trigger a BOOTRST or an NMI.")
        self.WWDTLP1RSTDIS = BitField(self, 0x00000002, "WWDTLP1RSTDIS", "WWDTLP1RSTDIS specifies whether a WWDT Error Event will trigger a SYSRST or an NMI.")
        self.WWDTLPRSTDIS = Subscriptor(self, "WWDTLP{}RSTDIS")

class SA_SYSCTL_WRITELOCK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "WRITELOCK", "SYSCTL register write lockout")
        self.ACTIVE = BitField(self, 0x00000001, "ACTIVE", "ACTIVE controls whether critical SYSCTL registers are write protected or not.")

class SA_SYSCTL_DEDERRADDR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DEDERRADDR", "Memory DED Address")
        self.ADDR = BitField(self, 0xFFFFFFFF, "ADDR", "Address of MEMORY DED Error.")

class SA_SYSCTL_RSTCAUSE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCAUSE", "Reset cause")
        self.ID = BitField(self, 0x0000001F, "ID", "ID is a read-to-clear field which indicates the lowest level reset cause since the last read.")

class SA_SYSCTL_RESETLEVEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RESETLEVEL", "Reset level for application-triggered reset command")
        self.LEVEL = BitField(self, 0x00000007, "LEVEL", "LEVEL is used to specify the type of reset to be issued when RESETCMD is set to generate a software triggered reset.")

class SA_SYSCTL_RESETCMD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RESETCMD", "Execute an application-triggered reset command")
        self.KEY = BitField(self, 0xFF000000, "KEY", "The key value of E4h (228) must be written to KEY together with GO to trigger the reset.")
        self.GO = BitField(self, 0x00000001, "GO", "Execute the reset specified in RESETLEVEL.LEVEL. Must be written together with the KEY.")

class SA_SYSCTL_BORTHRESHOLD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "BORTHRESHOLD", "BOR threshold selection")
        self.LEVEL = BitField(self, 0x00000003, "LEVEL", "LEVEL specifies the desired BOR threshold and BOR mode.")

class SA_SYSCTL_BORCLRCMD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "BORCLRCMD", "Set the BOR threshold")
        self.KEY = BitField(self, 0xFF000000, "KEY", "The key value of C7h (199) must be written to KEY together with GO to trigger the clear and BOR threshold change.")
        self.GO = BitField(self, 0x00000001, "GO", "GO clears any prior BOR violation status indications and attempts to change the active BOR mode to that specified in the LEVEL field of the BORTHRESHOLD register.")

class SA_SYSCTL_SYSOSCFCLCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SYSOSCFCLCTL", "SYSOSC frequency correction loop (FCL) ROSC enable")
        self.KEY = BitField(self, 0xFF000000, "KEY", "The key value of 2Ah (42) must be written to KEY together with SETUSEFCL to enable the FCL.")
        self.SETUSEFCL = BitField(self, 0x00000001, "SETUSEFCL", "Set SETUSEFCL to enable the frequency correction loop in SYSOSC. Once enabled, this state is locked until the next BOOTRST.")
        self.SETUSEEXRES = BitField(self, 0x00000002, "SETUSEEXRES", "Set SETUSEEXRES to specify that an external resistor will be used for the FCL. An appropriate resistor must be populated on the ROSC pin. This state is locked until the next BOOTRST.")

class SA_SYSCTL_LFXTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LFXTCTL", "LFXT and LFCLK control")
        self.KEY = BitField(self, 0xFF000000, "KEY", "The key value of 91h (145) must be written to KEY together with either STARTLFXT or SETUSELFXT to set the corresponding bit.")
        self.SETUSELFXT = BitField(self, 0x00000002, "SETUSELFXT", "Set SETUSELFXT to switch LFCLK to LFXT. Once set, SETUSELFXT remains set until the next BOOTRST.")
        self.STARTLFXT = BitField(self, 0x00000001, "STARTLFXT", "Set STARTLFXT to start the low frequency crystal oscillator (LFXT). Once set, STARTLFXT remains set until the next BOOTRST.")

class SA_SYSCTL_EXLFCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EXLFCTL", "LFCLK_IN and LFCLK control")
        self.KEY = BitField(self, 0xFF000000, "KEY", "The key value of 36h (54) must be written to KEY together with SETUSEEXLF to set SETUSEEXLF.")
        self.SETUSEEXLF = BitField(self, 0x00000001, "SETUSEEXLF", "Set SETUSEEXLF to switch LFCLK to the LFCLK_IN digital clock input. Once set, SETUSEEXLF remains set until the next BOOTRST.")

class SA_SYSCTL_SHDNIOREL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SHDNIOREL", "SHUTDOWN IO release control")
        self.KEY = BitField(self, 0xFF000000, "KEY", "The key value 91h must be written to KEY together with RELEASE to set RELEASE.")
        self.RELEASE = BitField(self, 0x00000001, "RELEASE", "Set RELEASE to release the IO after a SHUTDOWN mode exit.")

class SA_SYSCTL_EXRSTPIN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EXRSTPIN", "Disable the reset function of the NRST pin")
        self.KEY = BitField(self, 0xFF000000, "KEY", "The key value 1Eh must be written together with DISABLE to disable the reset function.")
        self.DISABLE = BitField(self, 0x00000001, "DISABLE", "Set DISABLE to disable the reset function of the NRST pin. Once set, this configuration is locked until the next POR.")

class SA_SYSCTL_SWDCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SWDCFG", "Disable the SWD function on the SWD pins")
        self.KEY = BitField(self, 0xFF000000, "KEY", "The key value 62h (98) must be written to KEY together with DISBALE to disable the SWD functions.")
        self.DISABLE = BitField(self, 0x00000001, "DISABLE", "Set DISABLE to disable the SWD function on SWD pins, allowing the SWD pins to be used as GPIO.")

class SA_SYSCTL_FCCCMD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FCCCMD", "Frequency clock counter start capture")
        self.KEY = BitField(self, 0xFF000000, "KEY", "The key value 0Eh (14) must be written with GO to start a capture.")
        self.GO = BitField(self, 0x00000001, "GO", "Set GO to start a capture with the frequency clock counter (FCC).")

class SA_SYSCTL_PMUOPAMP(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PMUOPAMP", "GPAMP control")
        self.RRI = BitField(self, 0x00000030, "RRI", "RRI selects the rail-to-rail input mode.")
        self.NSEL = BitField(self, 0x0000000C, "NSEL", "NSEL selects the GPAMP negative channel input.")
        self.CHOPCLKMODE = BitField(self, 0x00000C00, "CHOPCLKMODE", "CHOPCLKMODE selects the GPAMP chopping mode.")
        self.OUTENABLE = BitField(self, 0x00000040, "OUTENABLE", "Set OUTENABLE to connect the GPAMP output signal to the GPAMP_OUT pin")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Set ENABLE to turn on the GPAMP.")
        self.CHOPCLKFREQ = BitField(self, 0x00000300, "CHOPCLKFREQ", "CHOPCLKFREQ selects the GPAMP chopping clock frequency")
        self.PCHENABLE = BitField(self, 0x00000002, "PCHENABLE", "Set PCHENABLE to enable the positive channel input.")

class SA_SYSCTL_SHUTDNSTORE0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SHUTDNSTORE0", "Shutdown storage memory (byte 0)")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Shutdown storage byte 0")

class SA_SYSCTL_SHUTDNSTORE1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SHUTDNSTORE1", "Shutdown storage memory (byte 1)")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Shutdown storage byte 1")

class SA_SYSCTL_SHUTDNSTORE2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SHUTDNSTORE2", "Shutdown storage memory (byte 2)")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Shutdown storage byte 2")

class SA_SYSCTL_SHUTDNSTORE3(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SHUTDNSTORE3", "Shutdown storage memory (byte 3)")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Shutdown storage byte 3")

class SA_SYSCTL(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "mem_map")
        self.IIDX = SA_SYSCTL_IIDX(self, 0x1020)
        self.IMASK = SA_SYSCTL_IMASK(self, 0x1028)
        self.RIS = SA_SYSCTL_RIS(self, 0x1030)
        self.MIS = SA_SYSCTL_MIS(self, 0x1038)
        self.ISET = SA_SYSCTL_ISET(self, 0x1040)
        self.ICLR = SA_SYSCTL_ICLR(self, 0x1048)
        self.NMIIIDX = SA_SYSCTL_NMIIIDX(self, 0x1050)
        self.NMIRIS = SA_SYSCTL_NMIRIS(self, 0x1060)
        self.NMIISET = SA_SYSCTL_NMIISET(self, 0x1070)
        self.NMIICLR = SA_SYSCTL_NMIICLR(self, 0x1078)
        self.SYSOSCCFG = SA_SYSCTL_SYSOSCCFG(self, 0x1100)
        self.HSCLKEN = SA_SYSCTL_HSCLKEN(self, 0x1108)
        self.SYSPLLCFG0 = SA_SYSCTL_SYSPLLCFG0(self, 0x1120)
        self.SYSPLLCFG1 = SA_SYSCTL_SYSPLLCFG1(self, 0x1124)
        self.SYSPLLPARAM0 = SA_SYSCTL_SYSPLLPARAM0(self, 0x1128)
        self.SYSPLLPARAM1 = SA_SYSCTL_SYSPLLPARAM1(self, 0x112C)
        self.GENCLKEN = SA_SYSCTL_GENCLKEN(self, 0x113C)
        self.PMODECFG = SA_SYSCTL_PMODECFG(self, 0x1140)
        self.FCC = SA_SYSCTL_FCC(self, 0x1150)
        self.SYSOSCTRIMUSER = SA_SYSCTL_SYSOSCTRIMUSER(self, 0x1170)
        self.SRAMBOUNDARY = SA_SYSCTL_SRAMBOUNDARY(self, 0x1178)
        self.SYSTEMCFG = SA_SYSCTL_SYSTEMCFG(self, 0x1180)
        self.WRITELOCK = SA_SYSCTL_WRITELOCK(self, 0x1200)
        self.DEDERRADDR = SA_SYSCTL_DEDERRADDR(self, 0x120C)
        self.RSTCAUSE = SA_SYSCTL_RSTCAUSE(self, 0x1220)
        self.RESETLEVEL = SA_SYSCTL_RESETLEVEL(self, 0x1300)
        self.RESETCMD = SA_SYSCTL_RESETCMD(self, 0x1304)
        self.BORTHRESHOLD = SA_SYSCTL_BORTHRESHOLD(self, 0x1308)
        self.BORCLRCMD = SA_SYSCTL_BORCLRCMD(self, 0x130C)
        self.SYSOSCFCLCTL = SA_SYSCTL_SYSOSCFCLCTL(self, 0x1310)
        self.LFXTCTL = SA_SYSCTL_LFXTCTL(self, 0x1314)
        self.EXLFCTL = SA_SYSCTL_EXLFCTL(self, 0x1318)
        self.SHDNIOREL = SA_SYSCTL_SHDNIOREL(self, 0x131C)
        self.EXRSTPIN = SA_SYSCTL_EXRSTPIN(self, 0x1320)
        self.SWDCFG = SA_SYSCTL_SWDCFG(self, 0x1328)
        self.FCCCMD = SA_SYSCTL_FCCCMD(self, 0x132C)
        self.PMUOPAMP = SA_SYSCTL_PMUOPAMP(self, 0x1380)
        self.SHUTDNSTORE0 = SA_SYSCTL_SHUTDNSTORE0(self, 0x1400)
        self.SHUTDNSTORE1 = SA_SYSCTL_SHUTDNSTORE1(self, 0x1404)
        self.SHUTDNSTORE2 = SA_SYSCTL_SHUTDNSTORE2(self, 0x1408)
        self.SHUTDNSTORE3 = SA_SYSCTL_SHUTDNSTORE3(self, 0x140C)
        self.SYSPLLPARAM = Subscriptor(self, "SYSPLLPARAM{}")
        self.SHUTDNSTORE = Subscriptor(self, "SHUTDNSTORE{}")
        self.SYSPLLCFG = Subscriptor(self, "SYSPLLCFG{}")

SYSCTL = SA_SYSCTL(0x400AF000, "SYSCTL")

class SA_WWDT1_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power. Note: For safety devices the power cannot be disabled once enabled.")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_WWDT1_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear [GPRCM.STAT.RESETSTKY]")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral. Note: For safety devices a watchdog reset by software is not possible.")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_WWDT1_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Window Watchdog Timer Status Register")
        self.WWDTSTAT_RUN = BitField(self, 0x00000001, "WWDTSTAT_RUN", "Watchdog running status flag.")

class SA_WWDT1_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")

class SA_WWDT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x0000001F, "STAT", "Module Interrupt Vector Value. This register provides the highest priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC.")

class SA_WWDT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.INTTIM = BitField(self, 0x00000001, "INTTIM", "Interval Timer Interrupt.")

class SA_WWDT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.INTTIM = BitField(self, 0x00000001, "INTTIM", "Interval Timer Interrupt.")

class SA_WWDT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.INTTIM = BitField(self, 0x00000001, "INTTIM", "Interval Timer Interrupt.")

class SA_WWDT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.INTTIM = BitField(self, 0x00000001, "INTTIM", "Interval Timer Interrupt.")

class SA_WWDT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.INTTIM = BitField(self, 0x00000001, "INTTIM", "Interval Timer Interrupt.")

class SA_WWDT1_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")

class SA_WWDT1_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_WWDT1_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x43, "CTL0", "Window Watchdog Timer Control Register 0")
        self.WWDTCTL0_PER = BitField(self, 0x00000070, "WWDTCTL0_PER", "Timer Period of the WWDT. These bits select the total watchdog timer count.")
        self.WWDTCTL0_WINDOW0 = BitField(self, 0x00000700, "WWDTCTL0_WINDOW0", "Closed window period in percentage of the timer interval. WWDTCTL1.WINSEL determines the active window setting (WWDTCTL0.WINDOW0 or WWDTCTL0.WINDOW1).")
        self.WWDTCTL0_MODE = BitField(self, 0x00010000, "WWDTCTL0_MODE", "Window Watchdog Timer Mode")
        self.WWDTCTL0_STISM = BitField(self, 0x00020000, "WWDTCTL0_STISM", "Stop In Sleep Mode. . The functionality of this bit requires that POLICY.HWCEN = 0. If POLICY.HWCEN = 1 the WWDT resets during sleep and needs re-configuration. Note: This bit has no effect for the global Window Watchdog as Sleep Mode is not supported.")
        self.WWDTCTL0_KEY = BitField(self, 0xFF000000, "WWDTCTL0_KEY", "KEY to allow write access to this register. . Writing to this register with an incorrect key activates the WWDT error signal to the ESM. Read as 0.")
        self.WWDTCTL0_CLKDIV = BitField(self, 0x00000007, "WWDTCTL0_CLKDIV", "Module Clock Divider, Divide the clock source by CLKDIV+1.. Divider values from /1 to /8 are possible. The clock divider is currently 4 bits. Bit 4 has no effect and should always be written with 0.")
        self.WWDTCTL0_WINDOW1 = BitField(self, 0x00007000, "WWDTCTL0_WINDOW1", "Closed window period in percentage of the timer interval. WWDTCTL1.WINSEL determines the active window setting (WWDTCTL0.WINDOW0 or WWDTCTL0.WINDOW1).")
        self.WWDTCTL0_WINDOW = Subscriptor(self, "WWDTCTL0_WINDOW{}")

class SA_WWDT1_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL1", "Window Watchdog Timer Control Register 0")
        self.WWDTCTL1_KEY = BitField(self, 0xFF000000, "WWDTCTL1_KEY", "KEY to allow write access to this register. . Writing to this register with an incorrect key activates the WWDT error signal to the ESM. Read as 0.")
        self.WWDTCTL1_WINSEL = BitField(self, 0x00000001, "WWDTCTL1_WINSEL", "Close Window Select")

class SA_WWDT1_CNTRST(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CNTRST", "Window Watchdog Timer Counter Reset Register")
        self.WWDTCNTRST_RESTART = BitField(self, 0xFFFFFFFF, "WWDTCNTRST_RESTART", "Window Watchdog Timer Counter Restart Writing 00A7h to this register restarts the WWDT Counter. . Writing any other value causes an error generation to the ESM. Read as 0.")

class SA_WWDT1(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "WWDT")
        self.PWREN = SA_WWDT1_PWREN(self, 0x800)
        self.RSTCTL = SA_WWDT1_RSTCTL(self, 0x804)
        self.STAT = SA_WWDT1_STAT(self, 0x110C)
        self.PDBGCTL = SA_WWDT1_PDBGCTL(self, 0x1018)
        self.IIDX = SA_WWDT1_IIDX(self, 0x1020)
        self.IMASK = SA_WWDT1_IMASK(self, 0x1028)
        self.RIS = SA_WWDT1_RIS(self, 0x1030)
        self.MIS = SA_WWDT1_MIS(self, 0x1038)
        self.ISET = SA_WWDT1_ISET(self, 0x1040)
        self.ICLR = SA_WWDT1_ICLR(self, 0x1048)
        self.EVT_MODE = SA_WWDT1_EVT_MODE(self, 0x10E0)
        self.DESC = SA_WWDT1_DESC(self, 0x10FC)
        self.CTL0 = SA_WWDT1_CTL0(self, 0x1100)
        self.CTL1 = SA_WWDT1_CTL1(self, 0x1104)
        self.CNTRST = SA_WWDT1_CNTRST(self, 0x1108)
        self.CTL = Subscriptor(self, "CTL{}")

WWDT1 = SA_WWDT1(0x40082000, "WWDT1")

class SA_CPUSS_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT_CFG = BitField(self, 0x00000003, "INT_CFG", "Event line mode select")

class SA_CPUSS_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_CPUSS_INT_GROUP0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_GROUP0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_CPUSS_INT_GROUP0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF, "INT_GROUP0_IMASK", "Interrupt mask")
        self.INT = BitField(self, 0x000000FF, "INT", "Masks the corresponding interrupt")

class SA_CPUSS_INT_GROUP0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_GROUP0_RIS", "Raw interrupt status")
        self.INT = BitField(self, 0x000000FF, "INT", "Raw interrupt status for INT")

class SA_CPUSS_INT_GROUP0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_GROUP0_MIS", "Masked interrupt status")
        self.INT = BitField(self, 0x00000001, "INT", "Masked interrupt status for INT0")

class SA_CPUSS_INT_GROUP0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_GROUP0_ISET", "Interrupt set")
        self.INT = BitField(self, 0x00000001, "INT", "Sets INT in RIS register")

class SA_CPUSS_INT_GROUP0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_GROUP0_ICLR", "Interrupt clear")
        self.INT = BitField(self, 0x00000001, "INT", "Clears INT in RIS register")

class SA_CPUSS_INT_GROUP1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_GROUP1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_CPUSS_INT_GROUP1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF, "INT_GROUP1_IMASK", "Interrupt mask")
        self.INT = BitField(self, 0x000000FF, "INT", "Masks the corresponding interrupt")

class SA_CPUSS_INT_GROUP1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_GROUP1_RIS", "Raw interrupt status")
        self.INT = BitField(self, 0x00000001, "INT", "Raw interrupt status for INT")

class SA_CPUSS_INT_GROUP1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_GROUP1_MIS", "Masked interrupt status")
        self.INT = BitField(self, 0x00000001, "INT", "Masked interrupt status for INT0")

class SA_CPUSS_INT_GROUP1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_GROUP1_ISET", "Interrupt set")
        self.INT = BitField(self, 0x00000001, "INT", "Sets INT in RIS register")

class SA_CPUSS_INT_GROUP1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_GROUP1_ICLR", "Interrupt clear")
        self.INT = BitField(self, 0x00000001, "INT", "Clears INT in RIS register")

class SA_CPUSS_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x7, "CTL", "Prefetch/Cache control")
        self.PREFETCH = BitField(self, 0x00000001, "PREFETCH", "Used to enable/disable instruction prefetch to Flash.")
        self.ICACHE = BitField(self, 0x00000002, "ICACHE", "Used to enable/disable Instruction caching on flash access.")
        self.LITEN = BitField(self, 0x00000004, "LITEN", "Literal caching and prefetch enable. . This bit is a subset of ICACHE/PREFETCH bit i.e. literal caching or literal prefetching will only happen if ICACHE or PREFETCH bits have been set respectively When enabled, the cache and prefetcher structures inside CPUSS will cache and prefetch literals When disabled, the cache and prefetcher structures inside CPUSS will not cache and prefetch literals")

class SA_CPUSS(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "CPUSSMMR")
        self.EVT_MODE = SA_CPUSS_EVT_MODE(self, 0x10E0)
        self.DESC = SA_CPUSS_DESC(self, 0x10FC)
        self.INT_GROUP0_IIDX = SA_CPUSS_INT_GROUP0_IIDX(self, 0x1100)
        self.INT_GROUP0_IMASK = SA_CPUSS_INT_GROUP0_IMASK(self, 0x1108)
        self.INT_GROUP0_RIS = SA_CPUSS_INT_GROUP0_RIS(self, 0x1110)
        self.INT_GROUP0_MIS = SA_CPUSS_INT_GROUP0_MIS(self, 0x1118)
        self.INT_GROUP0_ISET = SA_CPUSS_INT_GROUP0_ISET(self, 0x1120)
        self.INT_GROUP0_ICLR = SA_CPUSS_INT_GROUP0_ICLR(self, 0x1128)
        self.INT_GROUP1_IIDX = SA_CPUSS_INT_GROUP1_IIDX(self, 0x1130)
        self.INT_GROUP1_IMASK = SA_CPUSS_INT_GROUP1_IMASK(self, 0x1138)
        self.INT_GROUP1_RIS = SA_CPUSS_INT_GROUP1_RIS(self, 0x1140)
        self.INT_GROUP1_MIS = SA_CPUSS_INT_GROUP1_MIS(self, 0x1148)
        self.INT_GROUP1_ISET = SA_CPUSS_INT_GROUP1_ISET(self, 0x1150)
        self.INT_GROUP1_ICLR = SA_CPUSS_INT_GROUP1_ICLR(self, 0x1158)
        self.CTL = SA_CPUSS_CTL(self, 0x1300)
        self.INT_GROUP_ISET = Subscriptor(self, "INT_GROUP{}_ISET")
        self.INT_GROUP_IIDX = Subscriptor(self, "INT_GROUP{}_IIDX")
        self.INT_GROUP_MIS = Subscriptor(self, "INT_GROUP{}_MIS")
        self.INT_GROUP_ICLR = Subscriptor(self, "INT_GROUP{}_ICLR")
        self.INT_GROUP_RIS = Subscriptor(self, "INT_GROUP{}_RIS")
        self.INT_GROUP_IMASK = Subscriptor(self, "INT_GROUP{}_IMASK")

CPUSS = SA_CPUSS(0x40400000, "CPUSS")

class SA_CANFD0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_CANFD0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_CANFD0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_CANFD0_MCAN_CREL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x32380608, "MCAN_CREL", "MCAN Core Release Register")
        self.DAY = BitField(self, 0x000000FF, "DAY", "Time Stamp Day. Two digits, BCD-coded.")
        self.MON = BitField(self, 0x0000FF00, "MON", "Time Stamp Month. Two digits, BCD-coded.")
        self.YEAR = BitField(self, 0x000F0000, "YEAR", "Time Stamp Year. One digit, BCD-coded.")
        self.SUBSTEP = BitField(self, 0x00F00000, "SUBSTEP", "Sub-Step of Core Release. One digit, BCD-coded.")
        self.STEP = BitField(self, 0x0F000000, "STEP", "Step of Core Release. One digit, BCD-coded.")
        self.REL = BitField(self, 0xF0000000, "REL", "Core Release. One digit, BCD-coded.")

class SA_CANFD0_MCAN_ENDN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x87654321, "MCAN_ENDN", "MCAN Endian Register")
        self.ETV = BitField(self, 0xFFFFFFFF, "ETV", "Endianess Test Value. Reading the constant value maintained in this register allows software to determine the endianess of the host CPU.")

class SA_CANFD0_MCAN_DBTP(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xA33, "MCAN_DBTP", "MCAN Data Bit Timing and Prescaler Register")
        self.DSJW = BitField(self, 0x0000000F, "DSJW", "Data Resynchronization Jump Width. Valid values are 0 to 15. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.DTSEG2 = BitField(self, 0x000000F0, "DTSEG2", "Data Time Segment After Sample Point. Valid values are 0 to 15. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.DTSEG1 = BitField(self, 0x00001F00, "DTSEG1", "Data Time Segment Before Sample Point. Valid values are 0 to 31. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.DBRP = BitField(self, 0x001F0000, "DBRP", "Data Bit Rate Prescaler. The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit Rate Prescaler are 0 to 31. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.TDC = BitField(self, 0x00800000, "TDC", "Transmitter Delay Compensation. 0 Transmitter Delay Compensation disabled 1 Transmitter Delay Compensation enabled +I107")
        self.DTSEG = Subscriptor(self, "DTSEG{}")

class SA_CANFD0_MCAN_TEST(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TEST", "MCAN Test Register")
        self.LBCK = BitField(self, 0x00000010, "LBCK", "Loop Back Mode. 0 Reset value, Loop Back Mode is disabled 1 Loop Back Mode is enabled Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.TX = BitField(self, 0x00000060, "TX", "Control of Transmit Pin. 00 CAN TX pin controlled by the CAN Core, updated at the end of the CAN bit time 01 Sample Point can be monitored at CAN TX pin 10 Dominant ('0') level at CAN TX pin 11 Recessive ('1') at CAN TX pin Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.RX = BitField(self, 0x00000080, "RX", "Receive Pin. Monitors the actual value of the CAN receive pin.. 0 The CAN bus is dominant (CAN RX pin = '0') 1 The CAN bus is recessive (CAN RX pin = '1')")

class SA_CANFD0_MCAN_RWD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_RWD", "MCAN RAM Watchdog")
        self.WDC = BitField(self, 0x000000FF, "WDC", "Watchdog Configuration. Start value of the Message RAM Watchdog Counter. With the reset value of &amp;quot;00&amp;quot; the counter is disabled.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.WDV = BitField(self, 0x0000FF00, "WDV", "Watchdog Value. Acutal Message RAM Watchdog Counter Value.. The RAM Watchdog monitors the READY output of the Message RAM. A Message RAM access via the MCAN's Generic Master Interface starts the Message RAM Watchdog Counter with the value configured by the WDC field. The counter is reloaded with WDC when the Message RAM signals successful completion by activating its READY output. In case there is no response from the Message RAM until the counter has counted down to zero, the counter stops and interrupt flag MCAN_IR.WDI is set. The RAM Watchdog Counter is clocked by the host (system) clock.")

class SA_CANFD0_MCAN_CCCR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x1, "MCAN_CCCR", "MCAN CC Control Register")
        self.INIT = BitField(self, 0x00000001, "INIT", "Initialization. 0 Normal Operation 1 Initialization is started Note: Due to the synchronization mechanism between the two clock domains, there may be a delay until the value written to INIT can be read back. Therefore the programmer has to assure that the previous value written to INIT has been accepted by reading INIT before setting INIT to a new value.")
        self.CCE = BitField(self, 0x00000002, "CCE", "Configuration Change Enable. 0 The CPU has no write access to the protected configuration registers 1 The CPU has write access to the protected configuration registers (while CCCR.INIT = '1') Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.ASM = BitField(self, 0x00000004, "ASM", "Restricted Operation Mode. Bit ASM can only be set by SW when both CCE and INIT are set to '1'. The bit can be reset by SW at any time.. 0 Normal CAN operation 1 Restricted Operation Mode active Qualified Write 1 to Set is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.CSA = BitField(self, 0x00000008, "CSA", "Clock Stop Acknowledge. 0 No clock stop acknowledged 1 MCAN may be set in power down by stopping the Host and CAN clocks")
        self.CSR = BitField(self, 0x00000010, "CSR", "Clock Stop Request. 0 No clock stop is requested 1 Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after all pending transfer requests have been completed and the CAN bus reached idle.")
        self.MON = BitField(self, 0x00000020, "MON", "Bus Monitoring Mode. Bit MON can only be set by SW when both CCE and INIT are set to '1'. The bit can be reset by SW at any time.. 0 Bus Monitoring Mode is disabled 1 Bus Monitoring Mode is enabled Qualified Write 1 to Set is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.DAR = BitField(self, 0x00000040, "DAR", "Disable Automatic Retransmission. 0 Automatic retransmission of messages not transmitted successfully enabled 1 Automatic retransmission disabled Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.TEST = BitField(self, 0x00000080, "TEST", "Test Mode Enable. 0 Normal operation, register TEST holds reset values 1 Test Mode, write access to register TEST enabled Qualified Write 1 to Set is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.FDOE = BitField(self, 0x00000100, "FDOE", "Flexible Datarate Operation Enable. 0 FD operation disabled 1 FD operation enabled Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.BRSE = BitField(self, 0x00000200, "BRSE", "Bit Rate Switch Enable. 0 Bit rate switching for transmissions disabled 1 Bit rate switching for transmissions enabled Note: When CAN FD operation is disabled FDOE = '0', BRSE is not evaluated. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.PXHD = BitField(self, 0x00001000, "PXHD", "Protocol Exception Handling Disable. 0 Protocol exception handling enabled 1 Protocol exception handling disabled Note: When protocol exception handling is disabled, the MCAN will transmit an error frame when it detects a protocol exception condition. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.EFBI = BitField(self, 0x00002000, "EFBI", "Edge Filtering during Bus Integration. 0 Edge filtering disabled 1 Two consecutive dominant tq required to detect an edge for hard synchronization Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.TXP = BitField(self, 0x00004000, "TXP", "Transmit Pause. If this bit is set, the MCAN pauses for two CAN bit times before starting the next transmission after itself has successfully transmitted a frame.. 0 Transmit pause disabled 1 Transmit pause enabled Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.NISO = BitField(self, 0x00008000, "NISO", "Non ISO Operation. If this bit is set, the MCAN uses the CAN FD frame format as specified by the Bosch CAN FD Specification V1.0.. 0 CAN FD frame format according to ISO 11898-1:2015 1 CAN FD frame format according to Bosch CAN FD Specification V1.0")

class SA_CANFD0_MCAN_NBTP(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x6000A03, "MCAN_NBTP", "MCAN Nominal Bit Timing and Prescaler Register")
        self.NTSEG2 = BitField(self, 0x0000007F, "NTSEG2", "Nominal Time Segment After Sample Point. Valid values are 1 to 127. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.NTSEG1 = BitField(self, 0x0000FF00, "NTSEG1", "Nominal Time Segment Before Sample Point. Valid values are 1 to 255. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.NBRP = BitField(self, 0x01FF0000, "NBRP", "Nominal Bit Rate Prescaler. The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.NSJW = BitField(self, 0xFE000000, "NSJW", "Nominal (Re)Synchronization Jump Width. Valid values are 0 to 127. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.NTSEG = Subscriptor(self, "NTSEG{}")

class SA_CANFD0_MCAN_TSCC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TSCC", "MCAN Timestamp Counter Configuration")
        self.TSS = BitField(self, 0x00000003, "TSS", "Timestamp Select. 00 Timestamp counter value always 0x0000 01 Timestamp counter value incremented according to TCP 10 External timestamp counter value used 11 Same as &amp;quot;00&amp;quot; Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.TCP = BitField(self, 0x000F0000, "TCP", "Timestamp Counter Prescaler. Configures the timestamp and timeout counters time unit in multiples of CAN bit times. Valid values are 0 to 15. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.. Note: With CAN FD an external counter is required for timestamp generation (TSS = &amp;quot;10&amp;quot;). Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")

class SA_CANFD0_MCAN_TSCV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TSCV", "MCAN Timestamp Counter Value")
        self.TSC = BitField(self, 0x0000FFFF, "TSC", "Timestamp Counter. The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx). When TSCC.TSS = &amp;quot;01&amp;quot;, the Timestamp Counter is incremented in multiples of CAN bit times, (1...16), depending on the configuration of TSCC.TCP. A wrap around sets interrupt flag IR.TSW. Write access resets the counter to zero. When TSCC.TSS = &amp;quot;10&amp;quot;, TSC reflects the External Timestamp Counter value, and a write access has no impact.. Note: A &amp;quot;wrap around&amp;quot; is a change of the Timestamp Counter value from non-zero to zero not caused by write access to MCAN_TSCV.")

class SA_CANFD0_MCAN_TOCC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFFFF0000, "MCAN_TOCC", "MCAN Timeout Counter Configuration")
        self.ETOC = BitField(self, 0x00000001, "ETOC", "Enable Timeout Counter. 0 Timeout Counter disabled 1 Timeout Counter enabled Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.TOS = BitField(self, 0x00000006, "TOS", "Timeout Select. When operating in Continuous mode, a write to TOCV presets the counter to the value configured by TOCC.TOP and continues down-counting. When the Timeout Counter is controlled by one of the FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting is started when the first FIFO element is stored.. 00 Continuous operation 01 Timeout controlled by Tx Event FIFO 10 Timeout controlled by Rx FIFO 0 11 Timeout controlled by Rx FIFO 1 Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.TOP = BitField(self, 0xFFFF0000, "TOP", "Timeout Period. Start value of the Timeout Counter (down-counter). Configures the Timeout Period.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")

class SA_CANFD0_MCAN_TOCV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFFFF, "MCAN_TOCV", "MCAN Timeout Counter Value")
        self.TOC = BitField(self, 0x0000FFFF, "TOC", "Timeout Counter. The Timeout Counter is decremented in multiples of CAN bit times, (1...16), depending on the configuration of TSCC.TCP. When decremented to zero, interrupt flag IR.TOO is set and the Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.")

class SA_CANFD0_MCAN_ECR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_ECR", "MCAN Error Counter Register")
        self.TEC = BitField(self, 0x000000FF, "TEC", "Transmit Error Counter. Actual state of the Transmit Error Counter, values between 0 and 255.. Note: When CCCR.ASM is set, the CAN protocol controller does not increment TEC and REC when a CAN protocol error is detected, but CEL is still incremented.")
        self.REC = BitField(self, 0x00007F00, "REC", "Receive Error Counter. Actual state of the Receive Error Counter, values between 0 and 127.. Note: When CCCR.ASM is set, the CAN protocol controller does not increment TEC and REC when a CAN protocol error is detected, but CEL is still incremented.")
        self.RP = BitField(self, 0x00008000, "RP", "Receive Error Passive. 0 The Receive Error Counter is below the error passive level of 128 1 The Receive Error Counter has reached the error passive level of 128")
        self.CEL = BitField(self, 0x00FF0000, "CEL", "CAN Error Logging. The counter is incremented each time when a CAN protocol error causes the Transmit Error Counter or the Receive Error Counter to be incremented. It is reset by read access to CEL. The counter stops at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.. Note: When CCCR.ASM is set, the CAN protocol controller does not increment TEC and REC when a CAN protocol error is detected, but CEL is still incremented.")

class SA_CANFD0_MCAN_PSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x707, "MCAN_PSR", "MCAN Protocol Status Register")
        self.LEC = BitField(self, 0x00000007, "LEC", "Last Error Code. The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0' when a message has been transferred (reception or transmission) without error.. 0 No Error: No error occurred since LEC has been reset by successful reception or transmission. 1 Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed. 2 Form Error: A fixed format part of a received frame has the wrong format. 3 AckError: The message transmitted by the MCAN was not acknowledged by another node. 4 Bit1Error: During the transmission of a message (with the exception of the arbitration field), the device wanted to send a recessive level (bit of logical value '1'), but the monitored bus value was dominant. 5 Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a dominant level (data or identifier bit logical value '0'), but the monitored bus value was recessive. During Bus_Off recovery this status is set each time a sequence of 11 recessive bits has been monitored. This enables the CPU to monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at dominant or continuously disturbed). 6 CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming message does not match with the CRC calculated from the received data. 7 NoChange: Any read access to the Protocol Status Register re-initializes the LEC to '7'. When the LEC shows the value '7', no CAN bus event was detected since the last CPU read access to the Protocol Status Register. Note: When a frame in CAN FD format has reached the data phase with BRS flag set, the next CAN event (error or valid frame) will be shown in DLEC instead of LEC. An error in a fixed stuff bit of a CAN FD CRC sequence will be shown as a Form Error, not Stuff Error. Note: The Bus_Off recovery sequence (see ISO 11898-1:2015) cannot be shortened by setting or resetting CCCR.INIT. If the device goes Bus_Off, it will set CCCR.INIT of its own accord, stopping all bus activities. Once CCCR.INIT has been cleared by the CPU, the device will then wait for 129 occurrences of Bus Idle (129 * 11 consecutive recessive bits) before resuming normal operation. At the end of the Bus_Off recovery sequence, the Error Management Counters will be reset. During the waiting time after the resetting of CCCR.INIT, each time a sequence of 11 recessive bits has been monitored, a Bit0Error code is written to PSR.LEC, enabling the CPU to readily check up whether the CAN bus is stuck at dominant or continuously disturbed and to monitor the Bus_Off recovery sequence. ECR.REC is used to count these sequences.")
        self.ACT = BitField(self, 0x00000018, "ACT", "Node Activity. Monitors the module's CAN communication state.. 00 Synchronizing - node is synchronizing on CAN communication 01 Idle - node is neither receiver nor transmitter 10 Receiver - node is operating as receiver 11 Transmitter - node is operating as transmitter Note: ACT is set to &amp;quot;00&amp;quot; by a Protocol Exception Event.")
        self.EP = BitField(self, 0x00000020, "EP", "Error Passive. 0 The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected 1 The M_CAN is in the Error_Passive state")
        self.EW = BitField(self, 0x00000040, "EW", "Warning Status. 0 Both error counters are below the Error_Warning limit of 96 1 At least one of error counter has reached the Error_Warning limit of 96")
        self.BO = BitField(self, 0x00000080, "BO", "Bus_Off Status. 0 The M_CAN is not Bus_Off 1 The M_CAN is in Bus_Off state")
        self.DLEC = BitField(self, 0x00000700, "DLEC", "Data Phase Last Error Code. Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set. Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with its BRS flag set has been transferred (reception or transmission) without error.")
        self.RESI = BitField(self, 0x00000800, "RESI", "ESI Flag of Last Received CAN FD Message. This bit is set together with RFDF, independent of acceptance filtering.. 0 Last received CAN FD message did not have its ESI flag set 1 Last received CAN FD message had its ESI flag set")
        self.RBRS = BitField(self, 0x00001000, "RBRS", "BRS Flag of Last Received CAN FD Message. This bit is set together with RFDF, independent of acceptance filtering.. 0 Last received CAN FD message did not have its BRS flag set 1 Last received CAN FD message had its BRS flag set")
        self.RFDF = BitField(self, 0x00002000, "RFDF", "Received a CAN FD Message. This bit is set independent of acceptance filtering.. 0 Since this bit was reset by the CPU, no CAN FD message has been received 1 Message in CAN FD format with FDF flag set has been received")
        self.PXE = BitField(self, 0x00004000, "PXE", "Protocol Exception Event. 0 No protocol exception event occurred since last read access 1 Protocol exception event occurred")
        self.TDCV = BitField(self, 0x007F0000, "TDCV", "Transmitter Delay Compensation Value. Position of the secondary sample point, defined by the sum of the measured delay from the internal CAN TX signal to the internal CAN RX signal and TDCR.TDCO. The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.")

class SA_CANFD0_MCAN_TDCR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TDCR", "MCAN Transmitter Delay Compensation Register")
        self.TDCF = BitField(self, 0x0000007F, "TDCF", "Transmitter Delay Compensation Filter Window Length. Defines the minimum value for the SSP position, dominant edges on the internal CAN RX signal that would result in an earlier SSP position are ignored for transmitter delay measurement. The feature is enabled when TDCF is configured to a value greater than TDCO. Valid values are 0 to 127 mtq.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.TDCO = BitField(self, 0x00007F00, "TDCO", "Transmitter Delay Compensation Offset. Offset value defining the distance between the measured delay from the internal CAN TX signal to the internal CAN RX signal and the secondary sample point. Valid values are 0 to 127 mtq.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")

class SA_CANFD0_MCAN_IR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x80000000, "MCAN_IR", "MCAN Interrupt Register")
        self.RF0N = BitField(self, 0x00000001, "RF0N", "Rx FIFO 0 New Message. 0 No new message written to Rx FIFO 0 1 New message written to Rx FIFO 0")
        self.RF0W = BitField(self, 0x00000002, "RF0W", "Rx FIFO 0 Watermark Reached. 0 Rx FIFO 0 fill level below watermark 1 Rx FIFO 0 fill level reached watermark")
        self.RF0F = BitField(self, 0x00000004, "RF0F", "Rx FIFO 0 Full. 0 Rx FIFO 0 not full 1 Rx FIFO 0 full")
        self.RF0L = BitField(self, 0x00000008, "RF0L", "Rx FIFO 0 Message Lost. 0 No Rx FIFO 0 message lost 1 Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero")
        self.RF1N = BitField(self, 0x00000010, "RF1N", "Rx FIFO 1 New Message. 0 No new message written to Rx FIFO 1 1 New message written to Rx FIFO 1")
        self.RF1W = BitField(self, 0x00000020, "RF1W", "Rx FIFO 1 Watermark Reached. 0 Rx FIFO 1 fill level below watermark 1 Rx FIFO 1 fill level reached watermark")
        self.RF1F = BitField(self, 0x00000040, "RF1F", "Rx FIFO 1 Full. 0 Rx FIFO 1 not full 1 Rx FIFO 1 full")
        self.RF1L = BitField(self, 0x00000080, "RF1L", "Rx FIFO 1 Message Lost. 0 No Rx FIFO 1 message lost 1 Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero")
        self.HPM = BitField(self, 0x00000100, "HPM", "High Priority Message. 0 No high priority message received 1 High priority message received")
        self.TC = BitField(self, 0x00000200, "TC", "Transmission Completed. 0 No transmission completed 1 Transmission completed")
        self.TCF = BitField(self, 0x00000400, "TCF", "Transmission Cancellation Finished. 0 No transmission cancellation finished 1 Transmission cancellation finished")
        self.TFE = BitField(self, 0x00000800, "TFE", "Tx FIFO Empty. 0 Tx FIFO non-empty 1 Tx FIFO empty")
        self.TEFN = BitField(self, 0x00001000, "TEFN", "Tx Event FIFO New Entry. 0 Tx Event FIFO unchanged 1 Tx Handler wrote Tx Event FIFO element")
        self.TEFW = BitField(self, 0x00002000, "TEFW", "Tx Event FIFO Watermark Reached. 0 Tx Event FIFO fill level below watermark 1 Tx Event FIFO fill level reached watermark")
        self.TEFF = BitField(self, 0x00004000, "TEFF", "Tx Event FIFO Full. 0 Tx Event FIFO not full 1 Tx Event FIFO full")
        self.TEFL = BitField(self, 0x00008000, "TEFL", "Tx Event FIFO Element Lost. 0 No Tx Event FIFO element lost 1 Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero")
        self.TSW = BitField(self, 0x00010000, "TSW", "Timestamp Wraparound. 0 No timestamp counter wrap-around 1 Timestamp counter wrapped around")
        self.MRAF = BitField(self, 0x00020000, "MRAF", "Message RAM Access Failure. The flag is set, when the Rx Handler:. - has not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message storage is aborted and the Rx Handler starts processing of the following message. - was not able to write a message to the Message RAM. In this case message storage is aborted. In both cases the FIFO put index is not updated resp. the New Data flag for a dedicated Rx Buffer is not set, a partly stored message is overwritten when the next message is stored to this location. The flag is also set when the Tx Handler was not able to read a message from the Message RAM in time. In this case message transmission is aborted. In case of a Tx Handler access failure the MCAN is switched into Restricted Operation Mode. To leave Restricted Operation Mode, the Host CPU has to reset CCCR.ASM. 0 No Message RAM access failure occurred 1 Message RAM access failure occurred")
        self.TOO = BitField(self, 0x00040000, "TOO", "Timeout Occurred. 0 No timeout 1 Timeout reached")
        self.DRX = BitField(self, 0x00080000, "DRX", "Message Stored to Dedicated Rx Buffer. The flag is set whenever a received message has been stored into a dedicated Rx Buffer.. 0 No Rx Buffer updated 1 At least one received message stored into an Rx Buffer")
        self.BEU = BitField(self, 0x00200000, "BEU", "Bit Error Uncorrected. Message RAM bit error detected, uncorrected. This bit is set when a double bit error is detected by the ECC aggregator attached to the Message RAM. An uncorrected Message RAM bit error sets CCCR.INIT to '1'. This is done to avoid transmission of corrupted data.. 0 No bit error detected when reading from Message RAM 1 Bit error detected, uncorrected (e.g. parity logic)")
        self.ELO = BitField(self, 0x00400000, "ELO", "Error Logging Overflow. 0 CAN Error Logging Counter did not overflow 1 Overflow of CAN Error Logging Counter occurred")
        self.EP = BitField(self, 0x00800000, "EP", "Error Passive. 0 Error_Passive status unchanged 1 Error_Passive status changed")
        self.EW = BitField(self, 0x01000000, "EW", "Warning Status. 0 Error_Warning status unchanged 1 Error_Warning status changed")
        self.BO = BitField(self, 0x02000000, "BO", "Bus_Off Status. 0 Bus_Off status unchanged 1 Bus_Off status changed")
        self.WDI = BitField(self, 0x04000000, "WDI", "Watchdog Interrupt. 0 No Message RAM Watchdog event occurred 1 Message RAM Watchdog event due to missing READY")
        self.PEA = BitField(self, 0x08000000, "PEA", "Protocol Error in Arbitration Phase (Nominal Bit Time is used). 0 No protocol error in arbitration phase 1 Protocol error in arbitration phase detected (PSR.LEC ? 0,7)")
        self.PED = BitField(self, 0x10000000, "PED", "Protocol Error in Data Phase (Data Bit Time is used). 0 No protocol error in data phase 1 Protocol error in data phase detected (PSR.DLEC ? 0,7)")
        self.ARA = BitField(self, 0x20000000, "ARA", "Access to Reserved Address. 0 No access to reserved address occurred 1 Access to reserved address occurred")
        self.RFN = Subscriptor(self, "RF{}N")
        self.RFW = Subscriptor(self, "RF{}W")
        self.RFF = Subscriptor(self, "RF{}F")
        self.RFL = Subscriptor(self, "RF{}L")

class SA_CANFD0_MCAN_IE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_IE", "MCAN Interrupt Enable")
        self.RF0NE = BitField(self, 0x00000001, "RF0NE", "Rx FIFO 0 New Message Enable")
        self.RF0WE = BitField(self, 0x00000002, "RF0WE", "Rx FIFO 0 Watermark Reached Enable")
        self.RF0FE = BitField(self, 0x00000004, "RF0FE", "Rx FIFO 0 Full Enable")
        self.RF0LE = BitField(self, 0x00000008, "RF0LE", "Rx FIFO 0 Message Lost Enable")
        self.RF1NE = BitField(self, 0x00000010, "RF1NE", "Rx FIFO 1 New Message Enable")
        self.RF1WE = BitField(self, 0x00000020, "RF1WE", "Rx FIFO 1 Watermark Reached Enable")
        self.RF1FE = BitField(self, 0x00000040, "RF1FE", "Rx FIFO 1 Full Enable")
        self.RF1LE = BitField(self, 0x00000080, "RF1LE", "Rx FIFO 1 Message Lost Enable")
        self.HPME = BitField(self, 0x00000100, "HPME", "High Priority Message Enable")
        self.TCE = BitField(self, 0x00000200, "TCE", "Transmission Completed Enable")
        self.TCFE = BitField(self, 0x00000400, "TCFE", "Transmission Cancellation Finished Enable")
        self.TFEE = BitField(self, 0x00000800, "TFEE", "Tx FIFO Empty Enable")
        self.TEFNE = BitField(self, 0x00001000, "TEFNE", "Tx Event FIFO New Entry Enable")
        self.TEFWE = BitField(self, 0x00002000, "TEFWE", "Tx Event FIFO Watermark Reached Enable")
        self.TEFFE = BitField(self, 0x00004000, "TEFFE", "Tx Event FIFO Full Enable")
        self.TEFLE = BitField(self, 0x00008000, "TEFLE", "Tx Event FIFO Element Lost Enable")
        self.TSWE = BitField(self, 0x00010000, "TSWE", "Timestamp Wraparound Enable")
        self.MRAFE = BitField(self, 0x00020000, "MRAFE", "Message RAM Access Failure Enable")
        self.TOOE = BitField(self, 0x00040000, "TOOE", "Timeout Occurred Enable")
        self.DRXE = BitField(self, 0x00080000, "DRXE", "Message Stored to Dedicated Rx Buffer Enable")
        self.BECE = BitField(self, 0x00100000, "BECE", "Bit Error Corrected Enable. A separate interrupt line reserved for corrected bit errors is provided via the MCAN_ERROR_REGS. It advised for the user to use these registers and leave this bit cleared to '0'.")
        self.BEUE = BitField(self, 0x00200000, "BEUE", "Bit Error Uncorrected Enable")
        self.ELOE = BitField(self, 0x00400000, "ELOE", "Error Logging Overflow Enable")
        self.EPE = BitField(self, 0x00800000, "EPE", "Error Passive Enable")
        self.EWE = BitField(self, 0x01000000, "EWE", "Warning Status Enable")
        self.BOE = BitField(self, 0x02000000, "BOE", "Bus_Off Status Enable")
        self.WDIE = BitField(self, 0x04000000, "WDIE", "Watchdog Interrupt Enable")
        self.PEAE = BitField(self, 0x08000000, "PEAE", "Protocol Error in Arbitration Phase Enable")
        self.PEDE = BitField(self, 0x10000000, "PEDE", "Protocol Error in Data Phase Enable")
        self.ARAE = BitField(self, 0x20000000, "ARAE", "Access to Reserved Address Enable")
        self.RFWE = Subscriptor(self, "RF{}WE")
        self.RFNE = Subscriptor(self, "RF{}NE")
        self.RFLE = Subscriptor(self, "RF{}LE")
        self.RFFE = Subscriptor(self, "RF{}FE")

class SA_CANFD0_MCAN_ILS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_ILS", "MCAN Interrupt Line Select")
        self.RF0NL = BitField(self, 0x00000001, "RF0NL", "Rx FIFO 0 New Message Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.RF0WL = BitField(self, 0x00000002, "RF0WL", "Rx FIFO 0 Watermark Reached Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.RF0FL = BitField(self, 0x00000004, "RF0FL", "Rx FIFO 0 Full Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.RF0LL = BitField(self, 0x00000008, "RF0LL", "Rx FIFO 0 Message Lost Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.RF1NL = BitField(self, 0x00000010, "RF1NL", "Rx FIFO 1 New Message Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.RF1WL = BitField(self, 0x00000020, "RF1WL", "Rx FIFO 1 Watermark Reached Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.RF1FL = BitField(self, 0x00000040, "RF1FL", "Rx FIFO 1 Full Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.RF1LL = BitField(self, 0x00000080, "RF1LL", "Rx FIFO 1 Message Lost Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.HPML = BitField(self, 0x00000100, "HPML", "High Priority Message Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.TCL = BitField(self, 0x00000200, "TCL", "Transmission Completed Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.TCFL = BitField(self, 0x00000400, "TCFL", "Transmission Cancellation Finished Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.TFEL = BitField(self, 0x00000800, "TFEL", "Tx FIFO Empty Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.TEFNL = BitField(self, 0x00001000, "TEFNL", "Tx Event FIFO New Entry Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.TEFWL = BitField(self, 0x00002000, "TEFWL", "Tx Event FIFO Watermark Reached Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.TEFFL = BitField(self, 0x00004000, "TEFFL", "Tx Event FIFO Full Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.TEFLL = BitField(self, 0x00008000, "TEFLL", "Tx Event FIFO Element Lost Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.TSWL = BitField(self, 0x00010000, "TSWL", "Timestamp Wraparound Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.MRAFL = BitField(self, 0x00020000, "MRAFL", "Message RAM Access Failure Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.TOOL = BitField(self, 0x00040000, "TOOL", "Timeout Occurred Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.DRXL = BitField(self, 0x00080000, "DRXL", "Message Stored to Dedicated Rx Buffer Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.BECL = BitField(self, 0x00100000, "BECL", "Bit Error Corrected Line. A separate interrupt line reserved for corrected bit errors is provided via the MCAN_ERROR_REGS. It advised for the user to use these registers and leave the MCAN_IE.BECE bit cleared to '0' (disabled), thereby relegating this bit to not applicable.")
        self.BEUL = BitField(self, 0x00200000, "BEUL", "Bit Error Uncorrected Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.ELOL = BitField(self, 0x00400000, "ELOL", "Error Logging Overflow Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.EPL = BitField(self, 0x00800000, "EPL", "Error Passive Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.EWL = BitField(self, 0x01000000, "EWL", "Warning Status Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.BOL = BitField(self, 0x02000000, "BOL", "Bus_Off Status Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.WDIL = BitField(self, 0x04000000, "WDIL", "Watchdog Interrupt Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.PEAL = BitField(self, 0x08000000, "PEAL", "Protocol Error in Arbitration Phase Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.PEDL = BitField(self, 0x10000000, "PEDL", "Protocol Error in Data Phase Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.ARAL = BitField(self, 0x20000000, "ARAL", "Access to Reserved Address Line. 0 Interrupt source is assigned to Interrupt Line 0 1 Interrupt source is assigned to Interrupt Line 1")
        self.RFFL = Subscriptor(self, "RF{}FL")
        self.RFLL = Subscriptor(self, "RF{}LL")
        self.RFWL = Subscriptor(self, "RF{}WL")
        self.RFNL = Subscriptor(self, "RF{}NL")

class SA_CANFD0_MCAN_ILE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_ILE", "MCAN Interrupt Line Enable")
        self.EINT0 = BitField(self, 0x00000001, "EINT0", "Enable Interrupt Line 0. 0 Interrupt Line 0 is disabled 1 Interrupt Line 0 is enabled")
        self.EINT1 = BitField(self, 0x00000002, "EINT1", "Enable Interrupt Line 1. 0 Interrupt Line 1 is disabled 1 Interrupt Line 1 is enabled")
        self.EINT = Subscriptor(self, "EINT{}")

class SA_CANFD0_MCAN_GFC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_GFC", "MCAN Global Filter Configuration")
        self.RRFE = BitField(self, 0x00000001, "RRFE", "Reject Remote Frames Extended. 0 Filter remote frames with 29-bit extended IDs 1 Reject all remote frames with 29-bit extended IDs Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.RRFS = BitField(self, 0x00000002, "RRFS", "Reject Remote Frames Standard. 0 Filter remote frames with 11-bit standard IDs 1 Reject all remote frames with 11-bit standard IDs Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.ANFE = BitField(self, 0x0000000C, "ANFE", "Accept Non-matching Frames Extended. Defines how received messages with 29-bit IDs that do not match any element of the filter list are treated.. 00 Accept in Rx FIFO 0 01 Accept in Rx FIFO 1 10 Reject 11 Reject Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.ANFS = BitField(self, 0x00000030, "ANFS", "Accept Non-matching Frames Standard. Defines how received messages with 11-bit IDs that do not match any element of the filter list are treated.. 00 Accept in Rx FIFO 0 01 Accept in Rx FIFO 1 10 Reject 11 Reject Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")

class SA_CANFD0_MCAN_SIDFC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_SIDFC", "MCAN Standard ID Filter Configuration")
        self.FLSSA = BitField(self, 0x0000FFFC, "FLSSA", "Filter List Standard Start Address. Start address of standard Message ID filter list (32-bit word address).")
        self.LSS = BitField(self, 0x00FF0000, "LSS", "List Size Standard. 0 No standard Message ID filter 1-128 Number of standard Message ID filter elements &gt;128 Values greater than 128 are interpreted as 128")

class SA_CANFD0_MCAN_XIDFC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_XIDFC", "MCAN Extended ID Filter Configuration")
        self.FLESA = BitField(self, 0x0000FFFC, "FLESA", "List Size Extended. 0 No extended Message ID filter 1-64 Number of extended Message ID filter elements &gt;64 Values greater than 64 are interpreted as 64 Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.LSE = BitField(self, 0x007F0000, "LSE", "Filter List Extended Start Address. Start address of extended Message ID filter list (32-bit word address).. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")

class SA_CANFD0_MCAN_XIDAM(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x1FFFFFFF, "MCAN_XIDAM", "MCAN Extended ID and Mask")
        self.EIDM = BitField(self, 0x1FFFFFFF, "EIDM", "Extended ID Mask. For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all bits set to one the mask is not active.. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")

class SA_CANFD0_MCAN_HPMS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_HPMS", "MCAN High Priority Message Status")
        self.BIDX = BitField(self, 0x0000003F, "BIDX", "Buffer Index. Index of Rx FIFO element to which the message was stored. Only valid when MSI(1) = '1'.")
        self.MSI = BitField(self, 0x000000C0, "MSI", "Message Storage Indicator. 00 No FIFO selected 01 FIFO message lost 10 Message stored in FIFO 0 11 Message stored in FIFO 1")
        self.FIDX = BitField(self, 0x00007F00, "FIDX", "Filter Index. Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.")
        self.FLST = BitField(self, 0x00008000, "FLST", "Filter List. Indicates the filter list of the matching filter element.. 0 Standard Filter List 1 Extended Filter List")

class SA_CANFD0_MCAN_NDAT1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_NDAT1", "MCAN New Data 1")
        self.ND0 = BitField(self, 0x00000001, "ND0", "New Data RX Buffer 0. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND1 = BitField(self, 0x00000002, "ND1", "New Data RX Buffer 1. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND2 = BitField(self, 0x00000004, "ND2", "New Data RX Buffer 2. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND3 = BitField(self, 0x00000008, "ND3", "New Data RX Buffer 3. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND4 = BitField(self, 0x00000010, "ND4", "New Data RX Buffer 4. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND5 = BitField(self, 0x00000020, "ND5", "New Data RX Buffer 5. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND6 = BitField(self, 0x00000040, "ND6", "New Data RX Buffer 6. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND7 = BitField(self, 0x00000080, "ND7", "New Data RX Buffer 7. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND8 = BitField(self, 0x00000100, "ND8", "New Data RX Buffer 8. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND9 = BitField(self, 0x00000200, "ND9", "New Data RX Buffer 9. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND10 = BitField(self, 0x00000400, "ND10", "New Data RX Buffer 10. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND11 = BitField(self, 0x00000800, "ND11", "New Data RX Buffer 11. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND12 = BitField(self, 0x00001000, "ND12", "New Data RX Buffer 12. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND13 = BitField(self, 0x00002000, "ND13", "New Data RX Buffer 13. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND14 = BitField(self, 0x00004000, "ND14", "New Data RX Buffer 14. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND15 = BitField(self, 0x00008000, "ND15", "New Data RX Buffer 15. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND16 = BitField(self, 0x00010000, "ND16", "New Data RX Buffer 16. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND17 = BitField(self, 0x00020000, "ND17", "New Data RX Buffer 17. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND18 = BitField(self, 0x00040000, "ND18", "New Data RX Buffer 18. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND19 = BitField(self, 0x00080000, "ND19", "New Data RX Buffer 19. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND20 = BitField(self, 0x00100000, "ND20", "New Data RX Buffer 20. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND21 = BitField(self, 0x00200000, "ND21", "New Data RX Buffer 21. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND22 = BitField(self, 0x00400000, "ND22", "New Data RX Buffer 22. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND23 = BitField(self, 0x00800000, "ND23", "New Data RX Buffer 23. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND24 = BitField(self, 0x01000000, "ND24", "New Data RX Buffer 24. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND25 = BitField(self, 0x02000000, "ND25", "New Data RX Buffer 25. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND26 = BitField(self, 0x04000000, "ND26", "New Data RX Buffer 26. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND27 = BitField(self, 0x08000000, "ND27", "New Data RX Buffer 27. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND28 = BitField(self, 0x10000000, "ND28", "New Data RX Buffer 28. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND29 = BitField(self, 0x20000000, "ND29", "New Data RX Buffer 29. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND30 = BitField(self, 0x40000000, "ND30", "New Data RX Buffer 30. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND31 = BitField(self, 0x80000000, "ND31", "New Data RX Buffer 31. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND = Subscriptor(self, "ND{}")

class SA_CANFD0_MCAN_NDAT2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_NDAT2", "MCAN New Data 2")
        self.ND32 = BitField(self, 0x00000001, "ND32", "New Data RX Buffer 32. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND33 = BitField(self, 0x00000002, "ND33", "New Data RX Buffer 33. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND34 = BitField(self, 0x00000004, "ND34", "New Data RX Buffer 34. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND35 = BitField(self, 0x00000008, "ND35", "New Data RX Buffer 35. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND36 = BitField(self, 0x00000010, "ND36", "New Data RX Buffer 36. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND37 = BitField(self, 0x00000020, "ND37", "New Data RX Buffer 37. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND38 = BitField(self, 0x00000040, "ND38", "New Data RX Buffer 38. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND39 = BitField(self, 0x00000080, "ND39", "New Data RX Buffer 39. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND40 = BitField(self, 0x00000100, "ND40", "New Data RX Buffer 40. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND41 = BitField(self, 0x00000200, "ND41", "New Data RX Buffer 41. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND42 = BitField(self, 0x00000400, "ND42", "New Data RX Buffer 42. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND43 = BitField(self, 0x00000800, "ND43", "New Data RX Buffer 43. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND44 = BitField(self, 0x00001000, "ND44", "New Data RX Buffer 44. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND45 = BitField(self, 0x00002000, "ND45", "New Data RX Buffer 45. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND46 = BitField(self, 0x00004000, "ND46", "New Data RX Buffer 46. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND47 = BitField(self, 0x00008000, "ND47", "New Data RX Buffer 47. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND48 = BitField(self, 0x00010000, "ND48", "New Data RX Buffer 48. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND49 = BitField(self, 0x00020000, "ND49", "New Data RX Buffer 49. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND50 = BitField(self, 0x00040000, "ND50", "New Data RX Buffer 50. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND51 = BitField(self, 0x00080000, "ND51", "New Data RX Buffer 51. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND52 = BitField(self, 0x00100000, "ND52", "New Data RX Buffer 52. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND53 = BitField(self, 0x00200000, "ND53", "New Data RX Buffer 53. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND54 = BitField(self, 0x00400000, "ND54", "New Data RX Buffer 54. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND55 = BitField(self, 0x00800000, "ND55", "New Data RX Buffer 55. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND56 = BitField(self, 0x01000000, "ND56", "New Data RX Buffer 56. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND57 = BitField(self, 0x02000000, "ND57", "New Data RX Buffer 57. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND58 = BitField(self, 0x04000000, "ND58", "New Data RX Buffer 58. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND59 = BitField(self, 0x08000000, "ND59", "New Data RX Buffer 59. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND60 = BitField(self, 0x10000000, "ND60", "New Data RX Buffer 60. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND61 = BitField(self, 0x20000000, "ND61", "New Data RX Buffer 61. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND62 = BitField(self, 0x40000000, "ND62", "New Data RX Buffer 62. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND63 = BitField(self, 0x80000000, "ND63", "New Data RX Buffer 63. 0 Rx Buffer not updated 1 Rx Buffer updated from new message")
        self.ND = Subscriptor(self, "ND{}")

class SA_CANFD0_MCAN_RXF0C(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_RXF0C", "MCAN Rx FIFO 0 Configuration")
        self.F0SA = BitField(self, 0x0000FFFC, "F0SA", "Rx FIFO 0 Start Address. Start address of Rx FIFO 0 in Message RAM (32-bit word address).. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.F0S = BitField(self, 0x007F0000, "F0S", "Rx FIFO 0 Size. The Rx FIFO 0 elements are indexed from 0 to F0S-1.. 0 No Rx FIFO 0 1-64 Number of Rx FIFO 0 elements &gt;64 Values greater than 64 are interpreted as 64 Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.F0WM = BitField(self, 0x7F000000, "F0WM", "Rx FIFO 0 Watermark. 0 Watermark interrupt disabled 1-64 Level for Rx FIFO 0 watermark interrupt (IR.RF0W) &gt;64 Watermark interrupt disabled Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.F0OM = BitField(self, 0x80000000, "F0OM", "FIFO 0 Operation Mode. FIFO 0 can be operated in blocking or in overwrite mode.. 0 FIFO 0 blocking mode 1 FIFO 0 overwrite mode Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")

class SA_CANFD0_MCAN_RXF0S(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_RXF0S", "MCAN Rx FIFO 0 Status")
        self.F0FL = BitField(self, 0x0000007F, "F0FL", "Rx FIFO 0 Fill Level. Number of elements stored in Rx FIFO 0, range 0 to 64.")
        self.F0GI = BitField(self, 0x00003F00, "F0GI", "Rx FIFO 0 Get Index. Rx FIFO 0 read index pointer, range 0 to 63.")
        self.F0PI = BitField(self, 0x003F0000, "F0PI", "Rx FIFO 0 Put Index. Rx FIFO 0 write index pointer, range 0 to 63.")
        self.F0F = BitField(self, 0x01000000, "F0F", "Rx FIFO 0 Full. 0 Rx FIFO 0 not full 1 Rx FIFO 0 full")
        self.RF0L = BitField(self, 0x02000000, "RF0L", "Rx FIFO 0 Message Lost. This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset.. 0 No Rx FIFO 0 message lost 1 Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero Note: Overwriting the oldest message when RXF0C.F0OM = '1' will not set this flag.")

class SA_CANFD0_MCAN_RXF0A(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_RXF0A", "MCAN Rx FIFO 0 Acknowledge")
        self.F0AI = BitField(self, 0x0000003F, "F0AI", "Rx FIFO 0 Acknowledge Index. After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the buffer index of the last element read from Rx FIFO 0 to F0AI. This will set the Rx FIFO 0 Get Index RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.")

class SA_CANFD0_MCAN_RXBC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_RXBC", "MCAN Rx Buffer Configuration")
        self.RBSA = BitField(self, 0x0000FFFC, "RBSA", "Rx Buffer Start Address. Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address).. +I466")

class SA_CANFD0_MCAN_RXF1C(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_RXF1C", "MCAN Rx FIFO 1 Configuration")
        self.F1SA = BitField(self, 0x0000FFFC, "F1SA", "Rx FIFO 1 Start Address Start address of Rx FIFO 1 in Message RAM (32-bit word address).")
        self.F1S = BitField(self, 0x007F0000, "F1S", "Rx FIFO 1 Size. The Rx FIFO 1 elements are indexed from 0 to F1S - 1.. 0 No Rx FIFO 1 1-64 Number of Rx FIFO 1 elements &gt;64 Values greater than 64 are interpreted as 64 Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.F1WM = BitField(self, 0x7F000000, "F1WM", "Rx FIFO 1 Watermark. 0 Watermark interrupt disabled 1-64 Level for Rx FIFO 1 watermark interrupt (IR.RF1W) &gt;64 Watermark interrupt disabled Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.F1OM = BitField(self, 0x80000000, "F1OM", "FIFO 1 Operation Mode. FIFO 1 can be operated in blocking or in overwrite mode.. 0 FIFO 1 blocking mode 1 FIFO 1 overwrite mode Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")

class SA_CANFD0_MCAN_RXF1S(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_RXF1S", "MCAN Rx FIFO 1 Status")
        self.F1FL = BitField(self, 0x0000007F, "F1FL", "Rx FIFO 1 Fill Level. Number of elements stored in Rx FIFO 1, range 0 to 64.")
        self.F1GI = BitField(self, 0x00003F00, "F1GI", "Rx FIFO 1 Get Index. Rx FIFO 1 read index pointer, range 0 to 63.")
        self.F1PI = BitField(self, 0x003F0000, "F1PI", "Rx FIFO 1 Put Index. Rx FIFO 1 write index pointer, range 0 to 63.")
        self.F1F = BitField(self, 0x01000000, "F1F", "Rx FIFO 1 Full. 0 Rx FIFO 1 not full 1 Rx FIFO 1 full")
        self.RF1L = BitField(self, 0x02000000, "RF1L", "Rx FIFO 1 Message Lost. This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset.. 0 No Rx FIFO 1 message lost 1 Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero Note: Overwriting the oldest message when RXF1C.F1OM = '1' will not set this flag.")
        self.DMS = BitField(self, 0xC0000000, "DMS", "Debug Message Status. 00 Idle state, wait for reception of debug messages 01 Debug message A received 10 Debug messages A, B received 11 Debug messages A, B, C received")

class SA_CANFD0_MCAN_RXF1A(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_RXF1A", "MCAN Rx FIFO 1 Acknowledge")
        self.F1AI = BitField(self, 0x0000003F, "F1AI", "Rx FIFO 1 Acknowledge Index. After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the buffer index of the last element read from Rx FIFO 1 to F1AI. This will set the Rx FIFO 1 Get Index RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.")

class SA_CANFD0_MCAN_RXESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_RXESC", "MCAN Rx Buffer / FIFO Element Size Configuration")
        self.F0DS = BitField(self, 0x00000007, "F0DS", "Rx FIFO 0 Data Field Size. 000 8 byte data field 001 12 byte data field 010 16 byte data field 011 20 byte data field 100 24 byte data field 101 32 byte data field 110 48 byte data field 111 64 byte data field Note: In case the data field size of an accepted CAN frame exceeds the data field size configured for the matching Rx Buffer or Rx FIFO, only the number of bytes as configured by RXESC are stored to the Rx Buffer resp. Rx FIFO element. The rest of the frame's data field is ignored. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.F1DS = BitField(self, 0x00000070, "F1DS", "Rx FIFO 1 Data Field Size. 000 8 byte data field 001 12 byte data field 010 16 byte data field 011 20 byte data field 100 24 byte data field 101 32 byte data field 110 48 byte data field 111 64 byte data field Note: In case the data field size of an accepted CAN frame exceeds the data field size configured for the matching Rx Buffer or Rx FIFO, only the number of bytes as configured by RXESC are stored to the Rx Buffer resp. Rx FIFO element. The rest of the frame's data field is ignored. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.RBDS = BitField(self, 0x00000700, "RBDS", "Rx Buffer Data Field Size. 000 8 byte data field 001 12 byte data field 010 16 byte data field 011 20 byte data field 100 24 byte data field 101 32 byte data field 110 48 byte data field 111 64 byte data field Note: In case the data field size of an accepted CAN frame exceeds the data field size configured for the matching Rx Buffer or Rx FIFO, only the number of bytes as configured by RXESC are stored to the Rx Buffer resp. Rx FIFO element. The rest of the frame's data field is ignored. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.FDS = Subscriptor(self, "F{}DS")

class SA_CANFD0_MCAN_TXBC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXBC", "MCAN Tx Buffer Configuration")
        self.TBSA = BitField(self, 0x0000FFFC, "TBSA", "Tx Buffers Start Address. Start address of Tx Buffers section in Message RAM (32-bit word address).. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.NDTB = BitField(self, 0x003F0000, "NDTB", "Number of Dedicated Transmit Buffers. 0 No Dedicated Tx Buffers 1-32 Number of Dedicated Tx Buffers &gt;32 Values greater than 32 are interpreted as 32 Note: Be aware that the sum of TFQS and NDTB may be not greater than 32. There is no check for erroneous configurations. The Tx Buffers section in the Message RAM starts with the dedicated Tx Buffers. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.TFQS = BitField(self, 0x3F000000, "TFQS", "Transmit FIFO/Queue Size. 0 No Tx FIFO/Queue 1-32 Number of Tx Buffers used for Tx FIFO/Queue &gt;32 Values greater than 32 are interpreted as 32 Note: Be aware that the sum of TFQS and NDTB may be not greater than 32. There is no check for erroneous configurations. The Tx Buffers section in the Message RAM starts with the dedicated Tx Buffers. Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")
        self.TFQM = BitField(self, 0x40000000, "TFQM", "Tx FIFO/Queue Mode. 0 Tx FIFO operation 1 Tx Queue operation Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")

class SA_CANFD0_MCAN_TXFQS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXFQS", "MCAN Tx FIFO / Queue Status")
        self.TFFL = BitField(self, 0x0000003F, "TFFL", "Tx FIFO Free Level. Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when Tx Queue operation is configured (TXBC.TFQM = '1').")
        self.TFGI = BitField(self, 0x00001F00, "TFGI", "Tx FIFO Get Index. Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured (TXBC.TFQM = '1').. Note: In case of mixed configurations where dedicated Tx Buffers are combined with a Tx FIFO or a Tx Queue, the Put and Get Indices indicate the number of the Tx Buffer starting with the first dedicated Tx Buffers. Example: For a configuration of 12 dedicated Tx Buffers and a Tx FIFO of 20 Buffers a Put Index of 15 points to the fourth buffer of the Tx FIFO.")
        self.TFQP = BitField(self, 0x001F0000, "TFQP", "Tx FIFO/Queue Put Index. Tx FIFO/Queue write index pointer, range 0 to 31.. Note: In case of mixed configurations where dedicated Tx Buffers are combined with a Tx FIFO or a Tx Queue, the Put and Get Indices indicate the number of the Tx Buffer starting with the first dedicated Tx Buffers. Example: For a configuration of 12 dedicated Tx Buffers and a Tx FIFO of 20 Buffers a Put Index of 15 points to the fourth buffer of the Tx FIFO.")
        self.TFQF = BitField(self, 0x00200000, "TFQF", "Tx FIFO/Queue Full. 0 Tx FIFO/Queue not full 1 Tx FIFO/Queue full")

class SA_CANFD0_MCAN_TXESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXESC", "MCAN Tx Buffer Element Size Configuration")
        self.TBDS = BitField(self, 0x00000007, "TBDS", "Tx Buffer Data Field Size. 000 8 byte data field 001 12 byte data field 010 16 byte data field 011 20 byte data field 100 24 byte data field 101 32 byte data field 110 48 byte data field 111 64 byte data field Note: In case the data length code DLC of a Tx Buffer element is configured to a value higher than the Tx Buffer data field size TXESC.TBDS, the bytes not defined by the Tx Buffer are transmitted as &amp;quot;0xCC&amp;quot; (padding bytes). Qualified Write is possible only with CCCR.CCE='1' and CCCR.INIT='1'.")

class SA_CANFD0_MCAN_TXBRP(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXBRP", "MCAN Tx Buffer Request Pending")
        self.TRP0 = BitField(self, 0x00000001, "TRP0", "Transmission Request Pending 0.. Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR. The bits are reset after a requested transmission has completed or has been cancelled via register TXBCR. TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set, a Tx scan is started to check for the pending Tx request with the highest priority (Tx Buffer with lowest Message ID). A cancellation request resets the corresponding transmission request pending bit of register TXBRP. In case a transmission has already been started when a cancellation is requested, this is done at the end of the transmission, regardless whether the transmission was successful or not. The cancellation request bits are reset directly after the corresponding TXBRP bit has been reset. After a cancellation has been requested, a finished cancellation is signalled via TXBCF - after successful transmission together with the corresponding TXBTO bit - when the transmission has not yet been started at the point of cancellation - when the transmission has been aborted due to lost arbitration - when an error occurred during frame transmission In DAR mode all transmissions are automatically cancelled if they are not successful. The corresponding TXBCF bit is set for all unsuccessful transmissions. 0 No transmission request pending 1 Transmission request pending Note: TXBRP bits which are set while a Tx scan is in progress are not considered during this particular Tx scan. In case a cancellation is requested for such a Tx Buffer, this Add Request is cancelled immediately, the corresponding TXBRP bit is reset.")
        self.TRP1 = BitField(self, 0x00000002, "TRP1", "Transmission Request Pending 1. See description for bit 0.")
        self.TRP2 = BitField(self, 0x00000004, "TRP2", "Transmission Request Pending 2. See description for bit 0.")
        self.TRP3 = BitField(self, 0x00000008, "TRP3", "Transmission Request Pending 3. See description for bit 0.")
        self.TRP4 = BitField(self, 0x00000010, "TRP4", "Transmission Request Pending 4. See description for bit 0.")
        self.TRP5 = BitField(self, 0x00000020, "TRP5", "Transmission Request Pending 5. See description for bit 0.")
        self.TRP6 = BitField(self, 0x00000040, "TRP6", "Transmission Request Pending 6. See description for bit 0.")
        self.TRP7 = BitField(self, 0x00000080, "TRP7", "Transmission Request Pending 7. See description for bit 0.")
        self.TRP8 = BitField(self, 0x00000100, "TRP8", "Transmission Request Pending 8. See description for bit 0.")
        self.TRP9 = BitField(self, 0x00000200, "TRP9", "Transmission Request Pending 9. See description for bit 0.")
        self.TRP10 = BitField(self, 0x00000400, "TRP10", "Transmission Request Pending 10. See description for bit 0.")
        self.TRP11 = BitField(self, 0x00000800, "TRP11", "Transmission Request Pending 11. See description for bit 0.")
        self.TRP12 = BitField(self, 0x00001000, "TRP12", "Transmission Request Pending 12. See description for bit 0.")
        self.TRP13 = BitField(self, 0x00002000, "TRP13", "Transmission Request Pending 13. See description for bit 0.")
        self.TRP14 = BitField(self, 0x00004000, "TRP14", "Transmission Request Pending 14. See description for bit 0.")
        self.TRP15 = BitField(self, 0x00008000, "TRP15", "Transmission Request Pending 15. See description for bit 0.")
        self.TRP16 = BitField(self, 0x00010000, "TRP16", "Transmission Request Pending 16. See description for bit 0.")
        self.TRP17 = BitField(self, 0x00020000, "TRP17", "Transmission Request Pending 17. See description for bit 0.")
        self.TRP18 = BitField(self, 0x00040000, "TRP18", "Transmission Request Pending 18. See description for bit 0.")
        self.TRP19 = BitField(self, 0x00080000, "TRP19", "Transmission Request Pending 19. See description for bit 0.")
        self.TRP20 = BitField(self, 0x00100000, "TRP20", "Transmission Request Pending 20. See description for bit 0.")
        self.TRP21 = BitField(self, 0x00200000, "TRP21", "Transmission Request Pending 21. See description for bit 0.")
        self.TRP22 = BitField(self, 0x00400000, "TRP22", "Transmission Request Pending 22. See description for bit 0.")
        self.TRP23 = BitField(self, 0x00800000, "TRP23", "Transmission Request Pending 23. See description for bit 0.")
        self.TRP24 = BitField(self, 0x01000000, "TRP24", "Transmission Request Pending 24. See description for bit 0.")
        self.TRP25 = BitField(self, 0x02000000, "TRP25", "Transmission Request Pending 25. See description for bit 0.")
        self.TRP26 = BitField(self, 0x04000000, "TRP26", "Transmission Request Pending 26. See description for bit 0.")
        self.TRP27 = BitField(self, 0x08000000, "TRP27", "Transmission Request Pending 27. See description for bit 0.")
        self.TRP28 = BitField(self, 0x10000000, "TRP28", "Transmission Request Pending 28. See description for bit 0.")
        self.TRP29 = BitField(self, 0x20000000, "TRP29", "Transmission Request Pending 29. See description for bit 0.")
        self.TRP30 = BitField(self, 0x40000000, "TRP30", "Transmission Request Pending 30. See description for bit 0.")
        self.TRP31 = BitField(self, 0x80000000, "TRP31", "Transmission Request Pending 31. See description for bit 0.")
        self.TRP = Subscriptor(self, "TRP{}")

class SA_CANFD0_MCAN_TXBAR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXBAR", "MCAN Tx Buffer Add Request")
        self.AR0 = BitField(self, 0x00000001, "AR0", "Add Request 0.. Each Tx Buffer has its own Add Request bit. Writing a '1' will set the corresponding Add Request bit; writing a '0' has no impact. This enables the Host to set transmission requests for multiple Tx Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC. When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan process has completed. 0 No transmission request added 1 Transmission requested added Note: If an add request is applied for a Tx Buffer with pending transmission request (corresponding TXBRP bit already set), this add request is ignored. Qualified Write is possible only with CCCR.CCE='0'")
        self.AR1 = BitField(self, 0x00000002, "AR1", "Add Request 1. See description for bit 0.")
        self.AR2 = BitField(self, 0x00000004, "AR2", "Add Request 2. See description for bit 0.")
        self.AR3 = BitField(self, 0x00000008, "AR3", "Add Request 3. See description for bit 0.")
        self.AR4 = BitField(self, 0x00000010, "AR4", "Add Request 4. See description for bit 0.")
        self.AR5 = BitField(self, 0x00000020, "AR5", "Add Request 5. See description for bit 0.")
        self.AR6 = BitField(self, 0x00000040, "AR6", "Add Request 6. See description for bit 0.")
        self.AR7 = BitField(self, 0x00000080, "AR7", "Add Request 7. See description for bit 0.")
        self.AR8 = BitField(self, 0x00000100, "AR8", "Add Request 8. See description for bit 0.")
        self.AR9 = BitField(self, 0x00000200, "AR9", "Add Request 9. See description for bit 0.")
        self.AR10 = BitField(self, 0x00000400, "AR10", "Add Request 10. See description for bit 0.")
        self.AR11 = BitField(self, 0x00000800, "AR11", "Add Request 11. See description for bit 0.")
        self.AR12 = BitField(self, 0x00001000, "AR12", "Add Request 12. See description for bit 0.")
        self.AR13 = BitField(self, 0x00002000, "AR13", "Add Request 13. See description for bit 0.")
        self.AR14 = BitField(self, 0x00004000, "AR14", "Add Request 14. See description for bit 0.")
        self.AR15 = BitField(self, 0x00008000, "AR15", "Add Request 15. See description for bit 0.")
        self.AR16 = BitField(self, 0x00010000, "AR16", "Add Request 16. See description for bit 0.")
        self.AR17 = BitField(self, 0x00020000, "AR17", "Add Request 17. See description for bit 0.")
        self.AR18 = BitField(self, 0x00040000, "AR18", "Add Request 18. See description for bit 0.")
        self.AR19 = BitField(self, 0x00080000, "AR19", "Add Request 19. See description for bit 0.")
        self.AR20 = BitField(self, 0x00100000, "AR20", "Add Request 20. See description for bit 0.")
        self.AR21 = BitField(self, 0x00200000, "AR21", "Add Request 21. See description for bit 0.")
        self.AR22 = BitField(self, 0x00400000, "AR22", "Add Request 22. See description for bit 0.")
        self.AR23 = BitField(self, 0x00800000, "AR23", "Add Request 23. See description for bit 0.")
        self.AR24 = BitField(self, 0x01000000, "AR24", "Add Request 24. See description for bit 0.")
        self.AR25 = BitField(self, 0x02000000, "AR25", "Add Request 25. See description for bit 0.")
        self.AR26 = BitField(self, 0x04000000, "AR26", "Add Request 26. See description for bit 0.")
        self.AR27 = BitField(self, 0x08000000, "AR27", "Add Request 27. See description for bit 0.")
        self.AR28 = BitField(self, 0x10000000, "AR28", "Add Request 28. See description for bit 0.")
        self.AR29 = BitField(self, 0x20000000, "AR29", "Add Request 29. See description for bit 0.")
        self.AR30 = BitField(self, 0x40000000, "AR30", "Add Request 30. See description for bit 0.")
        self.AR31 = BitField(self, 0x80000000, "AR31", "Add Request 31. See description for bit 0.")
        self.AR = Subscriptor(self, "AR{}")

class SA_CANFD0_MCAN_TXBCR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXBCR", "MCAN Tx Buffer Cancellation Request")
        self.CR0 = BitField(self, 0x00000001, "CR0", "Cancellation Request 0.. Each Tx Buffer has its own Cancellation Request bit. Writing a '1' will set the corresponding Cancellation Request bit; writing a '0' has no impact. This enables the Host to set cancellation requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset. 0 No cancellation pending 1 Cancellation pending Qualified Write is possible only with CCCR.CCE='0'")
        self.CR1 = BitField(self, 0x00000002, "CR1", "Cancellation Request 1. See description for bit 0.")
        self.CR2 = BitField(self, 0x00000004, "CR2", "Cancellation Request 2. See description for bit 0.")
        self.CR3 = BitField(self, 0x00000008, "CR3", "Cancellation Request 3. See description for bit 0.")
        self.CR4 = BitField(self, 0x00000010, "CR4", "Cancellation Request 4. See description for bit 0.")
        self.CR5 = BitField(self, 0x00000020, "CR5", "Cancellation Request 5. See description for bit 0.")
        self.CR6 = BitField(self, 0x00000040, "CR6", "Cancellation Request 6. See description for bit 0.")
        self.CR7 = BitField(self, 0x00000080, "CR7", "Cancellation Request 7. See description for bit 0.")
        self.CR8 = BitField(self, 0x00000100, "CR8", "Cancellation Request 8. See description for bit 0.")
        self.CR9 = BitField(self, 0x00000200, "CR9", "Cancellation Request 9. See description for bit 0.")
        self.CR10 = BitField(self, 0x00000400, "CR10", "Cancellation Request 10. See description for bit 0.")
        self.CR11 = BitField(self, 0x00000800, "CR11", "Cancellation Request 11. See description for bit 0.")
        self.CR12 = BitField(self, 0x00001000, "CR12", "Cancellation Request 12. See description for bit 0.")
        self.CR13 = BitField(self, 0x00002000, "CR13", "Cancellation Request 13. See description for bit 0.")
        self.CR14 = BitField(self, 0x00004000, "CR14", "Cancellation Request 14. See description for bit 0.")
        self.CR15 = BitField(self, 0x00008000, "CR15", "Cancellation Request 15. See description for bit 0.")
        self.CR16 = BitField(self, 0x00010000, "CR16", "Cancellation Request 16. See description for bit 0.")
        self.CR17 = BitField(self, 0x00020000, "CR17", "Cancellation Request 17. See description for bit 0.")
        self.CR18 = BitField(self, 0x00040000, "CR18", "Cancellation Request 18. See description for bit 0.")
        self.CR19 = BitField(self, 0x00080000, "CR19", "Cancellation Request 19. See description for bit 0.")
        self.CR20 = BitField(self, 0x00100000, "CR20", "Cancellation Request 20. See description for bit 0.")
        self.CR21 = BitField(self, 0x00200000, "CR21", "Cancellation Request 21. See description for bit 0.")
        self.CR22 = BitField(self, 0x00400000, "CR22", "Cancellation Request 22. See description for bit 0.")
        self.CR23 = BitField(self, 0x00800000, "CR23", "Cancellation Request 23. See description for bit 0.")
        self.CR24 = BitField(self, 0x01000000, "CR24", "Cancellation Request 24. See description for bit 0.")
        self.CR25 = BitField(self, 0x02000000, "CR25", "Cancellation Request 25. See description for bit 0.")
        self.CR26 = BitField(self, 0x04000000, "CR26", "Cancellation Request 26. See description for bit 0.")
        self.CR27 = BitField(self, 0x08000000, "CR27", "Cancellation Request 27. See description for bit 0.")
        self.CR28 = BitField(self, 0x10000000, "CR28", "Cancellation Request 28. See description for bit 0.")
        self.CR29 = BitField(self, 0x20000000, "CR29", "Cancellation Request 29. See description for bit 0.")
        self.CR30 = BitField(self, 0x40000000, "CR30", "Cancellation Request 30. See description for bit 0.")
        self.CR31 = BitField(self, 0x80000000, "CR31", "Cancellation Request 31. See description for bit 0.")
        self.CR = Subscriptor(self, "CR{}")

class SA_CANFD0_MCAN_TXBTO(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXBTO", "MCAN Tx Buffer Transmission Occurred")
        self.TO0 = BitField(self, 0x00000001, "TO0", "Transmission Occurred 0.. Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission is requested by writing a '1' to the corresponding bit of register TXBAR. 0 No transmission occurred 1 Transmission occurred")
        self.TO1 = BitField(self, 0x00000002, "TO1", "Transmission Occurred 1. See description for bit 0.")
        self.TO2 = BitField(self, 0x00000004, "TO2", "Transmission Occurred 2. See description for bit 0.")
        self.TO3 = BitField(self, 0x00000008, "TO3", "Transmission Occurred 3. See description for bit 0.")
        self.TO4 = BitField(self, 0x00000010, "TO4", "Transmission Occurred 4. See description for bit 0.")
        self.TO5 = BitField(self, 0x00000020, "TO5", "Transmission Occurred 5. See description for bit 0.")
        self.TO6 = BitField(self, 0x00000040, "TO6", "Transmission Occurred 6. See description for bit 0.")
        self.TO7 = BitField(self, 0x00000080, "TO7", "Transmission Occurred 7. See description for bit 0.")
        self.TO8 = BitField(self, 0x00000100, "TO8", "Transmission Occurred 8. See description for bit 0.")
        self.TO9 = BitField(self, 0x00000200, "TO9", "Transmission Occurred 9. See description for bit 0.")
        self.TO10 = BitField(self, 0x00000400, "TO10", "Transmission Occurred 10. See description for bit 0.")
        self.TO11 = BitField(self, 0x00000800, "TO11", "Transmission Occurred 11. See description for bit 0.")
        self.TO12 = BitField(self, 0x00001000, "TO12", "Transmission Occurred 12. See description for bit 0.")
        self.TO13 = BitField(self, 0x00002000, "TO13", "Transmission Occurred 13. See description for bit 0.")
        self.TO14 = BitField(self, 0x00004000, "TO14", "Transmission Occurred 14. See description for bit 0.")
        self.TO15 = BitField(self, 0x00008000, "TO15", "Transmission Occurred 15. See description for bit 0.")
        self.TO16 = BitField(self, 0x00010000, "TO16", "Transmission Occurred 16. See description for bit 0.")
        self.TO17 = BitField(self, 0x00020000, "TO17", "Transmission Occurred 17. See description for bit 0.")
        self.TO18 = BitField(self, 0x00040000, "TO18", "Transmission Occurred 18. See description for bit 0.")
        self.TO19 = BitField(self, 0x00080000, "TO19", "Transmission Occurred 19. See description for bit 0.")
        self.TO20 = BitField(self, 0x00100000, "TO20", "Transmission Occurred 20. See description for bit 0.")
        self.TO21 = BitField(self, 0x00200000, "TO21", "Transmission Occurred 21. See description for bit 0.")
        self.TO22 = BitField(self, 0x00400000, "TO22", "Transmission Occurred 22. See description for bit 0.")
        self.TO23 = BitField(self, 0x00800000, "TO23", "Transmission Occurred 23. See description for bit 0.")
        self.TO24 = BitField(self, 0x01000000, "TO24", "Transmission Occurred 24. See description for bit 0.")
        self.TO25 = BitField(self, 0x02000000, "TO25", "Transmission Occurred 25. See description for bit 0.")
        self.TO26 = BitField(self, 0x04000000, "TO26", "Transmission Occurred 26. See description for bit 0.")
        self.TO27 = BitField(self, 0x08000000, "TO27", "Transmission Occurred 27. See description for bit 0.")
        self.TO28 = BitField(self, 0x10000000, "TO28", "Transmission Occurred 28. See description for bit 0.")
        self.TO29 = BitField(self, 0x20000000, "TO29", "Transmission Occurred 29. See description for bit 0.")
        self.TO30 = BitField(self, 0x40000000, "TO30", "Transmission Occurred 30. See description for bit 0.")
        self.TO31 = BitField(self, 0x80000000, "TO31", "Transmission Occurred 31. See description for bit 0.")
        self.TO = Subscriptor(self, "TO{}")

class SA_CANFD0_MCAN_TXBCF(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXBCF", "MCAN Tx Buffer Cancellation Finished")
        self.CF0 = BitField(self, 0x00000001, "CF0", "Cancellation Finished 0.. Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a new transmission is requested by writing a '1' to the corresponding bit of register TXBAR. 0 No transmit buffer cancellation 1 Transmit buffer cancellation finished")
        self.CF1 = BitField(self, 0x00000002, "CF1", "Cancellation Finished 1. See description for bit 0.")
        self.CF2 = BitField(self, 0x00000004, "CF2", "Cancellation Finished 2. See description for bit 0.")
        self.CF3 = BitField(self, 0x00000008, "CF3", "Cancellation Finished 3. See description for bit 0.")
        self.CF4 = BitField(self, 0x00000010, "CF4", "Cancellation Finished 4. See description for bit 0.")
        self.CF5 = BitField(self, 0x00000020, "CF5", "Cancellation Finished 5. See description for bit 0.")
        self.CF6 = BitField(self, 0x00000040, "CF6", "Cancellation Finished 6. See description for bit 0.")
        self.CF7 = BitField(self, 0x00000080, "CF7", "Cancellation Finished 7. See description for bit 0.")
        self.CF8 = BitField(self, 0x00000100, "CF8", "Cancellation Finished 8. See description for bit 0.")
        self.CF9 = BitField(self, 0x00000200, "CF9", "Cancellation Finished 9. See description for bit 0.")
        self.CF10 = BitField(self, 0x00000400, "CF10", "Cancellation Finished 10. See description for bit 0.")
        self.CF11 = BitField(self, 0x00000800, "CF11", "Cancellation Finished 11. See description for bit 0.")
        self.CF12 = BitField(self, 0x00001000, "CF12", "Cancellation Finished 12. See description for bit 0.")
        self.CF13 = BitField(self, 0x00002000, "CF13", "Cancellation Finished 13. See description for bit 0.")
        self.CF14 = BitField(self, 0x00004000, "CF14", "Cancellation Finished 14. See description for bit 0.")
        self.CF15 = BitField(self, 0x00008000, "CF15", "Cancellation Finished 15. See description for bit 0.")
        self.CF16 = BitField(self, 0x00010000, "CF16", "Cancellation Finished 16. See description for bit 0.")
        self.CF17 = BitField(self, 0x00020000, "CF17", "Cancellation Finished 17. See description for bit 0.")
        self.CF18 = BitField(self, 0x00040000, "CF18", "Cancellation Finished 18. See description for bit 0.")
        self.CF19 = BitField(self, 0x00080000, "CF19", "Cancellation Finished 19. See description for bit 0.")
        self.CF20 = BitField(self, 0x00100000, "CF20", "Cancellation Finished 20. See description for bit 0.")
        self.CF21 = BitField(self, 0x00200000, "CF21", "Cancellation Finished 21. See description for bit 0.")
        self.CF22 = BitField(self, 0x00400000, "CF22", "Cancellation Finished 22. See description for bit 0.")
        self.CF23 = BitField(self, 0x00800000, "CF23", "Cancellation Finished 23. See description for bit 0.")
        self.CF24 = BitField(self, 0x01000000, "CF24", "Cancellation Finished 24. See description for bit 0.")
        self.CF25 = BitField(self, 0x02000000, "CF25", "Cancellation Finished 25. See description for bit 0.")
        self.CF26 = BitField(self, 0x04000000, "CF26", "Cancellation Finished 26. See description for bit 0.")
        self.CF27 = BitField(self, 0x08000000, "CF27", "Cancellation Finished 27. See description for bit 0.")
        self.CF28 = BitField(self, 0x10000000, "CF28", "Cancellation Finished 28. See description for bit 0.")
        self.CF29 = BitField(self, 0x20000000, "CF29", "Cancellation Finished 29. See description for bit 0.")
        self.CF30 = BitField(self, 0x40000000, "CF30", "Cancellation Finished 30. See description for bit 0.")
        self.CF31 = BitField(self, 0x80000000, "CF31", "Cancellation Finished 31. See description for bit 0.")
        self.CF = Subscriptor(self, "CF{}")

class SA_CANFD0_MCAN_TXBTIE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXBTIE", "MCAN Tx Buffer Transmission Interrupt Enable")
        self.TIE0 = BitField(self, 0x00000001, "TIE0", "Transmission Interrupt Enable 0. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE1 = BitField(self, 0x00000002, "TIE1", "Transmission Interrupt Enable 1. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE2 = BitField(self, 0x00000004, "TIE2", "Transmission Interrupt Enable 2. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE3 = BitField(self, 0x00000008, "TIE3", "Transmission Interrupt Enable 3. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE4 = BitField(self, 0x00000010, "TIE4", "Transmission Interrupt Enable 4. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE5 = BitField(self, 0x00000020, "TIE5", "Transmission Interrupt Enable 5. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE6 = BitField(self, 0x00000040, "TIE6", "Transmission Interrupt Enable 6. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE7 = BitField(self, 0x00000080, "TIE7", "Transmission Interrupt Enable 7. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE8 = BitField(self, 0x00000100, "TIE8", "Transmission Interrupt Enable 8. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE9 = BitField(self, 0x00000200, "TIE9", "Transmission Interrupt Enable 9. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE10 = BitField(self, 0x00000400, "TIE10", "Transmission Interrupt Enable 10. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE11 = BitField(self, 0x00000800, "TIE11", "Transmission Interrupt Enable 11. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE12 = BitField(self, 0x00001000, "TIE12", "Transmission Interrupt Enable 12. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE13 = BitField(self, 0x00002000, "TIE13", "Transmission Interrupt Enable 13. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE14 = BitField(self, 0x00004000, "TIE14", "Transmission Interrupt Enable 14. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE15 = BitField(self, 0x00008000, "TIE15", "Transmission Interrupt Enable 15. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE16 = BitField(self, 0x00010000, "TIE16", "Transmission Interrupt Enable 16. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE17 = BitField(self, 0x00020000, "TIE17", "Transmission Interrupt Enable 17. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE18 = BitField(self, 0x00040000, "TIE18", "Transmission Interrupt Enable 18. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE19 = BitField(self, 0x00080000, "TIE19", "Transmission Interrupt Enable 19. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE20 = BitField(self, 0x00100000, "TIE20", "Transmission Interrupt Enable 20. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE21 = BitField(self, 0x00200000, "TIE21", "Transmission Interrupt Enable 21. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE22 = BitField(self, 0x00400000, "TIE22", "Transmission Interrupt Enable 22. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE23 = BitField(self, 0x00800000, "TIE23", "Transmission Interrupt Enable 23. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE24 = BitField(self, 0x01000000, "TIE24", "Transmission Interrupt Enable 24. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE25 = BitField(self, 0x02000000, "TIE25", "Transmission Interrupt Enable 25. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE26 = BitField(self, 0x04000000, "TIE26", "Transmission Interrupt Enable 26. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE27 = BitField(self, 0x08000000, "TIE27", "Transmission Interrupt Enable 27. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE28 = BitField(self, 0x10000000, "TIE28", "Transmission Interrupt Enable 28. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE29 = BitField(self, 0x20000000, "TIE29", "Transmission Interrupt Enable 29. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE30 = BitField(self, 0x40000000, "TIE30", "Transmission Interrupt Enable 30. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE31 = BitField(self, 0x80000000, "TIE31", "Transmission Interrupt Enable 31. Each Tx Buffer has its own Transmission Interrupt Enable bit.. 0 Transmission interrupt disabled 1 Transmission interrupt enable")
        self.TIE = Subscriptor(self, "TIE{}")

class SA_CANFD0_MCAN_TXBCIE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXBCIE", "MCAN Tx Buffer Cancellation Finished Interrupt Enable")
        self.CFIE0 = BitField(self, 0x00000001, "CFIE0", "Cancellation Finished Interrupt Enable 0. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE1 = BitField(self, 0x00000002, "CFIE1", "Cancellation Finished Interrupt Enable 1. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE2 = BitField(self, 0x00000004, "CFIE2", "Cancellation Finished Interrupt Enable 2. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE3 = BitField(self, 0x00000008, "CFIE3", "Cancellation Finished Interrupt Enable 3. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE4 = BitField(self, 0x00000010, "CFIE4", "Cancellation Finished Interrupt Enable 4. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE5 = BitField(self, 0x00000020, "CFIE5", "Cancellation Finished Interrupt Enable 5. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE6 = BitField(self, 0x00000040, "CFIE6", "Cancellation Finished Interrupt Enable 6. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE7 = BitField(self, 0x00000080, "CFIE7", "Cancellation Finished Interrupt Enable 7. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE8 = BitField(self, 0x00000100, "CFIE8", "Cancellation Finished Interrupt Enable 8. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE9 = BitField(self, 0x00000200, "CFIE9", "Cancellation Finished Interrupt Enable 9. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE10 = BitField(self, 0x00000400, "CFIE10", "Cancellation Finished Interrupt Enable 10. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE11 = BitField(self, 0x00000800, "CFIE11", "Cancellation Finished Interrupt Enable 11. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE12 = BitField(self, 0x00001000, "CFIE12", "Cancellation Finished Interrupt Enable 12. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE13 = BitField(self, 0x00002000, "CFIE13", "Cancellation Finished Interrupt Enable 13. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE14 = BitField(self, 0x00004000, "CFIE14", "Cancellation Finished Interrupt Enable 14. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE15 = BitField(self, 0x00008000, "CFIE15", "Cancellation Finished Interrupt Enable 15. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE16 = BitField(self, 0x00010000, "CFIE16", "Cancellation Finished Interrupt Enable 16. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE17 = BitField(self, 0x00020000, "CFIE17", "Cancellation Finished Interrupt Enable 17. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE18 = BitField(self, 0x00040000, "CFIE18", "Cancellation Finished Interrupt Enable 18. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE19 = BitField(self, 0x00080000, "CFIE19", "Cancellation Finished Interrupt Enable 19. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE20 = BitField(self, 0x00100000, "CFIE20", "Cancellation Finished Interrupt Enable 20. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE21 = BitField(self, 0x00200000, "CFIE21", "Cancellation Finished Interrupt Enable 21. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE22 = BitField(self, 0x00400000, "CFIE22", "Cancellation Finished Interrupt Enable 22. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE23 = BitField(self, 0x00800000, "CFIE23", "Cancellation Finished Interrupt Enable 23. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE24 = BitField(self, 0x01000000, "CFIE24", "Cancellation Finished Interrupt Enable 24. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE25 = BitField(self, 0x02000000, "CFIE25", "Cancellation Finished Interrupt Enable 25. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE26 = BitField(self, 0x04000000, "CFIE26", "Cancellation Finished Interrupt Enable 26. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE27 = BitField(self, 0x08000000, "CFIE27", "Cancellation Finished Interrupt Enable 27. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE28 = BitField(self, 0x10000000, "CFIE28", "Cancellation Finished Interrupt Enable 28. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE29 = BitField(self, 0x20000000, "CFIE29", "Cancellation Finished Interrupt Enable 29. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE30 = BitField(self, 0x40000000, "CFIE30", "Cancellation Finished Interrupt Enable 30. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE31 = BitField(self, 0x80000000, "CFIE31", "Cancellation Finished Interrupt Enable 31. Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.. 0 Cancellation finished interrupt disabled 1 Cancellation finished interrupt enabled")
        self.CFIE = Subscriptor(self, "CFIE{}")

class SA_CANFD0_MCAN_TXEFC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXEFC", "MCAN Tx Event FIFO Configuration")
        self.EFSA = BitField(self, 0x0000FFFC, "EFSA", "Event FIFO Start Address. Start address of Tx Event FIFO in Message RAM (32-bit word address).")
        self.EFS = BitField(self, 0x003F0000, "EFS", "Event FIFO Size. The Tx Event FIFO elements are indexed from 0 to EFS - 1.. 0 Tx Event FIFO disabled 1-32 Number of Tx Event FIFO elements &gt;32 Values greater than 32 are interpreted as 32")
        self.EFWM = BitField(self, 0x3F000000, "EFWM", "Event FIFO Watermark. 0 Watermark interrupt disabled 1-32 Level for Tx Event FIFO watermark interrupt (IR.TEFW) &gt;32 Watermark interrupt disabled")

class SA_CANFD0_MCAN_TXEFS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXEFS", "MCAN Tx Event FIFO Status")
        self.EFFL = BitField(self, 0x0000003F, "EFFL", "Event FIFO Fill Level. Number of elements stored in Tx Event FIFO, range 0 to 32.")
        self.EFGI = BitField(self, 0x00001F00, "EFGI", "Event FIFO Get Index. Tx Event FIFO read index pointer, range 0 to 31.")
        self.EFPI = BitField(self, 0x001F0000, "EFPI", "Event FIFO Put Index.Tx Event FIFO write index pointer, range 0 to 31.")
        self.EFF = BitField(self, 0x01000000, "EFF", "Event FIFO Full. 0 Tx Event FIFO not full 1 Tx Event FIFO full")
        self.TEFL = BitField(self, 0x02000000, "TEFL", "Tx Event FIFO Element Lost. This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset.. 0 No Tx Event FIFO element lost 1 Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.")

class SA_CANFD0_MCAN_TXEFA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCAN_TXEFA", "MCAN Tx Event FIFO Acknowledge")
        self.EFAI = BitField(self, 0x0000001F, "EFAI", "Event FIFO Acknowledge Index. After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.")

class SA_CANFD0_MCANSS_PID(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x68E04901, "MCANSS_PID", "MCAN Subsystem Revision Register")
        self.MINOR = BitField(self, 0x0000003F, "MINOR", "Minor Revision of the MCAN Subsystem")
        self.MAJOR = BitField(self, 0x00000700, "MAJOR", "Major Revision of the MCAN Subsystem")
        self.MODULE_ID = BitField(self, 0x0FFF0000, "MODULE_ID", "Module Identification Number")
        self.SCHEME = BitField(self, 0xC0000000, "SCHEME", "PID Register Scheme")

class SA_CANFD0_MCANSS_CTRL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x8, "MCANSS_CTRL", "MCAN Subsystem Control Register")
        self.DBGSUSP_FREE = BitField(self, 0x00000008, "DBGSUSP_FREE", "Debug Suspend Free Bit. Enables debug suspend.. 0 Disable debug suspend 1 Enable debug suspend")
        self.WAKEUPREQEN = BitField(self, 0x00000010, "WAKEUPREQEN", "Wakeup Request Enable. Enables the MCANSS to wakeup on CAN RXD activity.. 0 Disable wakeup request 1 Enables wakeup request")
        self.AUTOWAKEUP = BitField(self, 0x00000020, "AUTOWAKEUP", "Automatic Wakeup Enable. Enables the MCANSS to automatically clear the MCAN CCCR.INIT bit, fully waking the MCAN up, on an enabled wakeup request.. 0 Disable the automatic write to CCCR.INIT 1 Enable the automatic write to CCCR.INIT")
        self.EXT_TS_CNTR_EN = BitField(self, 0x00000040, "EXT_TS_CNTR_EN", "External Timestamp Counter Enable.. 0 External timestamp counter disabled 1 External timestamp counter enabled")

class SA_CANFD0_MCANSS_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_STAT", "MCAN Subsystem Status Register")
        self.RESET = BitField(self, 0x00000001, "RESET", "Soft Reset Status.. 0 Not in reset 1 Reset is in progress")
        self.MEM_INIT_DONE = BitField(self, 0x00000002, "MEM_INIT_DONE", "Memory Initialization Done.. 0 Message RAM initialization is in progress 1 Message RAM is initialized for use")
        self.ENABLE_FDOE = BitField(self, 0x00000004, "ENABLE_FDOE", "Flexible Datarate Operation Enable. Determines whether CAN FD operation may be enabled via the MCAN core CCCR.FDOE bit (bit 8) or if only standard CAN operation is possible with this instance of the MCAN.. 0 MCAN is only capable of standard CAN communication 1 MCAN may be configured to perform CAN FD communication")

class SA_CANFD0_MCANSS_ICS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_ICS", "MCAN Subsystem Interrupt Clear Shadow Register")
        self.EXT_TS_CNTR_OVFL = BitField(self, 0x00000001, "EXT_TS_CNTR_OVFL", "External Timestamp Counter Overflow Interrupt Status Clear. Reads always return a 0.. 0 Write of '0' has no effect 1 Write of '1' clears the MCANSS_IRS.EXT_TS_CNTR_OVFL bit")

class SA_CANFD0_MCANSS_IRS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_IRS", "MCAN Subsystem Interrupt Raw Satus Register")
        self.EXT_TS_CNTR_OVFL = BitField(self, 0x00000001, "EXT_TS_CNTR_OVFL", "External Timestamp Counter Overflow Interrupt Status. This bit is set by HW or by a SW write of '1'. To clear, use the MCANSS_ICS.EXT_TS_CNTR_OVFL bit.. 0 External timestamp counter has not overflowed 1 External timestamp counter has overflowed When this bit is set to '1' by HW or SW, the MCANSS_EXT_TS_UNSERVICED_INTR_CNTR.EXT_TS_INTR_CNTR bit field will increment by 1.")

class SA_CANFD0_MCANSS_IECS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_IECS", "MCAN Subsystem Interrupt Enable Clear Shadow Register")
        self.EXT_TS_CNTR_OVFL = BitField(self, 0x00000001, "EXT_TS_CNTR_OVFL", "External Timestamp Counter Overflow Interrupt Enable Clear. Reads always return a 0.. 0 Write of '0' has no effect 1 Write of '1' clears the MCANSS_IES.EXT_TS_CNTR_OVFL bit")

class SA_CANFD0_MCANSS_IE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_IE", "MCAN Subsystem Interrupt Enable Register")
        self.EXT_TS_CNTR_OVFL = BitField(self, 0x00000001, "EXT_TS_CNTR_OVFL", "External Timestamp Counter Overflow Interrupt Enable. A write of '0' has no effect. A write of '1' sets the MCANSS_IES.EXT_TS_CNTR_OVFL bit.")

class SA_CANFD0_MCANSS_IES(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_IES", "MCAN Subsystem Interrupt Enable Status")
        self.EXT_TS_CNTR_OVFL = BitField(self, 0x00000001, "EXT_TS_CNTR_OVFL", "External Timestamp Counter Overflow Interrupt Enable Status. To set, use the CANSS_IE.EXT_TS_CNTR_OVFL bit. To clear, use the MCANSS_IECS.EXT_TS_CNTR_OVFL bit.. 0 External timestamp counter overflow interrupt is not enabled 1 External timestamp counter overflow interrupt is enabled")

class SA_CANFD0_MCANSS_EOI(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_EOI", "MCAN Subsystem End of Interrupt")
        self.EOI = BitField(self, 0x000000FF, "EOI", "End of Interrupt. A write to this register will clear the associated interrupt. If the unserviced interrupt counter is &gt; 1, another interrupt is generated.. 0x00 External TS Interrupt is cleared 0x01 MCAN(0) interrupt is cleared 0x02 MCAN(1) interrupt is cleared Other writes are ignored.")

class SA_CANFD0_MCANSS_EXT_TS_PRESCALER(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_EXT_TS_PRESCALER", "MCAN Subsystem External Timestamp Prescaler 0")
        self.PRESCALER = BitField(self, 0x00FFFFFF, "PRESCALER", "External Timestamp Prescaler Reload Value. The external timestamp count rate is the host (system) clock rate divided by this value, except in the case of 0. A zero value in this bit field will act identically to a value of 0x000001.")

class SA_CANFD0_MCANSS_EXT_TS_UNSERVICED_INTR_CNTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_EXT_TS_UNSERVICED_INTR_CNTR", "MCAN Subsystem External Timestamp Unserviced Interrupts Counter")
        self.EXT_TS_INTR_CNTR = BitField(self, 0x0000001F, "EXT_TS_INTR_CNTR", "External Timestamp Counter Unserviced Rollover Interrupts. If this value is &gt; 1, an MCANSS_EOI write of '1' to bit 0 will issue another interrupt.. The status of this bit field is affected by the MCANSS_IRS.EXT_TS_CNTR_OVFL bit field.")

class SA_CANFD0_MCANERR_REV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x66A0EA00, "MCANERR_REV", "MCAN Error Aggregator Revision Register")
        self.REVMIN = BitField(self, 0x0000003F, "REVMIN", "Minor Revision of the Error Aggregator")
        self.REVMAJ = BitField(self, 0x00000700, "REVMAJ", "Major Revision of the Error Aggregator")
        self.MODULE_ID = BitField(self, 0x0FFF0000, "MODULE_ID", "Module Identification Number")
        self.SCHEME = BitField(self, 0xC0000000, "SCHEME", "PID Register Scheme")

class SA_CANFD0_MCANERR_VECTOR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_VECTOR", "MCAN ECC Vector Register")
        self.ECC_VECTOR = BitField(self, 0x000007FF, "ECC_VECTOR", "ECC RAM ID. Each error detection and correction (EDC) controller has a bank of error registers (offsets 0x10 - 0x3B) associated with it. These registers are accessed via an internal serial bus (SVBUS). To access them through the ECC aggregator the controller ID desired must be written to the ECC_VECTOR field, together with the RD_SVBUS trigger and RD_SVBUS_ADDRESS bit field. This initiates the serial read which consummates by setting the RD_SVBUS_DONE bit. At this point the addressed register may be read by a normal CPU read of the appropriate offset address.. 0x000 Message RAM ECC controller is selected Others Reserved (do not use) Subsequent writes through the SVBUS (offsets 0x10 - 0x3B) have a delayed completion. To avoid conflicts, perform a read back of a register within this range after writing.")
        self.RD_SVBUS = BitField(self, 0x00008000, "RD_SVBUS", "Read Trigger")
        self.RD_SVBUS_ADDRESS = BitField(self, 0x00FF0000, "RD_SVBUS_ADDRESS", "Read Address Offset")
        self.RD_SVBUS_DONE = BitField(self, 0x01000000, "RD_SVBUS_DONE", "Read Completion Flag")

class SA_CANFD0_MCANERR_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x2, "MCANERR_STAT", "MCAN Error Misc Status")
        self.NUM_RAMS = BitField(self, 0x000007FF, "NUM_RAMS", "Number of RAMs. Number of ECC RAMs serviced by the aggregator.")

class SA_CANFD0_MCANERR_WRAP_REV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x66A46A02, "MCANERR_WRAP_REV", "MCAN ECC Wrapper Revision Register")
        self.REVMIN = BitField(self, 0x0000003F, "REVMIN", "Minor Revision of the Error Aggregator")
        self.REVMAJ = BitField(self, 0x00000700, "REVMAJ", "Major Revision of the Error Aggregator")
        self.MODULE_ID = BitField(self, 0x0FFF0000, "MODULE_ID", "Module Identification Number")
        self.SCHEME = BitField(self, 0xC0000000, "SCHEME", "PID Register Scheme")

class SA_CANFD0_MCANERR_CTRL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x187, "MCANERR_CTRL", "MCAN ECC Control")
        self.ECC_ENABLE = BitField(self, 0x00000001, "ECC_ENABLE", "Enable ECC Generation")
        self.ECC_CHECK = BitField(self, 0x00000002, "ECC_CHECK", "Enable ECC Check. ECC is completely bypassed if both ECC_ENABLE and ECC_CHECK are '0'.")
        self.ENABLE_RMW = BitField(self, 0x00000004, "ENABLE_RMW", "Enable read-modify-write on partial word writes")
        self.FORCE_SEC = BitField(self, 0x00000008, "FORCE_SEC", "Force single-bit error. Cleared on a writeback or the cycle following the error if ERROR_ONCE is asserted. For write through mode, this applies to writes as well as reads. MCANERR_ERR_CTRL1 and MCANERR_ERR_CTRL2 should be configured prior to setting this bit.")
        self.FORCE_DED = BitField(self, 0x00000010, "FORCE_DED", "Force double-bit error. Cleared the cycle following the error if ERROR_ONCE is asserted. For write through mode, this applies to writes as well as reads. MCANERR_ERR_CTRL1 and MCANERR_ERR_CTRL2 should be configured prior to setting this bit.")
        self.FORCE_N_ROW = BitField(self, 0x00000020, "FORCE_N_ROW", "Enable single/double-bit error on the next RAM read, regardless of the MCANERR_ERR_CTRL1.ECC_ROW setting. For write through mode, this applies to writes as well as reads.")
        self.ERROR_ONCE = BitField(self, 0x00000040, "ERROR_ONCE", "If this bit is set, the FORCE_SEC/FORCE_DED will inject an error to the specified row only once. The FORCE_SEC bit will be cleared once a writeback happens. If writeback is not enabled, this error will be cleared the cycle following the read when the data is corrected. For double-bit errors, the FORCE_DED bit will be cleared the cycle following the double-bit error. Any subsequent reads will not force an error.")
        self.CHECK_SVBUS_TIMEOUT = BitField(self, 0x00000100, "CHECK_SVBUS_TIMEOUT", "Enables Serial VBUS timeout mechanism")

class SA_CANFD0_MCANERR_ERR_CTRL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_ERR_CTRL1", "MCAN ECC Error Control 1 Register")
        self.ECC_ROW = BitField(self, 0xFFFFFFFF, "ECC_ROW", "Row address where FORCE_SEC or FORCE_DED needs to be applied. This is ignored if FORCE_N_ROW is set.")

class SA_CANFD0_MCANERR_ERR_CTRL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_ERR_CTRL2", "MCAN ECC Error Control 2 Register")
        self.ECC_BIT1 = BitField(self, 0x0000FFFF, "ECC_BIT1", "Column/Data bit that needs to be flipped when FORCE_SEC or FORCE_DED is set")
        self.ECC_BIT2 = BitField(self, 0xFFFF0000, "ECC_BIT2", "Second column/data bit that needs to be flipped when FORCE_DED is set")
        self.ECC_BIT = Subscriptor(self, "ECC_BIT{}")

class SA_CANFD0_MCANERR_ERR_STAT1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_ERR_STAT1", "MCAN ECC Error Status 1 Register")
        self.ECC_SEC = BitField(self, 0x00000003, "ECC_SEC", "Single Bit Error Corrected Status. A 2-bit saturating counter of the number of SEC errors that have occurred since last cleared.. 0 No single-bit error detected 1 One single-bit error was detected and corrected 2 Two single-bit errors were detected and corrected 3 Three single-bit errors were detected and corrected A write of a non-zero value to this bit field increments it by the value provided.")
        self.ECC_DED = BitField(self, 0x0000000C, "ECC_DED", "Double Bit Error Detected Status. A 2-bit saturating counter of the number of DED errors that have occurred since last cleared.. 0 No double-bit error detected 1 One double-bit error was detected 2 Two double-bit errors were detected 3 Three double-bit errors were detected A write of a non-zero value to this bit field increments it by the value provided.")
        self.ECC_OTHER = BitField(self, 0x00000010, "ECC_OTHER", "SEC While Writeback Error Status. 0 No SEC error while writeback pending 1 Indicates that successive single-bit errors have occurred while a writeback is still pending")
        self.CTRL_REG_ERROR = BitField(self, 0x00000080, "CTRL_REG_ERROR", "Control Register Error. A bit field in the control register is in an ambiguous state. This means that the redundancy registers have detected a state where not all values are the same and has defaulted to the reset state. S/W needs to re-write these registers to a known state. A write of 1 will set this interrupt flag.")
        self.CLR_ECC_SEC = BitField(self, 0x00000300, "CLR_ECC_SEC", "Clear ECC_SEC. A write of a non-zero value to this bit field decrements the ECC_SEC bit field by the value provided.")
        self.CLR_ECC_DED = BitField(self, 0x00000C00, "CLR_ECC_DED", "Clear ECC_DED. A write of a non-zero value to this bit field decrements the ECC_DED bit field by the value provided.")
        self.CLR_ECC_OTHER = BitField(self, 0x00001000, "CLR_ECC_OTHER", "Writing a '1' clears the ECC_OTHER bit.")
        self.CLR_CTRL_REG_ERROR = BitField(self, 0x00008000, "CLR_CTRL_REG_ERROR", "Writing a '1' clears the CTRL_REG_ERROR bit")
        self.ECC_BIT1 = BitField(self, 0xFFFF0000, "ECC_BIT1", "ECC Error Bit Position. Indicates the bit position in the RAM data that is in error on an SEC error. Only valid on an SEC error.. 0 Bit 0 is in error 1 Bit 1 is in error 2 Bit 2 is in error 3 Bit 3 is in error ... 31 Bit 31 is in error &gt;32 Invalid")

class SA_CANFD0_MCANERR_ERR_STAT2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_ERR_STAT2", "MCAN ECC Error Status 2 Register")
        self.ECC_ROW = BitField(self, 0xFFFFFFFF, "ECC_ROW", "Indicates the row address where the single or double-bit error occurred. This value is address offset/4.")

class SA_CANFD0_MCANERR_ERR_STAT3(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_ERR_STAT3", "MCAN ECC Error Status 3 Register")
        self.WB_PEND = BitField(self, 0x00000001, "WB_PEND", "Delayed Write Back Pending Status. 0 No write back pending 1 An ECC data correction write back is pending")
        self.SVBUS_TIMEOUT = BitField(self, 0x00000002, "SVBUS_TIMEOUT", "Serial VBUS Timeout Flag. Write 1 to set.")
        self.CLR_SVBUS_TIMEOUT = BitField(self, 0x00000200, "CLR_SVBUS_TIMEOUT", "Write 1 to clear the Serial VBUS Timeout Flag")

class SA_CANFD0_MCANERR_SEC_EOI(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_SEC_EOI", "MCAN Single Error Corrected End of Interrupt Register")
        self.EOI_WR = BitField(self, 0x00000001, "EOI_WR", "Write to this register indicates that software has acknowledged the pending interrupt and the next interrupt can be sent to the host.. Note that a write to the MCANERR_ERR_STAT1.CLR_ECC_SEC goes through the SVBUS and has a delayed completion. To avoid an additional interrupt, read the MCANERR_ERR_STAT1 register back prior to writing to this bit field.")

class SA_CANFD0_MCANERR_SEC_STATUS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_SEC_STATUS", "MCAN Single Error Corrected Interrupt Status Register")
        self.MSGMEM_PEND = BitField(self, 0x00000001, "MSGMEM_PEND", "Message RAM SEC Interrupt Pending. 0 No SEC interrupt is pending 1 SEC interrupt is pending")

class SA_CANFD0_MCANERR_SEC_ENABLE_SET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_SEC_ENABLE_SET", "MCAN Single Error Corrected Interrupt Enable Set Register")
        self.MSGMEM_ENABLE_SET = BitField(self, 0x00000001, "MSGMEM_ENABLE_SET", "Message RAM SEC Interrupt Pending Enable Set. Writing a 1 to this bit enables the Message RAM SEC error interrupts. Writing a 0 has no effect. Reads return the corresponding enable bit's current value.")

class SA_CANFD0_MCANERR_SEC_ENABLE_CLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_SEC_ENABLE_CLR", "MCAN Single Error Corrected Interrupt Enable Clear Register")
        self.MSGMEM_ENABLE_CLR = BitField(self, 0x00000001, "MSGMEM_ENABLE_CLR", "Message RAM SEC Interrupt Pending Enable Clear. Writing a 1 to this bit disables the Message RAM SEC error interrupts. Writing a 0 has no effect. Reads return the corresponding enable bit's current value.")

class SA_CANFD0_MCANERR_DED_EOI(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_DED_EOI", "MCAN Double Error Detected End of Interrupt Register")
        self.EOI_WR = BitField(self, 0x00000001, "EOI_WR", "Write to this register indicates that software has acknowledged the pending interrupt and the next interrupt can be sent to the host.. Note that a write to the MCANERR_ERR_STAT1.CLR_ECC_DED goes through the SVBUS and has a delayed completion. To avoid an additional interrupt, read the MCANERR_ERR_STAT1 register back prior to writing to this bit field.")

class SA_CANFD0_MCANERR_DED_STATUS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_DED_STATUS", "MCAN Double Error Detected Interrupt Status Register")
        self.MSGMEM_PEND = BitField(self, 0x00000001, "MSGMEM_PEND", "Message RAM DED Interrupt Pending. 0 No DED interrupt is pending 1 DED interrupt is pending")

class SA_CANFD0_MCANERR_DED_ENABLE_SET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_DED_ENABLE_SET", "MCAN Double Error Detected Interrupt Enable Set Register")
        self.MSGMEM_ENABLE_SET = BitField(self, 0x00000001, "MSGMEM_ENABLE_SET", "Message RAM DED Interrupt Pending Enable Set. Writing a 1 to this bit enables the Message RAM DED error interrupts. Writing a 0 has no effect. Reads return the corresponding enable bit's current value.")

class SA_CANFD0_MCANERR_DED_ENABLE_CLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_DED_ENABLE_CLR", "MCAN Double Error Detected Interrupt Enable Clear Register")
        self.MSGMEM_ENABLE_CLR = BitField(self, 0x00000001, "MSGMEM_ENABLE_CLR", "Message RAM DED Interrupt Pending Enable Clear. Writing a 1 to this bit disables the Message RAM DED error interrupts. Writing a 0 has no effect. Reads return the corresponding enable bit's current value.")

class SA_CANFD0_MCANERR_AGGR_ENABLE_SET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_AGGR_ENABLE_SET", "MCAN Error Aggregator Enable Set Register")
        self.ENABLE_PARITY_SET = BitField(self, 0x00000001, "ENABLE_PARITY_SET", "Write 1 to enable parity errors. Reads return the corresponding enable bit's current value.")
        self.ENABLE_TIMEOUT_SET = BitField(self, 0x00000002, "ENABLE_TIMEOUT_SET", "Write 1 to enable timeout errors. Reads return the corresponding enable bit's current value.")

class SA_CANFD0_MCANERR_AGGR_ENABLE_CLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_AGGR_ENABLE_CLR", "MCAN Error Aggregator Enable Clear Register")
        self.ENABLE_PARITY_CLR = BitField(self, 0x00000001, "ENABLE_PARITY_CLR", "Write 1 to disable parity errors. Reads return the corresponding enable bit's current value.")
        self.ENABLE_TIMEOUT_CLR = BitField(self, 0x00000002, "ENABLE_TIMEOUT_CLR", "Write 1 to disable timeout errors. Reads return the corresponding enable bit's current value.")

class SA_CANFD0_MCANERR_AGGR_STATUS_SET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_AGGR_STATUS_SET", "MCAN Error Aggregator Status Set Register")
        self.AGGR_PARITY_ERR = BitField(self, 0x00000003, "AGGR_PARITY_ERR", "Aggregator Parity Error Status. 2-bit saturating counter of the number of parity errors that have occurred since last cleared. 0 No parity errors have occurred 1 One parity error has occurred 2 Two parity errors have occurred 3 Three parity errors have occurred A write of a non-zero value to this bit field increments it by the value provided.")
        self.SVBUS_TIMEOUT = BitField(self, 0x0000000C, "SVBUS_TIMEOUT", "Aggregator Serial VBUS Timeout Error Status. 2-bit saturating counter of the number of SVBUS timeout errors that have occurred since last cleared. 0 No timeout errors have occurred 1 One timeout error has occurred 2 Two timeout errors have occurred 3 Three timeout errors have occurred A write of a non-zero value to this bit field increments it by the value provided.")

class SA_CANFD0_MCANERR_AGGR_STATUS_CLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANERR_AGGR_STATUS_CLR", "MCAN Error Aggregator Status Clear Register")
        self.AGGR_PARITY_ERR = BitField(self, 0x00000003, "AGGR_PARITY_ERR", "Aggregator Parity Error Status. 2-bit saturating counter of the number of parity errors that have occurred since last cleared. 0 No parity errors have occurred 1 One parity error has occurred 2 Two parity errors have occurred 3 Three parity errors have occurred A write of a non-zero value to this bit field decrements it by the value provided.")
        self.SVBUS_TIMEOUT = BitField(self, 0x0000000C, "SVBUS_TIMEOUT", "Aggregator Serial VBUS Timeout Error Status. 2-bit saturating counter of the number of SVBUS timeout errors that have occurred since last cleared. 0 No timeout errors have occurred 1 One timeout error has occurred 2 Two timeout errors have occurred 3 Three timeout errors have occurred A write of a non-zero value to this bit field decrements it by the value provided.")

class SA_CANFD0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_CANFD0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.INTL0 = BitField(self, 0x00000001, "INTL0", "MCAN Interrupt Line 0 mask.")
        self.INTL1 = BitField(self, 0x00000002, "INTL1", "MCAN Interrupt Line 1 mask.")
        self.SEC = BitField(self, 0x00000004, "SEC", "Message RAM SEC interrupt mask.")
        self.DED = BitField(self, 0x00000008, "DED", "Massage RAM DED interrupt mask.")
        self.EXT_TS_CNTR_OVFL = BitField(self, 0x00000010, "EXT_TS_CNTR_OVFL", "External Timestamp Counter Overflow interrupt mask.")
        self.WAKEUP = BitField(self, 0x00000020, "WAKEUP", "Clock Stop Wake Up interrupt mask.")
        self.INTL = Subscriptor(self, "INTL{}")

class SA_CANFD0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.INTL0 = BitField(self, 0x00000001, "INTL0", "MCAN Interrupt Line 0.")
        self.INTL1 = BitField(self, 0x00000002, "INTL1", "MCAN Interrupt Line 1.")
        self.SEC = BitField(self, 0x00000004, "SEC", "Message RAM SEC interrupt.")
        self.DED = BitField(self, 0x00000008, "DED", "Message RAM DED interrupt.")
        self.EXT_TS_CNTR_OVFL = BitField(self, 0x00000010, "EXT_TS_CNTR_OVFL", "External Timestamp Counter Overflow interrupt.")
        self.WAKEUP = BitField(self, 0x00000020, "WAKEUP", "Clock Stop Wake Up interrupt.")
        self.INTL = Subscriptor(self, "INTL{}")

class SA_CANFD0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.INTL0 = BitField(self, 0x00000001, "INTL0", "Masked MCAN Interrupt Line 0.")
        self.INTL1 = BitField(self, 0x00000002, "INTL1", "Masked MCAN Interrupt Line 1.")
        self.SEC = BitField(self, 0x00000004, "SEC", "Masked Message RAM SEC interrupt.")
        self.DED = BitField(self, 0x00000008, "DED", "Masked Message RAM DED interrupt.")
        self.EXT_TS_CNTR_OVFL = BitField(self, 0x00000010, "EXT_TS_CNTR_OVFL", "Masked External Timestamp Counter Overflow interrupt.")
        self.WAKEUP = BitField(self, 0x00000020, "WAKEUP", "Masked Clock Stop Wake Up interrupt.")
        self.INTL = Subscriptor(self, "INTL{}")

class SA_CANFD0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.INTL0 = BitField(self, 0x00000001, "INTL0", "Set MCAN Interrupt Line 0.")
        self.INTL1 = BitField(self, 0x00000002, "INTL1", "Set MCAN Interrupt Line 1.")
        self.SEC = BitField(self, 0x00000004, "SEC", "Set Message RAM SEC interrupt.")
        self.DED = BitField(self, 0x00000008, "DED", "Set Message RAM DED interrupt.")
        self.EXT_TS_CNTR_OVFL = BitField(self, 0x00000010, "EXT_TS_CNTR_OVFL", "Set External Timestamp Counter Overflow interrupt.")
        self.WAKEUP = BitField(self, 0x00000020, "WAKEUP", "Set Clock Stop Wake Up interrupt.")
        self.INTL = Subscriptor(self, "INTL{}")

class SA_CANFD0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.INTL0 = BitField(self, 0x00000001, "INTL0", "Clear MCAN Interrupt Line 0.")
        self.INTL1 = BitField(self, 0x00000002, "INTL1", "Clear MCAN Interrupt Line 1.")
        self.SEC = BitField(self, 0x00000004, "SEC", "Clear Message RAM SEC interrupt.")
        self.DED = BitField(self, 0x00000008, "DED", "Clear Message RAM DED interrupt.")
        self.EXT_TS_CNTR_OVFL = BitField(self, 0x00000010, "EXT_TS_CNTR_OVFL", "Clear External Timestamp Counter Overflow interrupt.")
        self.WAKEUP = BitField(self, 0x00000020, "WAKEUP", "Clear Clock Stop Wake Up interrupt.")
        self.INTL = Subscriptor(self, "INTL{}")

class SA_CANFD0_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")

class SA_CANFD0_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_CANFD0_MCANSS_CLKEN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_CLKEN", "MCAN module clock enable")
        self.CLK_REQEN = BitField(self, 0x00000001, "CLK_REQEN", "MCAN functional and MCAN/MCANSS MMR clock request enable bit")

class SA_CANFD0_MCANSS_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_CLKDIV", "Clock divider")
        self.RATIO = BitField(self, 0x00000003, "RATIO", "Clock divide ratio specification. Enables configuring clock divide settings for the MCAN functional clock input to the MCAN-SS.")

class SA_CANFD0_MCANSS_CLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_CLKCTL", "MCAN-SS clock stop control register")
        self.STOPREQ = BitField(self, 0x00000001, "STOPREQ", "This bit is used to enable/disable MCAN clock (both host clock and functional clock) gating request.. Note: This bit can be reset by HW by Clock-Stop Wake-up via CAN RX Activity. See spec for more details.")
        self.WAKEUP_INT_EN = BitField(self, 0x00000010, "WAKEUP_INT_EN", "This bit contols enabling or disabling the MCAN IP clock stop wakeup interrupt (when MCANSS_CTRL.WAKEUPREQEN wakeup request is enabled to wakeup MCAN IP upon CAN RXD activity)")
        self.WKUP_GLTFLT_EN = BitField(self, 0x00000100, "WKUP_GLTFLT_EN", "Setting this bit enables the glitch filter on MCAN RXD input, which wakes up the MCAN controller to exit clock gating.")

class SA_CANFD0_MCANSS_CLKSTS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCANSS_CLKSTS", "MCANSS clock stop status register")
        self.CLKSTOP_ACKSTS = BitField(self, 0x00000001, "CLKSTOP_ACKSTS", "Clock stop acknowledge status from MCAN IP")
        self.STOPREQ_HW_OVR = BitField(self, 0x00000010, "STOPREQ_HW_OVR", "MCANSS clock stop HW override status bit. . This bit indicates when the MCANSS_CLKCTL.STOPREQ bit has been cleared by HW when a clock-stop wake-up event via CAN RX activity is trigged.")
        self.CCLKDONE = BitField(self, 0x00000100, "CCLKDONE", "This bit indicates the status of MCAN contoller clock request from GPRCM.")

class SA_CANFD0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_CANFD0_PWREN(self, 0x6800)
        self.RSTCTL = SA_CANFD0_RSTCTL(self, 0x6804)
        self.STAT = SA_CANFD0_STAT(self, 0x6814)
        self.MCAN_CREL = SA_CANFD0_MCAN_CREL(self, 0x7000)
        self.MCAN_ENDN = SA_CANFD0_MCAN_ENDN(self, 0x7004)
        self.MCAN_DBTP = SA_CANFD0_MCAN_DBTP(self, 0x700C)
        self.MCAN_TEST = SA_CANFD0_MCAN_TEST(self, 0x7010)
        self.MCAN_RWD = SA_CANFD0_MCAN_RWD(self, 0x7014)
        self.MCAN_CCCR = SA_CANFD0_MCAN_CCCR(self, 0x7018)
        self.MCAN_NBTP = SA_CANFD0_MCAN_NBTP(self, 0x701C)
        self.MCAN_TSCC = SA_CANFD0_MCAN_TSCC(self, 0x7020)
        self.MCAN_TSCV = SA_CANFD0_MCAN_TSCV(self, 0x7024)
        self.MCAN_TOCC = SA_CANFD0_MCAN_TOCC(self, 0x7028)
        self.MCAN_TOCV = SA_CANFD0_MCAN_TOCV(self, 0x702C)
        self.MCAN_ECR = SA_CANFD0_MCAN_ECR(self, 0x7040)
        self.MCAN_PSR = SA_CANFD0_MCAN_PSR(self, 0x7044)
        self.MCAN_TDCR = SA_CANFD0_MCAN_TDCR(self, 0x7048)
        self.MCAN_IR = SA_CANFD0_MCAN_IR(self, 0x7050)
        self.MCAN_IE = SA_CANFD0_MCAN_IE(self, 0x7054)
        self.MCAN_ILS = SA_CANFD0_MCAN_ILS(self, 0x7058)
        self.MCAN_ILE = SA_CANFD0_MCAN_ILE(self, 0x705C)
        self.MCAN_GFC = SA_CANFD0_MCAN_GFC(self, 0x7080)
        self.MCAN_SIDFC = SA_CANFD0_MCAN_SIDFC(self, 0x7084)
        self.MCAN_XIDFC = SA_CANFD0_MCAN_XIDFC(self, 0x7088)
        self.MCAN_XIDAM = SA_CANFD0_MCAN_XIDAM(self, 0x7090)
        self.MCAN_HPMS = SA_CANFD0_MCAN_HPMS(self, 0x7094)
        self.MCAN_NDAT1 = SA_CANFD0_MCAN_NDAT1(self, 0x7098)
        self.MCAN_NDAT2 = SA_CANFD0_MCAN_NDAT2(self, 0x709C)
        self.MCAN_RXF0C = SA_CANFD0_MCAN_RXF0C(self, 0x70A0)
        self.MCAN_RXF0S = SA_CANFD0_MCAN_RXF0S(self, 0x70A4)
        self.MCAN_RXF0A = SA_CANFD0_MCAN_RXF0A(self, 0x70A8)
        self.MCAN_RXBC = SA_CANFD0_MCAN_RXBC(self, 0x70AC)
        self.MCAN_RXF1C = SA_CANFD0_MCAN_RXF1C(self, 0x70B0)
        self.MCAN_RXF1S = SA_CANFD0_MCAN_RXF1S(self, 0x70B4)
        self.MCAN_RXF1A = SA_CANFD0_MCAN_RXF1A(self, 0x70B8)
        self.MCAN_RXESC = SA_CANFD0_MCAN_RXESC(self, 0x70BC)
        self.MCAN_TXBC = SA_CANFD0_MCAN_TXBC(self, 0x70C0)
        self.MCAN_TXFQS = SA_CANFD0_MCAN_TXFQS(self, 0x70C4)
        self.MCAN_TXESC = SA_CANFD0_MCAN_TXESC(self, 0x70C8)
        self.MCAN_TXBRP = SA_CANFD0_MCAN_TXBRP(self, 0x70CC)
        self.MCAN_TXBAR = SA_CANFD0_MCAN_TXBAR(self, 0x70D0)
        self.MCAN_TXBCR = SA_CANFD0_MCAN_TXBCR(self, 0x70D4)
        self.MCAN_TXBTO = SA_CANFD0_MCAN_TXBTO(self, 0x70D8)
        self.MCAN_TXBCF = SA_CANFD0_MCAN_TXBCF(self, 0x70DC)
        self.MCAN_TXBTIE = SA_CANFD0_MCAN_TXBTIE(self, 0x70E0)
        self.MCAN_TXBCIE = SA_CANFD0_MCAN_TXBCIE(self, 0x70E4)
        self.MCAN_TXEFC = SA_CANFD0_MCAN_TXEFC(self, 0x70F0)
        self.MCAN_TXEFS = SA_CANFD0_MCAN_TXEFS(self, 0x70F4)
        self.MCAN_TXEFA = SA_CANFD0_MCAN_TXEFA(self, 0x70F8)
        self.MCANSS_PID = SA_CANFD0_MCANSS_PID(self, 0x7200)
        self.MCANSS_CTRL = SA_CANFD0_MCANSS_CTRL(self, 0x7204)
        self.MCANSS_STAT = SA_CANFD0_MCANSS_STAT(self, 0x7208)
        self.MCANSS_ICS = SA_CANFD0_MCANSS_ICS(self, 0x720C)
        self.MCANSS_IRS = SA_CANFD0_MCANSS_IRS(self, 0x7210)
        self.MCANSS_IECS = SA_CANFD0_MCANSS_IECS(self, 0x7214)
        self.MCANSS_IE = SA_CANFD0_MCANSS_IE(self, 0x7218)
        self.MCANSS_IES = SA_CANFD0_MCANSS_IES(self, 0x721C)
        self.MCANSS_EOI = SA_CANFD0_MCANSS_EOI(self, 0x7220)
        self.MCANSS_EXT_TS_PRESCALER = SA_CANFD0_MCANSS_EXT_TS_PRESCALER(self, 0x7224)
        self.MCANSS_EXT_TS_UNSERVICED_INTR_CNTR = SA_CANFD0_MCANSS_EXT_TS_UNSERVICED_INTR_CNTR(self, 0x7228)
        self.MCANERR_REV = SA_CANFD0_MCANERR_REV(self, 0x7400)
        self.MCANERR_VECTOR = SA_CANFD0_MCANERR_VECTOR(self, 0x7408)
        self.MCANERR_STAT = SA_CANFD0_MCANERR_STAT(self, 0x740C)
        self.MCANERR_WRAP_REV = SA_CANFD0_MCANERR_WRAP_REV(self, 0x7410)
        self.MCANERR_CTRL = SA_CANFD0_MCANERR_CTRL(self, 0x7414)
        self.MCANERR_ERR_CTRL1 = SA_CANFD0_MCANERR_ERR_CTRL1(self, 0x7418)
        self.MCANERR_ERR_CTRL2 = SA_CANFD0_MCANERR_ERR_CTRL2(self, 0x741C)
        self.MCANERR_ERR_STAT1 = SA_CANFD0_MCANERR_ERR_STAT1(self, 0x7420)
        self.MCANERR_ERR_STAT2 = SA_CANFD0_MCANERR_ERR_STAT2(self, 0x7424)
        self.MCANERR_ERR_STAT3 = SA_CANFD0_MCANERR_ERR_STAT3(self, 0x7428)
        self.MCANERR_SEC_EOI = SA_CANFD0_MCANERR_SEC_EOI(self, 0x743C)
        self.MCANERR_SEC_STATUS = SA_CANFD0_MCANERR_SEC_STATUS(self, 0x7440)
        self.MCANERR_SEC_ENABLE_SET = SA_CANFD0_MCANERR_SEC_ENABLE_SET(self, 0x7480)
        self.MCANERR_SEC_ENABLE_CLR = SA_CANFD0_MCANERR_SEC_ENABLE_CLR(self, 0x74C0)
        self.MCANERR_DED_EOI = SA_CANFD0_MCANERR_DED_EOI(self, 0x753C)
        self.MCANERR_DED_STATUS = SA_CANFD0_MCANERR_DED_STATUS(self, 0x7540)
        self.MCANERR_DED_ENABLE_SET = SA_CANFD0_MCANERR_DED_ENABLE_SET(self, 0x7580)
        self.MCANERR_DED_ENABLE_CLR = SA_CANFD0_MCANERR_DED_ENABLE_CLR(self, 0x75C0)
        self.MCANERR_AGGR_ENABLE_SET = SA_CANFD0_MCANERR_AGGR_ENABLE_SET(self, 0x7600)
        self.MCANERR_AGGR_ENABLE_CLR = SA_CANFD0_MCANERR_AGGR_ENABLE_CLR(self, 0x7604)
        self.MCANERR_AGGR_STATUS_SET = SA_CANFD0_MCANERR_AGGR_STATUS_SET(self, 0x7608)
        self.MCANERR_AGGR_STATUS_CLR = SA_CANFD0_MCANERR_AGGR_STATUS_CLR(self, 0x760C)
        self.IIDX = SA_CANFD0_IIDX(self, 0x7820)
        self.IMASK = SA_CANFD0_IMASK(self, 0x7828)
        self.RIS = SA_CANFD0_RIS(self, 0x7830)
        self.MIS = SA_CANFD0_MIS(self, 0x7838)
        self.ISET = SA_CANFD0_ISET(self, 0x7840)
        self.ICLR = SA_CANFD0_ICLR(self, 0x7848)
        self.EVT_MODE = SA_CANFD0_EVT_MODE(self, 0x78E0)
        self.DESC = SA_CANFD0_DESC(self, 0x78FC)
        self.MCANSS_CLKEN = SA_CANFD0_MCANSS_CLKEN(self, 0x7900)
        self.MCANSS_CLKDIV = SA_CANFD0_MCANSS_CLKDIV(self, 0x7904)
        self.MCANSS_CLKCTL = SA_CANFD0_MCANSS_CLKCTL(self, 0x7908)
        self.MCANSS_CLKSTS = SA_CANFD0_MCANSS_CLKSTS(self, 0x790C)
        self.MCAN_RXFS = Subscriptor(self, "MCAN_RXF{}S")
        self.MCANERR_ERR_CTRL = Subscriptor(self, "MCANERR_ERR_CTRL{}")
        self.MCANERR_ERR_STAT = Subscriptor(self, "MCANERR_ERR_STAT{}")
        self.MCAN_RXFA = Subscriptor(self, "MCAN_RXF{}A")
        self.MCAN_NDAT = Subscriptor(self, "MCAN_NDAT{}")
        self.MCAN_RXFC = Subscriptor(self, "MCAN_RXF{}C")

CANFD0 = SA_CANFD0(0x40508000, "CANFD0")

class SA_IOMUX_PINCM0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PINCM0", "Pin Control Management Register in SECCFG region")
        self.PF = BitField(self, 0x0000003F, "PF", "P channel Function selection bits")
        self.PC = BitField(self, 0x00000080, "PC", "Peripheral is Connected")
        self.WAKESTAT = BitField(self, 0x00002000, "WAKESTAT", "This has the IOPAD WAKEUP signal as status bit.")
        self.PIPD = BitField(self, 0x00010000, "PIPD", "Pull Down control selection")
        self.PIPU = BitField(self, 0x00020000, "PIPU", "Pull Up control selection")
        self.INENA = BitField(self, 0x00040000, "INENA", "Input Enable Control Selection")
        self.HYSTEN = BitField(self, 0x00080000, "HYSTEN", "Hystersis Enable Control Selection")
        self.DRV = BitField(self, 0x00100000, "DRV", "Drive strength control selection, for HS IOCELL only")
        self.HIZ1 = BitField(self, 0x02000000, "HIZ1", "High output value will tri-state the output when this bit is enabled")
        self.WUEN = BitField(self, 0x08000000, "WUEN", "Wakeup Enable bit")
        self.WCOMP = BitField(self, 0x10000000, "WCOMP", "Wakeup Compare Value bit")
        self.INV = BitField(self, 0x04000000, "INV", "Data inversion selection")

class SA_IOMUX(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PINCM0 = SA_IOMUX_PINCM0(self, 0x4)
        self.PINCM1 = SA_IOMUX_PINCM0(self, 0x8)
        self.PINCM2 = SA_IOMUX_PINCM0(self, 0xC)
        self.PINCM3 = SA_IOMUX_PINCM0(self, 0x10)
        self.PINCM4 = SA_IOMUX_PINCM0(self, 0x14)
        self.PINCM5 = SA_IOMUX_PINCM0(self, 0x18)
        self.PINCM6 = SA_IOMUX_PINCM0(self, 0x1C)
        self.PINCM7 = SA_IOMUX_PINCM0(self, 0x20)
        self.PINCM8 = SA_IOMUX_PINCM0(self, 0x24)
        self.PINCM9 = SA_IOMUX_PINCM0(self, 0x28)
        self.PINCM10 = SA_IOMUX_PINCM0(self, 0x2C)
        self.PINCM11 = SA_IOMUX_PINCM0(self, 0x30)
        self.PINCM12 = SA_IOMUX_PINCM0(self, 0x34)
        self.PINCM13 = SA_IOMUX_PINCM0(self, 0x38)
        self.PINCM14 = SA_IOMUX_PINCM0(self, 0x3C)
        self.PINCM15 = SA_IOMUX_PINCM0(self, 0x40)
        self.PINCM16 = SA_IOMUX_PINCM0(self, 0x44)
        self.PINCM17 = SA_IOMUX_PINCM0(self, 0x48)
        self.PINCM18 = SA_IOMUX_PINCM0(self, 0x4C)
        self.PINCM19 = SA_IOMUX_PINCM0(self, 0x50)
        self.PINCM20 = SA_IOMUX_PINCM0(self, 0x54)
        self.PINCM21 = SA_IOMUX_PINCM0(self, 0x58)
        self.PINCM22 = SA_IOMUX_PINCM0(self, 0x5C)
        self.PINCM23 = SA_IOMUX_PINCM0(self, 0x60)
        self.PINCM24 = SA_IOMUX_PINCM0(self, 0x64)
        self.PINCM25 = SA_IOMUX_PINCM0(self, 0x68)
        self.PINCM26 = SA_IOMUX_PINCM0(self, 0x6C)
        self.PINCM27 = SA_IOMUX_PINCM0(self, 0x70)
        self.PINCM28 = SA_IOMUX_PINCM0(self, 0x74)
        self.PINCM29 = SA_IOMUX_PINCM0(self, 0x78)
        self.PINCM30 = SA_IOMUX_PINCM0(self, 0x7C)
        self.PINCM31 = SA_IOMUX_PINCM0(self, 0x80)
        self.PINCM32 = SA_IOMUX_PINCM0(self, 0x84)
        self.PINCM33 = SA_IOMUX_PINCM0(self, 0x88)
        self.PINCM34 = SA_IOMUX_PINCM0(self, 0x8C)
        self.PINCM35 = SA_IOMUX_PINCM0(self, 0x90)
        self.PINCM36 = SA_IOMUX_PINCM0(self, 0x94)
        self.PINCM37 = SA_IOMUX_PINCM0(self, 0x98)
        self.PINCM38 = SA_IOMUX_PINCM0(self, 0x9C)
        self.PINCM39 = SA_IOMUX_PINCM0(self, 0xA0)
        self.PINCM40 = SA_IOMUX_PINCM0(self, 0xA4)
        self.PINCM41 = SA_IOMUX_PINCM0(self, 0xA8)
        self.PINCM42 = SA_IOMUX_PINCM0(self, 0xAC)
        self.PINCM43 = SA_IOMUX_PINCM0(self, 0xB0)
        self.PINCM44 = SA_IOMUX_PINCM0(self, 0xB4)
        self.PINCM45 = SA_IOMUX_PINCM0(self, 0xB8)
        self.PINCM46 = SA_IOMUX_PINCM0(self, 0xBC)
        self.PINCM47 = SA_IOMUX_PINCM0(self, 0xC0)
        self.PINCM48 = SA_IOMUX_PINCM0(self, 0xC4)
        self.PINCM49 = SA_IOMUX_PINCM0(self, 0xC8)
        self.PINCM50 = SA_IOMUX_PINCM0(self, 0xCC)
        self.PINCM51 = SA_IOMUX_PINCM0(self, 0xD0)
        self.PINCM52 = SA_IOMUX_PINCM0(self, 0xD4)
        self.PINCM53 = SA_IOMUX_PINCM0(self, 0xD8)
        self.PINCM54 = SA_IOMUX_PINCM0(self, 0xDC)
        self.PINCM55 = SA_IOMUX_PINCM0(self, 0xE0)
        self.PINCM56 = SA_IOMUX_PINCM0(self, 0xE4)
        self.PINCM57 = SA_IOMUX_PINCM0(self, 0xE8)
        self.PINCM58 = SA_IOMUX_PINCM0(self, 0xEC)
        self.PINCM59 = SA_IOMUX_PINCM0(self, 0xF0)
        self.PINCM60 = SA_IOMUX_PINCM0(self, 0xF4)
        self.PINCM61 = SA_IOMUX_PINCM0(self, 0xF8)
        self.PINCM62 = SA_IOMUX_PINCM0(self, 0xFC)
        self.PINCM63 = SA_IOMUX_PINCM0(self, 0x100)
        self.PINCM64 = SA_IOMUX_PINCM0(self, 0x104)
        self.PINCM65 = SA_IOMUX_PINCM0(self, 0x108)
        self.PINCM66 = SA_IOMUX_PINCM0(self, 0x10C)
        self.PINCM67 = SA_IOMUX_PINCM0(self, 0x110)
        self.PINCM68 = SA_IOMUX_PINCM0(self, 0x114)
        self.PINCM69 = SA_IOMUX_PINCM0(self, 0x118)
        self.PINCM70 = SA_IOMUX_PINCM0(self, 0x11C)
        self.PINCM71 = SA_IOMUX_PINCM0(self, 0x120)
        self.PINCM72 = SA_IOMUX_PINCM0(self, 0x124)
        self.PINCM73 = SA_IOMUX_PINCM0(self, 0x128)
        self.PINCM74 = SA_IOMUX_PINCM0(self, 0x12C)
        self.PINCM75 = SA_IOMUX_PINCM0(self, 0x130)
        self.PINCM76 = SA_IOMUX_PINCM0(self, 0x134)
        self.PINCM77 = SA_IOMUX_PINCM0(self, 0x138)
        self.PINCM78 = SA_IOMUX_PINCM0(self, 0x13C)
        self.PINCM79 = SA_IOMUX_PINCM0(self, 0x140)
        self.PINCM80 = SA_IOMUX_PINCM0(self, 0x144)
        self.PINCM81 = SA_IOMUX_PINCM0(self, 0x148)
        self.PINCM82 = SA_IOMUX_PINCM0(self, 0x14C)
        self.PINCM83 = SA_IOMUX_PINCM0(self, 0x150)
        self.PINCM84 = SA_IOMUX_PINCM0(self, 0x154)
        self.PINCM85 = SA_IOMUX_PINCM0(self, 0x158)
        self.PINCM86 = SA_IOMUX_PINCM0(self, 0x15C)
        self.PINCM87 = SA_IOMUX_PINCM0(self, 0x160)
        self.PINCM88 = SA_IOMUX_PINCM0(self, 0x164)
        self.PINCM89 = SA_IOMUX_PINCM0(self, 0x168)
        self.PINCM90 = SA_IOMUX_PINCM0(self, 0x16C)
        self.PINCM91 = SA_IOMUX_PINCM0(self, 0x170)
        self.PINCM92 = SA_IOMUX_PINCM0(self, 0x174)
        self.PINCM93 = SA_IOMUX_PINCM0(self, 0x178)
        self.PINCM94 = SA_IOMUX_PINCM0(self, 0x17C)
        self.PINCM95 = SA_IOMUX_PINCM0(self, 0x180)
        self.PINCM96 = SA_IOMUX_PINCM0(self, 0x184)
        self.PINCM97 = SA_IOMUX_PINCM0(self, 0x188)
        self.PINCM98 = SA_IOMUX_PINCM0(self, 0x18C)
        self.PINCM99 = SA_IOMUX_PINCM0(self, 0x190)
        self.PINCM100 = SA_IOMUX_PINCM0(self, 0x194)
        self.PINCM101 = SA_IOMUX_PINCM0(self, 0x198)
        self.PINCM102 = SA_IOMUX_PINCM0(self, 0x19C)
        self.PINCM103 = SA_IOMUX_PINCM0(self, 0x1A0)
        self.PINCM104 = SA_IOMUX_PINCM0(self, 0x1A4)
        self.PINCM105 = SA_IOMUX_PINCM0(self, 0x1A8)
        self.PINCM106 = SA_IOMUX_PINCM0(self, 0x1AC)
        self.PINCM107 = SA_IOMUX_PINCM0(self, 0x1B0)
        self.PINCM108 = SA_IOMUX_PINCM0(self, 0x1B4)
        self.PINCM109 = SA_IOMUX_PINCM0(self, 0x1B8)
        self.PINCM110 = SA_IOMUX_PINCM0(self, 0x1BC)
        self.PINCM111 = SA_IOMUX_PINCM0(self, 0x1C0)
        self.PINCM112 = SA_IOMUX_PINCM0(self, 0x1C4)
        self.PINCM113 = SA_IOMUX_PINCM0(self, 0x1C8)
        self.PINCM114 = SA_IOMUX_PINCM0(self, 0x1CC)
        self.PINCM115 = SA_IOMUX_PINCM0(self, 0x1D0)
        self.PINCM116 = SA_IOMUX_PINCM0(self, 0x1D4)
        self.PINCM117 = SA_IOMUX_PINCM0(self, 0x1D8)
        self.PINCM118 = SA_IOMUX_PINCM0(self, 0x1DC)
        self.PINCM119 = SA_IOMUX_PINCM0(self, 0x1E0)
        self.PINCM120 = SA_IOMUX_PINCM0(self, 0x1E4)
        self.PINCM121 = SA_IOMUX_PINCM0(self, 0x1E8)
        self.PINCM122 = SA_IOMUX_PINCM0(self, 0x1EC)
        self.PINCM123 = SA_IOMUX_PINCM0(self, 0x1F0)
        self.PINCM124 = SA_IOMUX_PINCM0(self, 0x1F4)
        self.PINCM125 = SA_IOMUX_PINCM0(self, 0x1F8)
        self.PINCM126 = SA_IOMUX_PINCM0(self, 0x1FC)
        self.PINCM127 = SA_IOMUX_PINCM0(self, 0x200)
        self.PINCM128 = SA_IOMUX_PINCM0(self, 0x204)
        self.PINCM129 = SA_IOMUX_PINCM0(self, 0x208)
        self.PINCM130 = SA_IOMUX_PINCM0(self, 0x20C)
        self.PINCM131 = SA_IOMUX_PINCM0(self, 0x210)
        self.PINCM132 = SA_IOMUX_PINCM0(self, 0x214)
        self.PINCM133 = SA_IOMUX_PINCM0(self, 0x218)
        self.PINCM134 = SA_IOMUX_PINCM0(self, 0x21C)
        self.PINCM135 = SA_IOMUX_PINCM0(self, 0x220)
        self.PINCM136 = SA_IOMUX_PINCM0(self, 0x224)
        self.PINCM137 = SA_IOMUX_PINCM0(self, 0x228)
        self.PINCM138 = SA_IOMUX_PINCM0(self, 0x22C)
        self.PINCM139 = SA_IOMUX_PINCM0(self, 0x230)
        self.PINCM140 = SA_IOMUX_PINCM0(self, 0x234)
        self.PINCM141 = SA_IOMUX_PINCM0(self, 0x238)
        self.PINCM142 = SA_IOMUX_PINCM0(self, 0x23C)
        self.PINCM143 = SA_IOMUX_PINCM0(self, 0x240)
        self.PINCM144 = SA_IOMUX_PINCM0(self, 0x244)
        self.PINCM145 = SA_IOMUX_PINCM0(self, 0x248)
        self.PINCM146 = SA_IOMUX_PINCM0(self, 0x24C)
        self.PINCM147 = SA_IOMUX_PINCM0(self, 0x250)
        self.PINCM148 = SA_IOMUX_PINCM0(self, 0x254)
        self.PINCM149 = SA_IOMUX_PINCM0(self, 0x258)
        self.PINCM150 = SA_IOMUX_PINCM0(self, 0x25C)
        self.PINCM151 = SA_IOMUX_PINCM0(self, 0x260)
        self.PINCM152 = SA_IOMUX_PINCM0(self, 0x264)
        self.PINCM153 = SA_IOMUX_PINCM0(self, 0x268)
        self.PINCM154 = SA_IOMUX_PINCM0(self, 0x26C)
        self.PINCM155 = SA_IOMUX_PINCM0(self, 0x270)
        self.PINCM156 = SA_IOMUX_PINCM0(self, 0x274)
        self.PINCM157 = SA_IOMUX_PINCM0(self, 0x278)
        self.PINCM158 = SA_IOMUX_PINCM0(self, 0x27C)
        self.PINCM159 = SA_IOMUX_PINCM0(self, 0x280)
        self.PINCM160 = SA_IOMUX_PINCM0(self, 0x284)
        self.PINCM161 = SA_IOMUX_PINCM0(self, 0x288)
        self.PINCM162 = SA_IOMUX_PINCM0(self, 0x28C)
        self.PINCM163 = SA_IOMUX_PINCM0(self, 0x290)
        self.PINCM164 = SA_IOMUX_PINCM0(self, 0x294)
        self.PINCM165 = SA_IOMUX_PINCM0(self, 0x298)
        self.PINCM166 = SA_IOMUX_PINCM0(self, 0x29C)
        self.PINCM167 = SA_IOMUX_PINCM0(self, 0x2A0)
        self.PINCM168 = SA_IOMUX_PINCM0(self, 0x2A4)
        self.PINCM169 = SA_IOMUX_PINCM0(self, 0x2A8)
        self.PINCM170 = SA_IOMUX_PINCM0(self, 0x2AC)
        self.PINCM171 = SA_IOMUX_PINCM0(self, 0x2B0)
        self.PINCM172 = SA_IOMUX_PINCM0(self, 0x2B4)
        self.PINCM173 = SA_IOMUX_PINCM0(self, 0x2B8)
        self.PINCM174 = SA_IOMUX_PINCM0(self, 0x2BC)
        self.PINCM175 = SA_IOMUX_PINCM0(self, 0x2C0)
        self.PINCM176 = SA_IOMUX_PINCM0(self, 0x2C4)
        self.PINCM177 = SA_IOMUX_PINCM0(self, 0x2C8)
        self.PINCM178 = SA_IOMUX_PINCM0(self, 0x2CC)
        self.PINCM179 = SA_IOMUX_PINCM0(self, 0x2D0)
        self.PINCM180 = SA_IOMUX_PINCM0(self, 0x2D4)
        self.PINCM181 = SA_IOMUX_PINCM0(self, 0x2D8)
        self.PINCM182 = SA_IOMUX_PINCM0(self, 0x2DC)
        self.PINCM183 = SA_IOMUX_PINCM0(self, 0x2E0)
        self.PINCM184 = SA_IOMUX_PINCM0(self, 0x2E4)
        self.PINCM185 = SA_IOMUX_PINCM0(self, 0x2E8)
        self.PINCM186 = SA_IOMUX_PINCM0(self, 0x2EC)
        self.PINCM187 = SA_IOMUX_PINCM0(self, 0x2F0)
        self.PINCM188 = SA_IOMUX_PINCM0(self, 0x2F4)
        self.PINCM189 = SA_IOMUX_PINCM0(self, 0x2F8)
        self.PINCM190 = SA_IOMUX_PINCM0(self, 0x2FC)
        self.PINCM191 = SA_IOMUX_PINCM0(self, 0x300)
        self.PINCM192 = SA_IOMUX_PINCM0(self, 0x304)
        self.PINCM193 = SA_IOMUX_PINCM0(self, 0x308)
        self.PINCM194 = SA_IOMUX_PINCM0(self, 0x30C)
        self.PINCM195 = SA_IOMUX_PINCM0(self, 0x310)
        self.PINCM196 = SA_IOMUX_PINCM0(self, 0x314)
        self.PINCM197 = SA_IOMUX_PINCM0(self, 0x318)
        self.PINCM198 = SA_IOMUX_PINCM0(self, 0x31C)
        self.PINCM199 = SA_IOMUX_PINCM0(self, 0x320)
        self.PINCM200 = SA_IOMUX_PINCM0(self, 0x324)
        self.PINCM201 = SA_IOMUX_PINCM0(self, 0x328)
        self.PINCM202 = SA_IOMUX_PINCM0(self, 0x32C)
        self.PINCM203 = SA_IOMUX_PINCM0(self, 0x330)
        self.PINCM204 = SA_IOMUX_PINCM0(self, 0x334)
        self.PINCM205 = SA_IOMUX_PINCM0(self, 0x338)
        self.PINCM206 = SA_IOMUX_PINCM0(self, 0x33C)
        self.PINCM207 = SA_IOMUX_PINCM0(self, 0x340)
        self.PINCM208 = SA_IOMUX_PINCM0(self, 0x344)
        self.PINCM209 = SA_IOMUX_PINCM0(self, 0x348)
        self.PINCM210 = SA_IOMUX_PINCM0(self, 0x34C)
        self.PINCM211 = SA_IOMUX_PINCM0(self, 0x350)
        self.PINCM212 = SA_IOMUX_PINCM0(self, 0x354)
        self.PINCM213 = SA_IOMUX_PINCM0(self, 0x358)
        self.PINCM214 = SA_IOMUX_PINCM0(self, 0x35C)
        self.PINCM215 = SA_IOMUX_PINCM0(self, 0x360)
        self.PINCM216 = SA_IOMUX_PINCM0(self, 0x364)
        self.PINCM217 = SA_IOMUX_PINCM0(self, 0x368)
        self.PINCM218 = SA_IOMUX_PINCM0(self, 0x36C)
        self.PINCM219 = SA_IOMUX_PINCM0(self, 0x370)
        self.PINCM220 = SA_IOMUX_PINCM0(self, 0x374)
        self.PINCM221 = SA_IOMUX_PINCM0(self, 0x378)
        self.PINCM222 = SA_IOMUX_PINCM0(self, 0x37C)
        self.PINCM223 = SA_IOMUX_PINCM0(self, 0x380)
        self.PINCM224 = SA_IOMUX_PINCM0(self, 0x384)
        self.PINCM225 = SA_IOMUX_PINCM0(self, 0x388)
        self.PINCM226 = SA_IOMUX_PINCM0(self, 0x38C)
        self.PINCM227 = SA_IOMUX_PINCM0(self, 0x390)
        self.PINCM228 = SA_IOMUX_PINCM0(self, 0x394)
        self.PINCM229 = SA_IOMUX_PINCM0(self, 0x398)
        self.PINCM230 = SA_IOMUX_PINCM0(self, 0x39C)
        self.PINCM231 = SA_IOMUX_PINCM0(self, 0x3A0)
        self.PINCM232 = SA_IOMUX_PINCM0(self, 0x3A4)
        self.PINCM233 = SA_IOMUX_PINCM0(self, 0x3A8)
        self.PINCM234 = SA_IOMUX_PINCM0(self, 0x3AC)
        self.PINCM235 = SA_IOMUX_PINCM0(self, 0x3B0)
        self.PINCM236 = SA_IOMUX_PINCM0(self, 0x3B4)
        self.PINCM237 = SA_IOMUX_PINCM0(self, 0x3B8)
        self.PINCM238 = SA_IOMUX_PINCM0(self, 0x3BC)
        self.PINCM239 = SA_IOMUX_PINCM0(self, 0x3C0)
        self.PINCM240 = SA_IOMUX_PINCM0(self, 0x3C4)
        self.PINCM241 = SA_IOMUX_PINCM0(self, 0x3C8)
        self.PINCM242 = SA_IOMUX_PINCM0(self, 0x3CC)
        self.PINCM243 = SA_IOMUX_PINCM0(self, 0x3D0)
        self.PINCM244 = SA_IOMUX_PINCM0(self, 0x3D4)
        self.PINCM245 = SA_IOMUX_PINCM0(self, 0x3D8)
        self.PINCM246 = SA_IOMUX_PINCM0(self, 0x3DC)
        self.PINCM247 = SA_IOMUX_PINCM0(self, 0x3E0)
        self.PINCM248 = SA_IOMUX_PINCM0(self, 0x3E4)
        self.PINCM249 = SA_IOMUX_PINCM0(self, 0x3E8)
        self.PINCM250 = SA_IOMUX_PINCM0(self, 0x3EC)
        self.PINCM = Subscriptor(self, "PINCM{}")

IOMUX = SA_IOMUX(0x40428000, "IOMUX")

class SA_GPIOB_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subsciber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_GPIOB_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_GPIOB_FPUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_0", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_GPIOB_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_GPIOB_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_GPIOB_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_GPIOB_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_GPIOB_CLKOVR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKOVR", "Clock Override")
        self.OVERRIDE = BitField(self, 0x00000001, "OVERRIDE", "Unlocks the functionality of [RUN_STOP] to override the automatic peripheral clock request")
        self.RUN_STOP = BitField(self, 0x00000002, "RUN_STOP", "If [OVERRIDE] is enabled, this register is used to manually control the peripheral's clock request to the system")

class SA_GPIOB_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x1, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")

class SA_GPIOB_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_GPIOB_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event mask")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event mask")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event mask")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event mask")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event mask")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event mask")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event mask")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event mask")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event mask")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event mask")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event mask")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event mask")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event mask")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event mask")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event mask")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event mask")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event mask")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event mask")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event mask")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event mask")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event mask")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event mask")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event mask")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event mask")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event mask")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event mask")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event mask")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event mask")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event mask")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event mask")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event mask")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event mask")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_GPIOB_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event mask")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event mask")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event mask")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event mask")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event mask")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event mask")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event mask")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event mask")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event mask")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event mask")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event mask")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event mask")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event mask")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event mask")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event mask")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event mask")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_GPIOB_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event mask")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event mask")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event mask")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event mask")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event mask")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event mask")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event mask")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event mask")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event mask")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event mask")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event mask")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event mask")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event mask")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event mask")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event mask")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event mask")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_GPIOB_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_GPIOB_DOUT3_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT3_0", "Data output 3 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "This bit sets the value of the pin configured as DIO0 when the output is enabled through DOE31_0 register.")
        self.DIO1 = BitField(self, 0x00000100, "DIO1", "This bit sets the value of the pin configured as DIO1 when the output is enabled through DOE31_0 register.")
        self.DIO2 = BitField(self, 0x00010000, "DIO2", "This bit sets the value of the pin configured as DIO2 when the output is enabled through DOE31_0 register.")
        self.DIO3 = BitField(self, 0x01000000, "DIO3", "This bit sets the value of the pin configured as DIO3 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUT7_4(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT7_4", "Data output 7 to 4")
        self.DIO4 = BitField(self, 0x00000001, "DIO4", "This bit sets the value of the pin configured as DIO4 when the output is enabled through DOE31_0 register.")
        self.DIO5 = BitField(self, 0x00000100, "DIO5", "This bit sets the value of the pin configured as DIO5 when the output is enabled through DOE31_0 register.")
        self.DIO6 = BitField(self, 0x00010000, "DIO6", "This bit sets the value of the pin configured as DIO6 when the output is enabled through DOE31_0 register.")
        self.DIO7 = BitField(self, 0x01000000, "DIO7", "This bit sets the value of the pin configured as DIO7 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUT11_8(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT11_8", "Data output 11 to 8")
        self.DIO8 = BitField(self, 0x00000001, "DIO8", "This bit sets the value of the pin configured as DIO8 when the output is enabled through DOE31_0 register.")
        self.DIO9 = BitField(self, 0x00000100, "DIO9", "This bit sets the value of the pin configured as DIO9 when the output is enabled through DOE31_0 register.")
        self.DIO10 = BitField(self, 0x00010000, "DIO10", "This bit sets the value of the pin configured as DIO10 when the output is enabled through DOE31_0 register.")
        self.DIO11 = BitField(self, 0x01000000, "DIO11", "This bit sets the value of the pin configured as DIO11 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUT15_12(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT15_12", "Data output 15 to 12")
        self.DIO12 = BitField(self, 0x00000001, "DIO12", "This bit sets the value of the pin configured as DIO12 when the output is enabled through DOE31_0 register.")
        self.DIO13 = BitField(self, 0x00000100, "DIO13", "This bit sets the value of the pin configured as DIO13 when the output is enabled through DOE31_0 register.")
        self.DIO14 = BitField(self, 0x00010000, "DIO14", "This bit sets the value of the pin configured as DIO14 when the output is enabled through DOE31_0 register.")
        self.DIO15 = BitField(self, 0x01000000, "DIO15", "This bit sets the value of the pin configured as DIO15 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUT19_16(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT19_16", "Data output 19 to 16")
        self.DIO16 = BitField(self, 0x00000001, "DIO16", "This bit sets the value of the pin configured as DIO16 when the output is enabled through DOE31_0 register.")
        self.DIO17 = BitField(self, 0x00000100, "DIO17", "This bit sets the value of the pin configured as DIO17 when the output is enabled through DOE31_0 register.")
        self.DIO18 = BitField(self, 0x00010000, "DIO18", "This bit sets the value of the pin configured as DIO18 when the output is enabled through DOE31_0 register.")
        self.DIO19 = BitField(self, 0x01000000, "DIO19", "This bit sets the value of the pin configured as DIO19 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUT23_20(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT23_20", "Data output 23 to 20")
        self.DIO20 = BitField(self, 0x00000001, "DIO20", "This bit sets the value of the pin configured as DIO20 when the output is enabled through DOE31_0 register.")
        self.DIO21 = BitField(self, 0x00000100, "DIO21", "This bit sets the value of the pin configured as DIO21 when the output is enabled through DOE31_0 register.")
        self.DIO22 = BitField(self, 0x00010000, "DIO22", "This bit sets the value of the pin configured as DIO22 when the output is enabled through DOE31_0 register.")
        self.DIO23 = BitField(self, 0x01000000, "DIO23", "This bit sets the value of the pin configured as DIO23 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUT27_24(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT27_24", "Data output 27 to 24")
        self.DIO24 = BitField(self, 0x00000001, "DIO24", "This bit sets the value of the pin configured as DIO24 when the output is enabled through DOE31_0 register.")
        self.DIO25 = BitField(self, 0x00000100, "DIO25", "This bit sets the value of the pin configured as DIO25 when the output is enabled through DOE31_0 register.")
        self.DIO26 = BitField(self, 0x00010000, "DIO26", "This bit sets the value of the pin configured as DIO26 when the output is enabled through DOE31_0 register.")
        self.DIO27 = BitField(self, 0x01000000, "DIO27", "This bit sets the value of the pin configured as DIO27 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUT31_28(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT31_28", "Data output 31 to 28")
        self.DIO28 = BitField(self, 0x00000001, "DIO28", "This bit sets the value of the pin configured as DIO28 when the output is enabled through DOE31_0 register.")
        self.DIO29 = BitField(self, 0x00000100, "DIO29", "This bit sets the value of the pin configured as DIO29 when the output is enabled through DOE31_0 register.")
        self.DIO30 = BitField(self, 0x00010000, "DIO30", "This bit sets the value of the pin configured as DIO30 when the output is enabled through DOE31_0 register.")
        self.DIO31 = BitField(self, 0x01000000, "DIO31", "This bit sets the value of the pin configured as DIO31 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUT31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT31_0", "Data output 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "This bit sets the value of the pin configured as DIO0 when the output is enabled through DOE31_0 register.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "This bit sets the value of the pin configured as DIO1 when the output is enabled through DOE31_0 register.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "This bit sets the value of the pin configured as DIO2 when the output is enabled through DOE31_0 register.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "This bit sets the value of the pin configured as DIO3 when the output is enabled through DOE31_0 register.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "This bit sets the value of the pin configured as DIO4 when the output is enabled through DOE31_0 register.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "This bit sets the value of the pin configured as DIO5 when the output is enabled through DOE31_0 register.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "This bit sets the value of the pin configured as DIO6 when the output is enabled through DOE31_0 register.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "This bit sets the value of the pin configured as DIO7 when the output is enabled through DOE31_0 register.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "This bit sets the value of the pin configured as DIO8 when the output is enabled through DOE31_0 register.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "This bit sets the value of the pin configured as DIO9 when the output is enabled through DOE31_0 register.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "This bit sets the value of the pin configured as DIO10 when the output is enabled through DOE31_0 register.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "This bit sets the value of the pin configured as DIO11 when the output is enabled through DOE31_0 register.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "This bit sets the value of the pin configured as DIO12 when the output is enabled through DOE31_0 register.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "This bit sets the value of the pin configured as DIO13 when the output is enabled through DOE31_0 register.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "This bit sets the value of the pin configured as DIO14 when the output is enabled through DOE31_0 register.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "This bit sets the value of the pin configured as DIO15 when the output is enabled through DOE31_0 register.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "This bit sets the value of the pin configured as DIO16 when the output is enabled through DOE31_0 register.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "This bit sets the value of the pin configured as DIO17 when the output is enabled through DOE31_0 register.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "This bit sets the value of the pin configured as DIO18 when the output is enabled through DOE31_0 register.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "This bit sets the value of the pin configured as DIO19 when the output is enabled through DOE31_0 register.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "This bit sets the value of the pin configured as DIO20 when the output is enabled through DOE31_0 register.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "This bit sets the value of the pin configured as DIO21 when the output is enabled through DOE31_0 register.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "This bit sets the value of the pin configured as DIO22 when the output is enabled through DOE31_0 register.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "This bit sets the value of the pin configured as DIO23 when the output is enabled through DOE31_0 register.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "This bit sets the value of the pin configured as DIO24 when the output is enabled through DOE31_0 register.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "This bit sets the value of the pin configured as DIO25 when the output is enabled through DOE31_0 register.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "This bit sets the value of the pin configured as DIO26 when the output is enabled through DOE31_0 register.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "This bit sets the value of the pin configured as DIO27 when the output is enabled through DOE31_0 register.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "This bit sets the value of the pin configured as DIO28 when the output is enabled through DOE31_0 register.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "This bit sets the value of the pin configured as DIO29 when the output is enabled through DOE31_0 register.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "This bit sets the value of the pin configured as DIO30 when the output is enabled through DOE31_0 register.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "This bit sets the value of the pin configured as DIO31 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUTSET31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUTSET31_0", "Data output set 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "Writing 1 to this bit sets the DIO0 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "Writing 1 to this bit sets the DIO1 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "Writing 1 to this bit sets the DIO2 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "Writing 1 to this bit sets the DIO3 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "Writing 1 to this bit sets the DIO4 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "Writing 1 to this bit sets the DIO5 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "Writing 1 to this bit sets the DIO6 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "Writing 1 to this bit sets the DIO7 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "Writing 1 to this bit sets the DIO8 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "Writing 1 to this bit sets the DIO9 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "Writing 1 to this bit sets the DIO10 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "Writing 1 to this bit sets the DIO11 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "Writing 1 to this bit sets the DIO12 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "Writing 1 to this bit sets the DIO13 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "Writing 1 to this bit sets the DIO14 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "Writing 1 to this bit sets the DIO15 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "Writing 1 to this bit sets the DIO16 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "Writing 1 to this bit sets the DIO17 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "Writing 1 to this bit sets the DIO18 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "Writing 1 to this bit sets the DIO19 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "Writing 1 to this bit sets the DIO20 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "Writing 1 to this bit sets the DIO21 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "Writing 1 to this bit sets the DIO22 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "Writing 1 to this bit sets the DIO23 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "Writing 1 to this bit sets the DIO24 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "Writing 1 to this bit sets the DIO25 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "Writing 1 to this bit sets the DIO26 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "Writing 1 to this bit sets the DIO27 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "Writing 1 to this bit sets the DIO28 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "Writing 1 to this bit sets the DIO29 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "Writing 1 to this bit sets the DIO30 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "Writing 1 to this bit sets the DIO31 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUTCLR31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUTCLR31_0", "Data output clear 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "Writing 1 to this bit clears the DIO0 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "Writing 1 to this bit clears the DIO1 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "Writing 1 to this bit clears the DIO2 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "Writing 1 to this bit clears the DIO3 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "Writing 1 to this bit clears the DIO4 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "Writing 1 to this bit clears the DIO5 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "Writing 1 to this bit clears the DIO6 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "Writing 1 to this bit clears the DIO7 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "Writing 1 to this bit clears the DIO8 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "Writing 1 to this bit clears the DIO9 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "Writing 1 to this bit clears the DIO10 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "Writing 1 to this bit clears the DIO11 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "Writing 1 to this bit clears the DIO12 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "Writing 1 to this bit clears the DIO13 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "Writing 1 to this bit clears the DIO14 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "Writing 1 to this bit clears the DIO15 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "Writing 1 to this bit clears the DIO16 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "Writing 1 to this bit clears the DIO17 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "Writing 1 to this bit clears the DIO18 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "Writing 1 to this bit clears the DIO19 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "Writing 1 to this bit clears the DIO20 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "Writing 1 to this bit clears the DIO21 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "Writing 1 to this bit clears the DIO22 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "Writing 1 to this bit clears the DIO23 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "Writing 1 to this bit clears the DIO24 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "Writing 1 to this bit clears the DIO25 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "Writing 1 to this bit clears the DIO26 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "Writing 1 to this bit clears the DIO27 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "Writing 1 to this bit clears the DIO28 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "Writing 1 to this bit clears the DIO29 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "Writing 1 to this bit clears the DIO30 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "Writing 1 to this bit clears the DIO31 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOUTTGL31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUTTGL31_0", "Data output toggle 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "This bit is used to toggle DIO0 output.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "This bit is used to toggle DIO1 output.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "This bit is used to toggle DIO2 output.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "This bit is used to toggle DIO3 output.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "This bit is used to toggle DIO4 output.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "This bit is used to toggle DIO5 output.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "This bit is used to toggle DIO6 output.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "This bit is used to toggle DIO7 output.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "This bit is used to toggle DIO8 output.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "This bit is used to toggle DIO9 output.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "This bit is used to toggle DIO10 output.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "This bit is used to toggle DIO11 output.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "This bit is used to toggle DIO12 output.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "This bit is used to toggle DIO13 output.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "This bit is used to toggle DIO14 output.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "This bit is used to toggle DIO15 output.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "This bit is used to toggle DIO16 output.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "This bit is used to toggle DIO17 output.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "This bit is used to toggle DIO18 output.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "This bit is used to toggle DIO19 output.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "This bit is used to toggle DIO20 output.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "This bit is used to toggle DIO21 output.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "This bit is used to toggle DIO22 output.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "This bit is used to toggle DIO23 output.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "This bit is used to toggle DIO24 output.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "This bit is used to toggle DIO25 output.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "This bit is used to toggle DIO26 output.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "This bit is used to toggle DIO27 output.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "This bit is used to toggle DIO28 output.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "This bit is used to toggle DIO29 output.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "This bit is used to toggle DIO30 output.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "This bit is used to toggle DIO31 output.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOE31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOE31_0", "Data output enable 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "Enables data output for DIO0.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "Enables data output for DIO1.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "Enables data output for DIO2.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "Enables data output for DIO3.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "Enables data output for DIO4.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "Enables data output for DIO5.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "Enables data output for DIO6.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "Enables data output for DIO7.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "Enables data output for DIO8.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "Enables data output for DIO9.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "Enables data output for DIO10.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "Enables data output for DIO11.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "Enables data output for DIO12.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "Enables data output for DIO13.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "Enables data output for DIO14.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "Enables data output for DIO15.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "Enables data output for DIO16.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "Enables data output for DIO17.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "Enables data output for DIO18.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "Enables data output for DIO19.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "Enables data output for DIO20.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "Enables data output for DIO21.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "Enables data output for DIO22.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "Enables data output for DIO23.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "Enables data output for DIO24.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "Enables data output for DIO25.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "Enables data output for DIO26.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "Enables data output for DIO27.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "Enables data output for DIO28.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "Enables data output for DIO29.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "Enables data output for DIO30.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "Enables data output for DIO31.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOESET31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOESET31_0", "Data output enable set 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "Writing 1 to this bit sets the DIO0 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "Writing 1 to this bit sets the DIO1 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "Writing 1 to this bit sets the DIO2 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "Writing 1 to this bit sets the DIO3 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "Writing 1 to this bit sets the DIO4 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "Writing 1 to this bit sets the DIO5 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "Writing 1 to this bit sets the DIO6 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "Writing 1 to this bit sets the DIO7 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "Writing 1 to this bit sets the DIO8 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "Writing 1 to this bit sets the DIO9 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "Writing 1 to this bit sets the DIO10 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "Writing 1 to this bit sets the DIO11 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "Writing 1 to this bit sets the DIO12 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "Writing 1 to this bit sets the DIO13 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "Writing 1 to this bit sets the DIO14 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "Writing 1 to this bit sets the DIO15 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "Writing 1 to this bit sets the DIO16 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "Writing 1 to this bit sets the DIO17 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "Writing 1 to this bit sets the DIO18 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "Writing 1 to this bit sets the DIO19 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "Writing 1 to this bit sets the DIO20 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "Writing 1 to this bit sets the DIO21 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "Writing 1 to this bit sets the DIO22 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "Writing 1 to this bit sets the DIO23 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "Writing 1 to this bit sets the DIO24 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "Writing 1 to this bit sets the DIO25 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "Writing 1 to this bit sets the DIO26 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "Writing 1 to this bit sets the DIO27 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "Writing 1 to this bit sets the DIO28 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "Writing 1 to this bit sets the DIO29 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "Writing 1 to this bit sets the DIO30 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "Writing 1 to this bit sets the DIO31 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DOECLR31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOECLR31_0", "Data output enable clear 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "Writing 1 to this bit clears the DIO0 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "Writing 1 to this bit clears the DIO1 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "Writing 1 to this bit clears the DIO2 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "Writing 1 to this bit clears the DIO3 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "Writing 1 to this bit clears the DIO4 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "Writing 1 to this bit clears the DIO5 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "Writing 1 to this bit clears the DIO6 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "Writing 1 to this bit clears the DIO7 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "Writing 1 to this bit clears the DIO8 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "Writing 1 to this bit clears the DIO9 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "Writing 1 to this bit clears the DIO10 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "Writing 1 to this bit clears the DIO11 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "Writing 1 to this bit clears the DIO12 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "Writing 1 to this bit clears the DIO13 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "Writing 1 to this bit clears the DIO14 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "Writing 1 to this bit clears the DIO15 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "Writing 1 to this bit clears the DIO16 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "Writing 1 to this bit clears the DIO17 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "Writing 1 to this bit clears the DIO18 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "Writing 1 to this bit clears the DIO19 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "Writing 1 to this bit clears the DIO20 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "Writing 1 to this bit clears the DIO21 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "Writing 1 to this bit clears the DIO22 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "Writing 1 to this bit clears the DIO23 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "Writing 1 to this bit clears the DIO24 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "Writing 1 to this bit clears the DIO25 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "Writing 1 to this bit clears the DIO26 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "Writing 1 to this bit clears the DIO27 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "Writing 1 to this bit clears the DIO28 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "Writing 1 to this bit clears the DIO29 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "Writing 1 to this bit clears the DIO30 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "Writing 1 to this bit clears the DIO31 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DIN3_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN3_0", "Data input 3 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "This bit reads the data input value of DIO0.")
        self.DIO1 = BitField(self, 0x00000100, "DIO1", "This bit reads the data input value of DIO1.")
        self.DIO2 = BitField(self, 0x00010000, "DIO2", "This bit reads the data input value of DIO2.")
        self.DIO3 = BitField(self, 0x01000000, "DIO3", "This bit reads the data input value of DIO3.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DIN7_4(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN7_4", "Data input 7 to 4")
        self.DIO4 = BitField(self, 0x00000001, "DIO4", "This bit reads the data input value of DIO4.")
        self.DIO5 = BitField(self, 0x00000100, "DIO5", "This bit reads the data input value of DIO5.")
        self.DIO6 = BitField(self, 0x00010000, "DIO6", "This bit reads the data input value of DIO6.")
        self.DIO7 = BitField(self, 0x01000000, "DIO7", "This bit reads the data input value of DIO7.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DIN11_8(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN11_8", "Data input 11 to 8")
        self.DIO8 = BitField(self, 0x00000001, "DIO8", "This bit reads the data input value of DIO8.")
        self.DIO9 = BitField(self, 0x00000100, "DIO9", "This bit reads the data input value of DIO9.")
        self.DIO10 = BitField(self, 0x00010000, "DIO10", "This bit reads the data input value of DIO10.")
        self.DIO11 = BitField(self, 0x01000000, "DIO11", "This bit reads the data input value of DIO11.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DIN15_12(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN15_12", "Data input 15 to 12")
        self.DIO12 = BitField(self, 0x00000001, "DIO12", "This bit reads the data input value of DIO12.")
        self.DIO13 = BitField(self, 0x00000100, "DIO13", "This bit reads the data input value of DIO13.")
        self.DIO14 = BitField(self, 0x00010000, "DIO14", "This bit reads the data input value of DIO14.")
        self.DIO15 = BitField(self, 0x01000000, "DIO15", "This bit reads the data input value of DIO15.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DIN19_16(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN19_16", "Data input 19 to 16")
        self.DIO16 = BitField(self, 0x00000001, "DIO16", "This bit reads the data input value of DIO16.")
        self.DIO17 = BitField(self, 0x00000100, "DIO17", "This bit reads the data input value of DIO17.")
        self.DIO18 = BitField(self, 0x00010000, "DIO18", "This bit reads the data input value of DIO18.")
        self.DIO19 = BitField(self, 0x01000000, "DIO19", "This bit reads the data input value of DIO19.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DIN23_20(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN23_20", "Data input 23 to 20")
        self.DIO20 = BitField(self, 0x00000001, "DIO20", "This bit reads the data input value of DIO20.")
        self.DIO21 = BitField(self, 0x00000100, "DIO21", "This bit reads the data input value of DIO21.")
        self.DIO22 = BitField(self, 0x00010000, "DIO22", "This bit reads the data input value of DIO22.")
        self.DIO23 = BitField(self, 0x01000000, "DIO23", "This bit reads the data input value of DIO23.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DIN27_24(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN27_24", "Data input 27 to 24")
        self.DIO24 = BitField(self, 0x00000001, "DIO24", "This bit reads the data input value of DIO24.")
        self.DIO25 = BitField(self, 0x00000100, "DIO25", "This bit reads the data input value of DIO25.")
        self.DIO26 = BitField(self, 0x00010000, "DIO26", "This bit reads the data input value of DIO26.")
        self.DIO27 = BitField(self, 0x01000000, "DIO27", "This bit reads the data input value of DIO27.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DIN31_28(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN31_28", "Data input 31 to 28")
        self.DIO28 = BitField(self, 0x00000001, "DIO28", "This bit reads the data input value of DIO28.")
        self.DIO29 = BitField(self, 0x00000100, "DIO29", "This bit reads the data input value of DIO29.")
        self.DIO30 = BitField(self, 0x00010000, "DIO30", "This bit reads the data input value of DIO30.")
        self.DIO31 = BitField(self, 0x01000000, "DIO31", "This bit reads the data input value of DIO31.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_DIN31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN31_0", "Data input 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "This bit reads the data input value of DIO0.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "This bit reads the data input value of DIO1.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "This bit reads the data input value of DIO2.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "This bit reads the data input value of DIO3.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "This bit reads the data input value of DIO4.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "This bit reads the data input value of DIO5.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "This bit reads the data input value of DIO6.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "This bit reads the data input value of DIO7.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "This bit reads the data input value of DIO8.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "This bit reads the data input value of DIO9.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "This bit reads the data input value of DIO10.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "This bit reads the data input value of DIO11.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "This bit reads the data input value of DIO12.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "This bit reads the data input value of DIO13.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "This bit reads the data input value of DIO14.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "This bit reads the data input value of DIO15.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "This bit reads the data input value of DIO16.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "This bit reads the data input value of DIO17.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "This bit reads the data input value of DIO18.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "This bit reads the data input value of DIO19.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "This bit reads the data input value of DIO20.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "This bit reads the data input value of DIO21.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "This bit reads the data input value of DIO22.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "This bit reads the data input value of DIO23.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "This bit reads the data input value of DIO24.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "This bit reads the data input value of DIO25.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "This bit reads the data input value of DIO26.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "This bit reads the data input value of DIO27.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "This bit reads the data input value of DIO28.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "This bit reads the data input value of DIO29.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "This bit reads the data input value of DIO30.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "This bit reads the data input value of DIO31.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_POLARITY15_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "POLARITY15_0", "Polarity 15 to 0")
        self.DIO0 = BitField(self, 0x00000003, "DIO0", "Enables and configures edge detection polarity for DIO0.")
        self.DIO1 = BitField(self, 0x0000000C, "DIO1", "Enables and configures edge detection polarity for DIO1.")
        self.DIO2 = BitField(self, 0x00000030, "DIO2", "Enables and configures edge detection polarity for DIO2.")
        self.DIO3 = BitField(self, 0x000000C0, "DIO3", "Enables and configures edge detection polarity for DIO3.")
        self.DIO4 = BitField(self, 0x00000300, "DIO4", "Enables and configures edge detection polarity for DIO4.")
        self.DIO5 = BitField(self, 0x00000C00, "DIO5", "Enables and configures edge detection polarity for DIO5.")
        self.DIO6 = BitField(self, 0x00003000, "DIO6", "Enables and configures edge detection polarity for DIO6.")
        self.DIO7 = BitField(self, 0x0000C000, "DIO7", "Enables and configures edge detection polarity for DIO7.")
        self.DIO8 = BitField(self, 0x00030000, "DIO8", "Enables and configures edge detection polarity for DIO8.")
        self.DIO9 = BitField(self, 0x000C0000, "DIO9", "Enables and configures edge detection polarity for DIO9.")
        self.DIO10 = BitField(self, 0x00300000, "DIO10", "Enables and configures edge detection polarity for DIO10.")
        self.DIO11 = BitField(self, 0x00C00000, "DIO11", "Enables and configures edge detection polarity for DIO11.")
        self.DIO12 = BitField(self, 0x03000000, "DIO12", "Enables and configures edge detection polarity for DIO12.")
        self.DIO13 = BitField(self, 0x0C000000, "DIO13", "Enables and configures edge detection polarity for DIO13.")
        self.DIO14 = BitField(self, 0x30000000, "DIO14", "Enables and configures edge detection polarity for DIO14.")
        self.DIO15 = BitField(self, 0xC0000000, "DIO15", "Enables and configures edge detection polarity for DIO15.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_POLARITY31_16(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "POLARITY31_16", "Polarity 31 to 16")
        self.DIO16 = BitField(self, 0x00000003, "DIO16", "Enables and configures edge detection polarity for DIO16.")
        self.DIO17 = BitField(self, 0x0000000C, "DIO17", "Enables and configures edge detection polarity for DIO17.")
        self.DIO18 = BitField(self, 0x00000030, "DIO18", "Enables and configures edge detection polarity for DIO18.")
        self.DIO19 = BitField(self, 0x000000C0, "DIO19", "Enables and configures edge detection polarity for DIO19.")
        self.DIO20 = BitField(self, 0x00000300, "DIO20", "Enables and configures edge detection polarity for DIO20.")
        self.DIO21 = BitField(self, 0x00000C00, "DIO21", "Enables and configures edge detection polarity for DIO21.")
        self.DIO22 = BitField(self, 0x00003000, "DIO22", "Enables and configures edge detection polarity for DIO22.")
        self.DIO23 = BitField(self, 0x0000C000, "DIO23", "Enables and configures edge detection polarity for DIO23.")
        self.DIO24 = BitField(self, 0x00030000, "DIO24", "Enables and configures edge detection polarity for DIO24.")
        self.DIO25 = BitField(self, 0x000C0000, "DIO25", "Enables and configures edge detection polarity for DIO25.")
        self.DIO26 = BitField(self, 0x00300000, "DIO26", "Enables and configures edge detection polarity for DIO26.")
        self.DIO27 = BitField(self, 0x00C00000, "DIO27", "Enables and configures edge detection polarity for DIO27.")
        self.DIO28 = BitField(self, 0x03000000, "DIO28", "Enables and configures edge detection polarity for DIO28.")
        self.DIO29 = BitField(self, 0x0C000000, "DIO29", "Enables and configures edge detection polarity for DIO29.")
        self.DIO30 = BitField(self, 0x30000000, "DIO30", "Enables and configures edge detection polarity for DIO30.")
        self.DIO31 = BitField(self, 0xC0000000, "DIO31", "Enables and configures edge detection polarity for DIO31.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOB_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL", "FAST WAKE GLOBAL EN")
        self.FASTWAKEONLY = BitField(self, 0x00000001, "FASTWAKEONLY", "FASTWAKEONLY for the global control of fastwake")

class SA_GPIOB_FASTWAKE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FASTWAKE", "FAST WAKE ENABLE")
        self.DIN0 = BitField(self, 0x00000001, "DIN0", "Enable fastwake feature for DIN0")
        self.DIN1 = BitField(self, 0x00000002, "DIN1", "Enable fastwake feature for DIN1")
        self.DIN2 = BitField(self, 0x00000004, "DIN2", "Enable fastwake feature for DIN2")
        self.DIN3 = BitField(self, 0x00000008, "DIN3", "Enable fastwake feature for DIN3")
        self.DIN4 = BitField(self, 0x00000010, "DIN4", "Enable fastwake feature for DIN4")
        self.DIN5 = BitField(self, 0x00000020, "DIN5", "Enable fastwake feature for DIN5")
        self.DIN6 = BitField(self, 0x00000040, "DIN6", "Enable fastwake feature for DIN6")
        self.DIN7 = BitField(self, 0x00000080, "DIN7", "Enable fastwake feature for DIN7")
        self.DIN8 = BitField(self, 0x00000100, "DIN8", "Enable fastwake feature for DIN8")
        self.DIN9 = BitField(self, 0x00000200, "DIN9", "Enable fastwake feature for DIN9")
        self.DIN10 = BitField(self, 0x00000400, "DIN10", "Enable fastwake feature for DIN10")
        self.DIN11 = BitField(self, 0x00000800, "DIN11", "Enable fastwake feature for DIN11")
        self.DIN12 = BitField(self, 0x00001000, "DIN12", "Enable fastwake feature for DIN12")
        self.DIN13 = BitField(self, 0x00002000, "DIN13", "Enable fastwake feature for DIN13")
        self.DIN14 = BitField(self, 0x00004000, "DIN14", "Enable fastwake feature for DIN14")
        self.DIN15 = BitField(self, 0x00008000, "DIN15", "Enable fastwake feature for DIN15")
        self.DIN16 = BitField(self, 0x00010000, "DIN16", "Enable fastwake feature for DIN16")
        self.DIN17 = BitField(self, 0x00020000, "DIN17", "Enable fastwake feature for DIN17")
        self.DIN18 = BitField(self, 0x00040000, "DIN18", "Enable fastwake feature for DIN18")
        self.DIN19 = BitField(self, 0x00080000, "DIN19", "Enable fastwake feature for DIN19")
        self.DIN20 = BitField(self, 0x00100000, "DIN20", "Enable fastwake feature for DIN20")
        self.DIN21 = BitField(self, 0x00200000, "DIN21", "Enable fastwake feature for DIN21")
        self.DIN22 = BitField(self, 0x00400000, "DIN22", "Enable fastwake feature for DIN22")
        self.DIN23 = BitField(self, 0x00800000, "DIN23", "Enable fastwake feature for DIN23")
        self.DIN24 = BitField(self, 0x01000000, "DIN24", "Enable fastwake feature for DIN24")
        self.DIN25 = BitField(self, 0x02000000, "DIN25", "Enable fastwake feature for DIN25")
        self.DIN26 = BitField(self, 0x04000000, "DIN26", "Enable fastwake feature for DIN26")
        self.DIN27 = BitField(self, 0x08000000, "DIN27", "Enable fastwake feature for DIN27")
        self.DIN28 = BitField(self, 0x10000000, "DIN28", "Enable fastwake feature for DIN29")
        self.DIN29 = BitField(self, 0x20000000, "DIN29", "Enable fastwake feature for DIN29")
        self.DIN30 = BitField(self, 0x40000000, "DIN30", "Enable fastwake feature for DIN30")
        self.DIN31 = BitField(self, 0x80000000, "DIN31", "Enable fastwake feature for DIN31")
        self.DIN = Subscriptor(self, "DIN{}")

class SA_GPIOB_SUB0CFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SUB0CFG", "Subscriber 0 configuration")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "This bit is used to enable subscriber 0 event.")
        self.OUTPOLICY = BitField(self, 0x00000300, "OUTPOLICY", "These bits configure the output policy for subscriber 0 event.")
        self.INDEX = BitField(self, 0x000F0000, "INDEX", "Indicates the specific bit among lower 16 bits that is targeted by the subscriber action")

class SA_GPIOB_FILTEREN15_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FILTEREN15_0", "Filter Enable 15 to 0")
        self.DIN0 = BitField(self, 0x00000003, "DIN0", "Programmable counter length of digital glitch filter for DIN0")
        self.DIN1 = BitField(self, 0x0000000C, "DIN1", "Programmable counter length of digital glitch filter for DIN1")
        self.DIN2 = BitField(self, 0x00000030, "DIN2", "Programmable counter length of digital glitch filter for DIN2")
        self.DIN3 = BitField(self, 0x000000C0, "DIN3", "Programmable counter length of digital glitch filter for DIN3")
        self.DIN4 = BitField(self, 0x00000300, "DIN4", "Programmable counter length of digital glitch filter for DIN4")
        self.DIN5 = BitField(self, 0x00000C00, "DIN5", "Programmable counter length of digital glitch filter for DIN5")
        self.DIN6 = BitField(self, 0x00003000, "DIN6", "Programmable counter length of digital glitch filter for DIN6")
        self.DIN7 = BitField(self, 0x0000C000, "DIN7", "Programmable counter length of digital glitch filter for DIN7")
        self.DIN8 = BitField(self, 0x00030000, "DIN8", "Programmable counter length of digital glitch filter for DIN8")
        self.DIN9 = BitField(self, 0x000C0000, "DIN9", "Programmable counter length of digital glitch filter for DIN9")
        self.DIN10 = BitField(self, 0x00300000, "DIN10", "Programmable counter length of digital glitch filter for DIN10")
        self.DIN11 = BitField(self, 0x00C00000, "DIN11", "Programmable counter length of digital glitch filter for DIN11")
        self.DIN12 = BitField(self, 0x03000000, "DIN12", "Programmable counter length of digital glitch filter for DIN12")
        self.DIN13 = BitField(self, 0x0C000000, "DIN13", "Programmable counter length of digital glitch filter for DIN13")
        self.DIN14 = BitField(self, 0x30000000, "DIN14", "Programmable counter length of digital glitch filter for DIN14")
        self.DIN15 = BitField(self, 0xC0000000, "DIN15", "Programmable counter length of digital glitch filter for DIN15")
        self.DIN = Subscriptor(self, "DIN{}")

class SA_GPIOB_FILTEREN31_16(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FILTEREN31_16", "Filter Enable 31 to 16")
        self.DIN16 = BitField(self, 0x00000003, "DIN16", "Programmable counter length of digital glitch filter for DIN16")
        self.DIN17 = BitField(self, 0x0000000C, "DIN17", "Programmable counter length of digital glitch filter for DIN17")
        self.DIN18 = BitField(self, 0x00000030, "DIN18", "Programmable counter length of digital glitch filter for DIN18")
        self.DIN19 = BitField(self, 0x000000C0, "DIN19", "Programmable counter length of digital glitch filter for DIN19")
        self.DIN20 = BitField(self, 0x00000300, "DIN20", "Programmable counter length of digital glitch filter for DIN20")
        self.DIN21 = BitField(self, 0x00000C00, "DIN21", "Programmable counter length of digital glitch filter for DIN21")
        self.DIN22 = BitField(self, 0x00003000, "DIN22", "Programmable counter length of digital glitch filter for DIN22")
        self.DIN23 = BitField(self, 0x0000C000, "DIN23", "Programmable counter length of digital glitch filter for DIN23")
        self.DIN24 = BitField(self, 0x00030000, "DIN24", "Programmable counter length of digital glitch filter for DIN24")
        self.DIN25 = BitField(self, 0x000C0000, "DIN25", "Programmable counter length of digital glitch filter for DIN25")
        self.DIN26 = BitField(self, 0x00300000, "DIN26", "Programmable counter length of digital glitch filter for DIN26")
        self.DIN27 = BitField(self, 0x00C00000, "DIN27", "Programmable counter length of digital glitch filter for DIN27")
        self.DIN28 = BitField(self, 0x03000000, "DIN28", "Programmable counter length of digital glitch filter for DIN28")
        self.DIN29 = BitField(self, 0x0C000000, "DIN29", "Programmable counter length of digital glitch filter for DIN29")
        self.DIN30 = BitField(self, 0x30000000, "DIN30", "Programmable counter length of digital glitch filter for DIN30")
        self.DIN31 = BitField(self, 0xC0000000, "DIN31", "Programmable counter length of digital glitch filter for DIN31")
        self.DIN = Subscriptor(self, "DIN{}")

class SA_GPIOB_DMAMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DMAMASK", "DMA Write MASK")
        self.DOUT0 = BitField(self, 0x00000001, "DOUT0", "DMA is allowed to modify DOUT0")
        self.DOUT1 = BitField(self, 0x00000002, "DOUT1", "DMA is allowed to modify DOUT1")
        self.DOUT2 = BitField(self, 0x00000004, "DOUT2", "DMA is allowed to modify DOUT2")
        self.DOUT3 = BitField(self, 0x00000008, "DOUT3", "DMA is allowed to modify DOUT3")
        self.DOUT4 = BitField(self, 0x00000010, "DOUT4", "DMA is allowed to modify DOUT4")
        self.DOUT5 = BitField(self, 0x00000020, "DOUT5", "DMA is allowed to modify DOUT5")
        self.DOUT6 = BitField(self, 0x00000040, "DOUT6", "DMA is allowed to modify DOUT6")
        self.DOUT7 = BitField(self, 0x00000080, "DOUT7", "DMA is allowed to modify DOUT7")
        self.DOUT8 = BitField(self, 0x00000100, "DOUT8", "DMA is allowed to modify DOUT8")
        self.DOUT9 = BitField(self, 0x00000200, "DOUT9", "DMA is allowed to modify DOUT9")
        self.DOUT10 = BitField(self, 0x00000400, "DOUT10", "DMA is allowed to modify DOUT10")
        self.DOUT11 = BitField(self, 0x00000800, "DOUT11", "DMA is allowed to modify DOUT11")
        self.DOUT12 = BitField(self, 0x00001000, "DOUT12", "DMA is allowed to modify DOUT12")
        self.DOUT13 = BitField(self, 0x00002000, "DOUT13", "DMA is allowed to modify DOUT13")
        self.DOUT14 = BitField(self, 0x00004000, "DOUT14", "DMA is allowed to modify DOUT14")
        self.DOUT15 = BitField(self, 0x00008000, "DOUT15", "DMA is allowed to modify DOUT15")
        self.DOUT16 = BitField(self, 0x00010000, "DOUT16", "DMA is allowed to modify DOUT16")
        self.DOUT17 = BitField(self, 0x00020000, "DOUT17", "DMA is allowed to modify DOUT17")
        self.DOUT18 = BitField(self, 0x00040000, "DOUT18", "DMA is allowed to modify DOUT18")
        self.DOUT19 = BitField(self, 0x00080000, "DOUT19", "DMA is allowed to modify DOUT19")
        self.DOUT20 = BitField(self, 0x00100000, "DOUT20", "DMA is allowed to modify DOUT20")
        self.DOUT21 = BitField(self, 0x00200000, "DOUT21", "DMA is allowed to modify DOUT21")
        self.DOUT22 = BitField(self, 0x00400000, "DOUT22", "DMA is allowed to modify DOUT22")
        self.DOUT23 = BitField(self, 0x00800000, "DOUT23", "DMA is allowed to modify DOUT23")
        self.DOUT24 = BitField(self, 0x01000000, "DOUT24", "DMA is allowed to modify DOUT24")
        self.DOUT25 = BitField(self, 0x02000000, "DOUT25", "DMA is allowed to modify DOUT25")
        self.DOUT26 = BitField(self, 0x04000000, "DOUT26", "DMA is allowed to modify DOUT26")
        self.DOUT27 = BitField(self, 0x08000000, "DOUT27", "DMA is allowed to modify DOUT27")
        self.DOUT28 = BitField(self, 0x10000000, "DOUT28", "DMA is allowed to modify DOUT28")
        self.DOUT29 = BitField(self, 0x20000000, "DOUT29", "DMA is allowed to modify DOUT29")
        self.DOUT30 = BitField(self, 0x40000000, "DOUT30", "DMA is allowed to modify DOUT30")
        self.DOUT31 = BitField(self, 0x80000000, "DOUT31", "DMA is allowed to modify DOUT31")
        self.DOUT = Subscriptor(self, "DOUT{}")

class SA_GPIOB_SUB1CFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SUB1CFG", "Subscriber 1 configuration")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "This bit is used to enable subscriber 1 event.")
        self.OUTPOLICY = BitField(self, 0x00000300, "OUTPOLICY", "These bits configure the output policy for subscriber 1 event.")
        self.INDEX = BitField(self, 0x000F0000, "INDEX", "indicates the specific bit in the upper 16 bits that is targeted by the subscriber action")

class SA_GPIOB(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_GPIOB_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_GPIOB_FSUB_1(self, 0x404)
        self.FPUB_0 = SA_GPIOB_FPUB_0(self, 0x444)
        self.FPUB_1 = SA_GPIOB_FPUB_1(self, 0x448)
        self.PWREN = SA_GPIOB_PWREN(self, 0x800)
        self.RSTCTL = SA_GPIOB_RSTCTL(self, 0x804)
        self.STAT = SA_GPIOB_STAT(self, 0x814)
        self.CLKOVR = SA_GPIOB_CLKOVR(self, 0x1010)
        self.PDBGCTL = SA_GPIOB_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_GPIOB_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_GPIOB_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_GPIOB_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_GPIOB_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_GPIOB_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_GPIOB_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_GPIOB_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_GPIOB_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_GPIOB_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_GPIOB_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_GPIOB_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_GPIOB_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_GPIOB_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_GPIOB_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_GPIOB_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_GPIOB_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_GPIOB_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_GPIOB_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_GPIOB_EVT_MODE(self, 0x10E0)
        self.DESC = SA_GPIOB_DESC(self, 0x10FC)
        self.DOUT3_0 = SA_GPIOB_DOUT3_0(self, 0x1200)
        self.DOUT7_4 = SA_GPIOB_DOUT7_4(self, 0x1204)
        self.DOUT11_8 = SA_GPIOB_DOUT11_8(self, 0x1208)
        self.DOUT15_12 = SA_GPIOB_DOUT15_12(self, 0x120C)
        self.DOUT19_16 = SA_GPIOB_DOUT19_16(self, 0x1210)
        self.DOUT23_20 = SA_GPIOB_DOUT23_20(self, 0x1214)
        self.DOUT27_24 = SA_GPIOB_DOUT27_24(self, 0x1218)
        self.DOUT31_28 = SA_GPIOB_DOUT31_28(self, 0x121C)
        self.DOUT31_0 = SA_GPIOB_DOUT31_0(self, 0x1280)
        self.DOUTSET31_0 = SA_GPIOB_DOUTSET31_0(self, 0x1290)
        self.DOUTCLR31_0 = SA_GPIOB_DOUTCLR31_0(self, 0x12A0)
        self.DOUTTGL31_0 = SA_GPIOB_DOUTTGL31_0(self, 0x12B0)
        self.DOE31_0 = SA_GPIOB_DOE31_0(self, 0x12C0)
        self.DOESET31_0 = SA_GPIOB_DOESET31_0(self, 0x12D0)
        self.DOECLR31_0 = SA_GPIOB_DOECLR31_0(self, 0x12E0)
        self.DIN3_0 = SA_GPIOB_DIN3_0(self, 0x1300)
        self.DIN7_4 = SA_GPIOB_DIN7_4(self, 0x1304)
        self.DIN11_8 = SA_GPIOB_DIN11_8(self, 0x1308)
        self.DIN15_12 = SA_GPIOB_DIN15_12(self, 0x130C)
        self.DIN19_16 = SA_GPIOB_DIN19_16(self, 0x1310)
        self.DIN23_20 = SA_GPIOB_DIN23_20(self, 0x1314)
        self.DIN27_24 = SA_GPIOB_DIN27_24(self, 0x1318)
        self.DIN31_28 = SA_GPIOB_DIN31_28(self, 0x131C)
        self.DIN31_0 = SA_GPIOB_DIN31_0(self, 0x1380)
        self.POLARITY15_0 = SA_GPIOB_POLARITY15_0(self, 0x1390)
        self.POLARITY31_16 = SA_GPIOB_POLARITY31_16(self, 0x13A0)
        self.CTL = SA_GPIOB_CTL(self, 0x1400)
        self.FASTWAKE = SA_GPIOB_FASTWAKE(self, 0x1404)
        self.SUB0CFG = SA_GPIOB_SUB0CFG(self, 0x1500)
        self.FILTEREN15_0 = SA_GPIOB_FILTEREN15_0(self, 0x1508)
        self.FILTEREN31_16 = SA_GPIOB_FILTEREN31_16(self, 0x150C)
        self.DMAMASK = SA_GPIOB_DMAMASK(self, 0x1510)
        self.SUB1CFG = SA_GPIOB_SUB1CFG(self, 0x1520)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.FSUB = Subscriptor(self, "FSUB_{}")
        self.SUBCFG = Subscriptor(self, "SUB{}CFG")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.FPUB = Subscriptor(self, "FPUB_{}")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

GPIOB = SA_GPIOB(0x400A2000, "GPIOB")

class SA_CRC_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_CRC_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_CRC_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_CRC_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_CRC_CTRL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTRL", "CRC Control Register")
        self.CRCCTRL_POLYSIZE = BitField(self, 0x00000001, "CRCCTRL_POLYSIZE", "This bit indicates which CRC calculation is performed by the generator.")
        self.CRCCTRL_BITREVERSE = BitField(self, 0x00000002, "CRCCTRL_BITREVERSE", "CRC Bit Input and output Reverse. This bit indictes that the bit order of each input byte used for the CRC calculation is reversed before it is passed to the generator, and that the bit order of the calculated CRC is be reversed when read from CRC_RESULT.")
        self.CRCCTRL_INPUT_ENDIANNESS = BitField(self, 0x00000004, "CRCCTRL_INPUT_ENDIANNESS", "CRC Endian. This bit indicates the byte order within a word or half word of input data.")
        self.CRCCTRL_OUTPUT_BYTESWAP = BitField(self, 0x00000010, "CRCCTRL_OUTPUT_BYTESWAP", "CRC Output Byteswap Enable. This bit controls whether the output is byte-swapped upon a read of the CRCOUT register.. If CRCOUT is accessed as a half-word, and the OUTPUT_BYTESWAP is set to to 1, then the two bytes in the 16-bit access are swapped and returned. B1 is returned as B0 B0 is returned as B1 If CRCOUT is accessed as a word, and the OUTPUT_BYTESWAP is set to 1, then the four bytes in the 32-bit read are swapped. B3 is returned as B0 B2 is returned as B1 B1 is returned as B2 B0 is returned as B3 Note that if the CRC POLYSIZE is 16-bit and a 32-bit read of CRCOUT is performed with OUTPUT_BYTESWAP enabled, then the output is: MSB LSB 0x0 0x0 B0 B1 If the CRC POLYSIZE is 16-bit and a 32-bit read of CRCOUT is performed with OUTPUT_BYTESWAP disabled, then the output is: MSB LSB 0x0 0x0 B1 B0")

class SA_CRC_SEED(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SEED", "CRC Seed Register")
        self.CRCSEED_SEED = BitField(self, 0xFFFFFFFF, "CRCSEED_SEED", "Seed Data")

class SA_CRC_IN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IN", "CRC Input Data Register")
        self.CRCIN_DATA = BitField(self, 0xFFFFFFFF, "CRCIN_DATA", "Input Data")

class SA_CRC_OUT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OUT", "CRC Output Result Register")
        self.CRCOUT_RESULT = BitField(self, 0xFFFFFFFF, "CRCOUT_RESULT", "Result")

class SA_CRC_IN_IDX0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IN_IDX0", "CRC Input Data Array Register")
        self.CRCIN_IDX_DATA = BitField(self, 0xFFFFFFFF, "CRCIN_IDX_DATA", "Input Data")

class SA_CRC(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_CRC_PWREN(self, 0x800)
        self.RSTCTL = SA_CRC_RSTCTL(self, 0x804)
        self.STAT = SA_CRC_STAT(self, 0x814)
        self.DESC = SA_CRC_DESC(self, 0x10FC)
        self.CTRL = SA_CRC_CTRL(self, 0x1100)
        self.SEED = SA_CRC_SEED(self, 0x1104)
        self.IN = SA_CRC_IN(self, 0x1108)
        self.OUT = SA_CRC_OUT(self, 0x110C)
        self.IN_IDX0 = SA_CRC_IN_IDX0(self, 0x1800)
        self.IN_IDX1 = SA_CRC_IN_IDX0(self, 0x1804)
        self.IN_IDX2 = SA_CRC_IN_IDX0(self, 0x1808)
        self.IN_IDX3 = SA_CRC_IN_IDX0(self, 0x180C)
        self.IN_IDX4 = SA_CRC_IN_IDX0(self, 0x1810)
        self.IN_IDX5 = SA_CRC_IN_IDX0(self, 0x1814)
        self.IN_IDX6 = SA_CRC_IN_IDX0(self, 0x1818)
        self.IN_IDX7 = SA_CRC_IN_IDX0(self, 0x181C)
        self.IN_IDX8 = SA_CRC_IN_IDX0(self, 0x1820)
        self.IN_IDX9 = SA_CRC_IN_IDX0(self, 0x1824)
        self.IN_IDX10 = SA_CRC_IN_IDX0(self, 0x1828)
        self.IN_IDX11 = SA_CRC_IN_IDX0(self, 0x182C)
        self.IN_IDX12 = SA_CRC_IN_IDX0(self, 0x1830)
        self.IN_IDX13 = SA_CRC_IN_IDX0(self, 0x1834)
        self.IN_IDX14 = SA_CRC_IN_IDX0(self, 0x1838)
        self.IN_IDX15 = SA_CRC_IN_IDX0(self, 0x183C)
        self.IN_IDX16 = SA_CRC_IN_IDX0(self, 0x1840)
        self.IN_IDX17 = SA_CRC_IN_IDX0(self, 0x1844)
        self.IN_IDX18 = SA_CRC_IN_IDX0(self, 0x1848)
        self.IN_IDX19 = SA_CRC_IN_IDX0(self, 0x184C)
        self.IN_IDX20 = SA_CRC_IN_IDX0(self, 0x1850)
        self.IN_IDX21 = SA_CRC_IN_IDX0(self, 0x1854)
        self.IN_IDX22 = SA_CRC_IN_IDX0(self, 0x1858)
        self.IN_IDX23 = SA_CRC_IN_IDX0(self, 0x185C)
        self.IN_IDX24 = SA_CRC_IN_IDX0(self, 0x1860)
        self.IN_IDX25 = SA_CRC_IN_IDX0(self, 0x1864)
        self.IN_IDX26 = SA_CRC_IN_IDX0(self, 0x1868)
        self.IN_IDX27 = SA_CRC_IN_IDX0(self, 0x186C)
        self.IN_IDX28 = SA_CRC_IN_IDX0(self, 0x1870)
        self.IN_IDX29 = SA_CRC_IN_IDX0(self, 0x1874)
        self.IN_IDX30 = SA_CRC_IN_IDX0(self, 0x1878)
        self.IN_IDX31 = SA_CRC_IN_IDX0(self, 0x187C)
        self.IN_IDX32 = SA_CRC_IN_IDX0(self, 0x1880)
        self.IN_IDX33 = SA_CRC_IN_IDX0(self, 0x1884)
        self.IN_IDX34 = SA_CRC_IN_IDX0(self, 0x1888)
        self.IN_IDX35 = SA_CRC_IN_IDX0(self, 0x188C)
        self.IN_IDX36 = SA_CRC_IN_IDX0(self, 0x1890)
        self.IN_IDX37 = SA_CRC_IN_IDX0(self, 0x1894)
        self.IN_IDX38 = SA_CRC_IN_IDX0(self, 0x1898)
        self.IN_IDX39 = SA_CRC_IN_IDX0(self, 0x189C)
        self.IN_IDX40 = SA_CRC_IN_IDX0(self, 0x18A0)
        self.IN_IDX41 = SA_CRC_IN_IDX0(self, 0x18A4)
        self.IN_IDX42 = SA_CRC_IN_IDX0(self, 0x18A8)
        self.IN_IDX43 = SA_CRC_IN_IDX0(self, 0x18AC)
        self.IN_IDX44 = SA_CRC_IN_IDX0(self, 0x18B0)
        self.IN_IDX45 = SA_CRC_IN_IDX0(self, 0x18B4)
        self.IN_IDX46 = SA_CRC_IN_IDX0(self, 0x18B8)
        self.IN_IDX47 = SA_CRC_IN_IDX0(self, 0x18BC)
        self.IN_IDX48 = SA_CRC_IN_IDX0(self, 0x18C0)
        self.IN_IDX49 = SA_CRC_IN_IDX0(self, 0x18C4)
        self.IN_IDX50 = SA_CRC_IN_IDX0(self, 0x18C8)
        self.IN_IDX51 = SA_CRC_IN_IDX0(self, 0x18CC)
        self.IN_IDX52 = SA_CRC_IN_IDX0(self, 0x18D0)
        self.IN_IDX53 = SA_CRC_IN_IDX0(self, 0x18D4)
        self.IN_IDX54 = SA_CRC_IN_IDX0(self, 0x18D8)
        self.IN_IDX55 = SA_CRC_IN_IDX0(self, 0x18DC)
        self.IN_IDX56 = SA_CRC_IN_IDX0(self, 0x18E0)
        self.IN_IDX57 = SA_CRC_IN_IDX0(self, 0x18E4)
        self.IN_IDX58 = SA_CRC_IN_IDX0(self, 0x18E8)
        self.IN_IDX59 = SA_CRC_IN_IDX0(self, 0x18EC)
        self.IN_IDX60 = SA_CRC_IN_IDX0(self, 0x18F0)
        self.IN_IDX61 = SA_CRC_IN_IDX0(self, 0x18F4)
        self.IN_IDX62 = SA_CRC_IN_IDX0(self, 0x18F8)
        self.IN_IDX63 = SA_CRC_IN_IDX0(self, 0x18FC)
        self.IN_IDX64 = SA_CRC_IN_IDX0(self, 0x1900)
        self.IN_IDX65 = SA_CRC_IN_IDX0(self, 0x1904)
        self.IN_IDX66 = SA_CRC_IN_IDX0(self, 0x1908)
        self.IN_IDX67 = SA_CRC_IN_IDX0(self, 0x190C)
        self.IN_IDX68 = SA_CRC_IN_IDX0(self, 0x1910)
        self.IN_IDX69 = SA_CRC_IN_IDX0(self, 0x1914)
        self.IN_IDX70 = SA_CRC_IN_IDX0(self, 0x1918)
        self.IN_IDX71 = SA_CRC_IN_IDX0(self, 0x191C)
        self.IN_IDX72 = SA_CRC_IN_IDX0(self, 0x1920)
        self.IN_IDX73 = SA_CRC_IN_IDX0(self, 0x1924)
        self.IN_IDX74 = SA_CRC_IN_IDX0(self, 0x1928)
        self.IN_IDX75 = SA_CRC_IN_IDX0(self, 0x192C)
        self.IN_IDX76 = SA_CRC_IN_IDX0(self, 0x1930)
        self.IN_IDX77 = SA_CRC_IN_IDX0(self, 0x1934)
        self.IN_IDX78 = SA_CRC_IN_IDX0(self, 0x1938)
        self.IN_IDX79 = SA_CRC_IN_IDX0(self, 0x193C)
        self.IN_IDX80 = SA_CRC_IN_IDX0(self, 0x1940)
        self.IN_IDX81 = SA_CRC_IN_IDX0(self, 0x1944)
        self.IN_IDX82 = SA_CRC_IN_IDX0(self, 0x1948)
        self.IN_IDX83 = SA_CRC_IN_IDX0(self, 0x194C)
        self.IN_IDX84 = SA_CRC_IN_IDX0(self, 0x1950)
        self.IN_IDX85 = SA_CRC_IN_IDX0(self, 0x1954)
        self.IN_IDX86 = SA_CRC_IN_IDX0(self, 0x1958)
        self.IN_IDX87 = SA_CRC_IN_IDX0(self, 0x195C)
        self.IN_IDX88 = SA_CRC_IN_IDX0(self, 0x1960)
        self.IN_IDX89 = SA_CRC_IN_IDX0(self, 0x1964)
        self.IN_IDX90 = SA_CRC_IN_IDX0(self, 0x1968)
        self.IN_IDX91 = SA_CRC_IN_IDX0(self, 0x196C)
        self.IN_IDX92 = SA_CRC_IN_IDX0(self, 0x1970)
        self.IN_IDX93 = SA_CRC_IN_IDX0(self, 0x1974)
        self.IN_IDX94 = SA_CRC_IN_IDX0(self, 0x1978)
        self.IN_IDX95 = SA_CRC_IN_IDX0(self, 0x197C)
        self.IN_IDX96 = SA_CRC_IN_IDX0(self, 0x1980)
        self.IN_IDX97 = SA_CRC_IN_IDX0(self, 0x1984)
        self.IN_IDX98 = SA_CRC_IN_IDX0(self, 0x1988)
        self.IN_IDX99 = SA_CRC_IN_IDX0(self, 0x198C)
        self.IN_IDX100 = SA_CRC_IN_IDX0(self, 0x1990)
        self.IN_IDX101 = SA_CRC_IN_IDX0(self, 0x1994)
        self.IN_IDX102 = SA_CRC_IN_IDX0(self, 0x1998)
        self.IN_IDX103 = SA_CRC_IN_IDX0(self, 0x199C)
        self.IN_IDX104 = SA_CRC_IN_IDX0(self, 0x19A0)
        self.IN_IDX105 = SA_CRC_IN_IDX0(self, 0x19A4)
        self.IN_IDX106 = SA_CRC_IN_IDX0(self, 0x19A8)
        self.IN_IDX107 = SA_CRC_IN_IDX0(self, 0x19AC)
        self.IN_IDX108 = SA_CRC_IN_IDX0(self, 0x19B0)
        self.IN_IDX109 = SA_CRC_IN_IDX0(self, 0x19B4)
        self.IN_IDX110 = SA_CRC_IN_IDX0(self, 0x19B8)
        self.IN_IDX111 = SA_CRC_IN_IDX0(self, 0x19BC)
        self.IN_IDX112 = SA_CRC_IN_IDX0(self, 0x19C0)
        self.IN_IDX113 = SA_CRC_IN_IDX0(self, 0x19C4)
        self.IN_IDX114 = SA_CRC_IN_IDX0(self, 0x19C8)
        self.IN_IDX115 = SA_CRC_IN_IDX0(self, 0x19CC)
        self.IN_IDX116 = SA_CRC_IN_IDX0(self, 0x19D0)
        self.IN_IDX117 = SA_CRC_IN_IDX0(self, 0x19D4)
        self.IN_IDX118 = SA_CRC_IN_IDX0(self, 0x19D8)
        self.IN_IDX119 = SA_CRC_IN_IDX0(self, 0x19DC)
        self.IN_IDX120 = SA_CRC_IN_IDX0(self, 0x19E0)
        self.IN_IDX121 = SA_CRC_IN_IDX0(self, 0x19E4)
        self.IN_IDX122 = SA_CRC_IN_IDX0(self, 0x19E8)
        self.IN_IDX123 = SA_CRC_IN_IDX0(self, 0x19EC)
        self.IN_IDX124 = SA_CRC_IN_IDX0(self, 0x19F0)
        self.IN_IDX125 = SA_CRC_IN_IDX0(self, 0x19F4)
        self.IN_IDX126 = SA_CRC_IN_IDX0(self, 0x19F8)
        self.IN_IDX127 = SA_CRC_IN_IDX0(self, 0x19FC)
        self.IN_IDX128 = SA_CRC_IN_IDX0(self, 0x1A00)
        self.IN_IDX129 = SA_CRC_IN_IDX0(self, 0x1A04)
        self.IN_IDX130 = SA_CRC_IN_IDX0(self, 0x1A08)
        self.IN_IDX131 = SA_CRC_IN_IDX0(self, 0x1A0C)
        self.IN_IDX132 = SA_CRC_IN_IDX0(self, 0x1A10)
        self.IN_IDX133 = SA_CRC_IN_IDX0(self, 0x1A14)
        self.IN_IDX134 = SA_CRC_IN_IDX0(self, 0x1A18)
        self.IN_IDX135 = SA_CRC_IN_IDX0(self, 0x1A1C)
        self.IN_IDX136 = SA_CRC_IN_IDX0(self, 0x1A20)
        self.IN_IDX137 = SA_CRC_IN_IDX0(self, 0x1A24)
        self.IN_IDX138 = SA_CRC_IN_IDX0(self, 0x1A28)
        self.IN_IDX139 = SA_CRC_IN_IDX0(self, 0x1A2C)
        self.IN_IDX140 = SA_CRC_IN_IDX0(self, 0x1A30)
        self.IN_IDX141 = SA_CRC_IN_IDX0(self, 0x1A34)
        self.IN_IDX142 = SA_CRC_IN_IDX0(self, 0x1A38)
        self.IN_IDX143 = SA_CRC_IN_IDX0(self, 0x1A3C)
        self.IN_IDX144 = SA_CRC_IN_IDX0(self, 0x1A40)
        self.IN_IDX145 = SA_CRC_IN_IDX0(self, 0x1A44)
        self.IN_IDX146 = SA_CRC_IN_IDX0(self, 0x1A48)
        self.IN_IDX147 = SA_CRC_IN_IDX0(self, 0x1A4C)
        self.IN_IDX148 = SA_CRC_IN_IDX0(self, 0x1A50)
        self.IN_IDX149 = SA_CRC_IN_IDX0(self, 0x1A54)
        self.IN_IDX150 = SA_CRC_IN_IDX0(self, 0x1A58)
        self.IN_IDX151 = SA_CRC_IN_IDX0(self, 0x1A5C)
        self.IN_IDX152 = SA_CRC_IN_IDX0(self, 0x1A60)
        self.IN_IDX153 = SA_CRC_IN_IDX0(self, 0x1A64)
        self.IN_IDX154 = SA_CRC_IN_IDX0(self, 0x1A68)
        self.IN_IDX155 = SA_CRC_IN_IDX0(self, 0x1A6C)
        self.IN_IDX156 = SA_CRC_IN_IDX0(self, 0x1A70)
        self.IN_IDX157 = SA_CRC_IN_IDX0(self, 0x1A74)
        self.IN_IDX158 = SA_CRC_IN_IDX0(self, 0x1A78)
        self.IN_IDX159 = SA_CRC_IN_IDX0(self, 0x1A7C)
        self.IN_IDX160 = SA_CRC_IN_IDX0(self, 0x1A80)
        self.IN_IDX161 = SA_CRC_IN_IDX0(self, 0x1A84)
        self.IN_IDX162 = SA_CRC_IN_IDX0(self, 0x1A88)
        self.IN_IDX163 = SA_CRC_IN_IDX0(self, 0x1A8C)
        self.IN_IDX164 = SA_CRC_IN_IDX0(self, 0x1A90)
        self.IN_IDX165 = SA_CRC_IN_IDX0(self, 0x1A94)
        self.IN_IDX166 = SA_CRC_IN_IDX0(self, 0x1A98)
        self.IN_IDX167 = SA_CRC_IN_IDX0(self, 0x1A9C)
        self.IN_IDX168 = SA_CRC_IN_IDX0(self, 0x1AA0)
        self.IN_IDX169 = SA_CRC_IN_IDX0(self, 0x1AA4)
        self.IN_IDX170 = SA_CRC_IN_IDX0(self, 0x1AA8)
        self.IN_IDX171 = SA_CRC_IN_IDX0(self, 0x1AAC)
        self.IN_IDX172 = SA_CRC_IN_IDX0(self, 0x1AB0)
        self.IN_IDX173 = SA_CRC_IN_IDX0(self, 0x1AB4)
        self.IN_IDX174 = SA_CRC_IN_IDX0(self, 0x1AB8)
        self.IN_IDX175 = SA_CRC_IN_IDX0(self, 0x1ABC)
        self.IN_IDX176 = SA_CRC_IN_IDX0(self, 0x1AC0)
        self.IN_IDX177 = SA_CRC_IN_IDX0(self, 0x1AC4)
        self.IN_IDX178 = SA_CRC_IN_IDX0(self, 0x1AC8)
        self.IN_IDX179 = SA_CRC_IN_IDX0(self, 0x1ACC)
        self.IN_IDX180 = SA_CRC_IN_IDX0(self, 0x1AD0)
        self.IN_IDX181 = SA_CRC_IN_IDX0(self, 0x1AD4)
        self.IN_IDX182 = SA_CRC_IN_IDX0(self, 0x1AD8)
        self.IN_IDX183 = SA_CRC_IN_IDX0(self, 0x1ADC)
        self.IN_IDX184 = SA_CRC_IN_IDX0(self, 0x1AE0)
        self.IN_IDX185 = SA_CRC_IN_IDX0(self, 0x1AE4)
        self.IN_IDX186 = SA_CRC_IN_IDX0(self, 0x1AE8)
        self.IN_IDX187 = SA_CRC_IN_IDX0(self, 0x1AEC)
        self.IN_IDX188 = SA_CRC_IN_IDX0(self, 0x1AF0)
        self.IN_IDX189 = SA_CRC_IN_IDX0(self, 0x1AF4)
        self.IN_IDX190 = SA_CRC_IN_IDX0(self, 0x1AF8)
        self.IN_IDX191 = SA_CRC_IN_IDX0(self, 0x1AFC)
        self.IN_IDX192 = SA_CRC_IN_IDX0(self, 0x1B00)
        self.IN_IDX193 = SA_CRC_IN_IDX0(self, 0x1B04)
        self.IN_IDX194 = SA_CRC_IN_IDX0(self, 0x1B08)
        self.IN_IDX195 = SA_CRC_IN_IDX0(self, 0x1B0C)
        self.IN_IDX196 = SA_CRC_IN_IDX0(self, 0x1B10)
        self.IN_IDX197 = SA_CRC_IN_IDX0(self, 0x1B14)
        self.IN_IDX198 = SA_CRC_IN_IDX0(self, 0x1B18)
        self.IN_IDX199 = SA_CRC_IN_IDX0(self, 0x1B1C)
        self.IN_IDX200 = SA_CRC_IN_IDX0(self, 0x1B20)
        self.IN_IDX201 = SA_CRC_IN_IDX0(self, 0x1B24)
        self.IN_IDX202 = SA_CRC_IN_IDX0(self, 0x1B28)
        self.IN_IDX203 = SA_CRC_IN_IDX0(self, 0x1B2C)
        self.IN_IDX204 = SA_CRC_IN_IDX0(self, 0x1B30)
        self.IN_IDX205 = SA_CRC_IN_IDX0(self, 0x1B34)
        self.IN_IDX206 = SA_CRC_IN_IDX0(self, 0x1B38)
        self.IN_IDX207 = SA_CRC_IN_IDX0(self, 0x1B3C)
        self.IN_IDX208 = SA_CRC_IN_IDX0(self, 0x1B40)
        self.IN_IDX209 = SA_CRC_IN_IDX0(self, 0x1B44)
        self.IN_IDX210 = SA_CRC_IN_IDX0(self, 0x1B48)
        self.IN_IDX211 = SA_CRC_IN_IDX0(self, 0x1B4C)
        self.IN_IDX212 = SA_CRC_IN_IDX0(self, 0x1B50)
        self.IN_IDX213 = SA_CRC_IN_IDX0(self, 0x1B54)
        self.IN_IDX214 = SA_CRC_IN_IDX0(self, 0x1B58)
        self.IN_IDX215 = SA_CRC_IN_IDX0(self, 0x1B5C)
        self.IN_IDX216 = SA_CRC_IN_IDX0(self, 0x1B60)
        self.IN_IDX217 = SA_CRC_IN_IDX0(self, 0x1B64)
        self.IN_IDX218 = SA_CRC_IN_IDX0(self, 0x1B68)
        self.IN_IDX219 = SA_CRC_IN_IDX0(self, 0x1B6C)
        self.IN_IDX220 = SA_CRC_IN_IDX0(self, 0x1B70)
        self.IN_IDX221 = SA_CRC_IN_IDX0(self, 0x1B74)
        self.IN_IDX222 = SA_CRC_IN_IDX0(self, 0x1B78)
        self.IN_IDX223 = SA_CRC_IN_IDX0(self, 0x1B7C)
        self.IN_IDX224 = SA_CRC_IN_IDX0(self, 0x1B80)
        self.IN_IDX225 = SA_CRC_IN_IDX0(self, 0x1B84)
        self.IN_IDX226 = SA_CRC_IN_IDX0(self, 0x1B88)
        self.IN_IDX227 = SA_CRC_IN_IDX0(self, 0x1B8C)
        self.IN_IDX228 = SA_CRC_IN_IDX0(self, 0x1B90)
        self.IN_IDX229 = SA_CRC_IN_IDX0(self, 0x1B94)
        self.IN_IDX230 = SA_CRC_IN_IDX0(self, 0x1B98)
        self.IN_IDX231 = SA_CRC_IN_IDX0(self, 0x1B9C)
        self.IN_IDX232 = SA_CRC_IN_IDX0(self, 0x1BA0)
        self.IN_IDX233 = SA_CRC_IN_IDX0(self, 0x1BA4)
        self.IN_IDX234 = SA_CRC_IN_IDX0(self, 0x1BA8)
        self.IN_IDX235 = SA_CRC_IN_IDX0(self, 0x1BAC)
        self.IN_IDX236 = SA_CRC_IN_IDX0(self, 0x1BB0)
        self.IN_IDX237 = SA_CRC_IN_IDX0(self, 0x1BB4)
        self.IN_IDX238 = SA_CRC_IN_IDX0(self, 0x1BB8)
        self.IN_IDX239 = SA_CRC_IN_IDX0(self, 0x1BBC)
        self.IN_IDX240 = SA_CRC_IN_IDX0(self, 0x1BC0)
        self.IN_IDX241 = SA_CRC_IN_IDX0(self, 0x1BC4)
        self.IN_IDX242 = SA_CRC_IN_IDX0(self, 0x1BC8)
        self.IN_IDX243 = SA_CRC_IN_IDX0(self, 0x1BCC)
        self.IN_IDX244 = SA_CRC_IN_IDX0(self, 0x1BD0)
        self.IN_IDX245 = SA_CRC_IN_IDX0(self, 0x1BD4)
        self.IN_IDX246 = SA_CRC_IN_IDX0(self, 0x1BD8)
        self.IN_IDX247 = SA_CRC_IN_IDX0(self, 0x1BDC)
        self.IN_IDX248 = SA_CRC_IN_IDX0(self, 0x1BE0)
        self.IN_IDX249 = SA_CRC_IN_IDX0(self, 0x1BE4)
        self.IN_IDX250 = SA_CRC_IN_IDX0(self, 0x1BE8)
        self.IN_IDX251 = SA_CRC_IN_IDX0(self, 0x1BEC)
        self.IN_IDX252 = SA_CRC_IN_IDX0(self, 0x1BF0)
        self.IN_IDX253 = SA_CRC_IN_IDX0(self, 0x1BF4)
        self.IN_IDX254 = SA_CRC_IN_IDX0(self, 0x1BF8)
        self.IN_IDX255 = SA_CRC_IN_IDX0(self, 0x1BFC)
        self.IN_IDX256 = SA_CRC_IN_IDX0(self, 0x1C00)
        self.IN_IDX257 = SA_CRC_IN_IDX0(self, 0x1C04)
        self.IN_IDX258 = SA_CRC_IN_IDX0(self, 0x1C08)
        self.IN_IDX259 = SA_CRC_IN_IDX0(self, 0x1C0C)
        self.IN_IDX260 = SA_CRC_IN_IDX0(self, 0x1C10)
        self.IN_IDX261 = SA_CRC_IN_IDX0(self, 0x1C14)
        self.IN_IDX262 = SA_CRC_IN_IDX0(self, 0x1C18)
        self.IN_IDX263 = SA_CRC_IN_IDX0(self, 0x1C1C)
        self.IN_IDX264 = SA_CRC_IN_IDX0(self, 0x1C20)
        self.IN_IDX265 = SA_CRC_IN_IDX0(self, 0x1C24)
        self.IN_IDX266 = SA_CRC_IN_IDX0(self, 0x1C28)
        self.IN_IDX267 = SA_CRC_IN_IDX0(self, 0x1C2C)
        self.IN_IDX268 = SA_CRC_IN_IDX0(self, 0x1C30)
        self.IN_IDX269 = SA_CRC_IN_IDX0(self, 0x1C34)
        self.IN_IDX270 = SA_CRC_IN_IDX0(self, 0x1C38)
        self.IN_IDX271 = SA_CRC_IN_IDX0(self, 0x1C3C)
        self.IN_IDX272 = SA_CRC_IN_IDX0(self, 0x1C40)
        self.IN_IDX273 = SA_CRC_IN_IDX0(self, 0x1C44)
        self.IN_IDX274 = SA_CRC_IN_IDX0(self, 0x1C48)
        self.IN_IDX275 = SA_CRC_IN_IDX0(self, 0x1C4C)
        self.IN_IDX276 = SA_CRC_IN_IDX0(self, 0x1C50)
        self.IN_IDX277 = SA_CRC_IN_IDX0(self, 0x1C54)
        self.IN_IDX278 = SA_CRC_IN_IDX0(self, 0x1C58)
        self.IN_IDX279 = SA_CRC_IN_IDX0(self, 0x1C5C)
        self.IN_IDX280 = SA_CRC_IN_IDX0(self, 0x1C60)
        self.IN_IDX281 = SA_CRC_IN_IDX0(self, 0x1C64)
        self.IN_IDX282 = SA_CRC_IN_IDX0(self, 0x1C68)
        self.IN_IDX283 = SA_CRC_IN_IDX0(self, 0x1C6C)
        self.IN_IDX284 = SA_CRC_IN_IDX0(self, 0x1C70)
        self.IN_IDX285 = SA_CRC_IN_IDX0(self, 0x1C74)
        self.IN_IDX286 = SA_CRC_IN_IDX0(self, 0x1C78)
        self.IN_IDX287 = SA_CRC_IN_IDX0(self, 0x1C7C)
        self.IN_IDX288 = SA_CRC_IN_IDX0(self, 0x1C80)
        self.IN_IDX289 = SA_CRC_IN_IDX0(self, 0x1C84)
        self.IN_IDX290 = SA_CRC_IN_IDX0(self, 0x1C88)
        self.IN_IDX291 = SA_CRC_IN_IDX0(self, 0x1C8C)
        self.IN_IDX292 = SA_CRC_IN_IDX0(self, 0x1C90)
        self.IN_IDX293 = SA_CRC_IN_IDX0(self, 0x1C94)
        self.IN_IDX294 = SA_CRC_IN_IDX0(self, 0x1C98)
        self.IN_IDX295 = SA_CRC_IN_IDX0(self, 0x1C9C)
        self.IN_IDX296 = SA_CRC_IN_IDX0(self, 0x1CA0)
        self.IN_IDX297 = SA_CRC_IN_IDX0(self, 0x1CA4)
        self.IN_IDX298 = SA_CRC_IN_IDX0(self, 0x1CA8)
        self.IN_IDX299 = SA_CRC_IN_IDX0(self, 0x1CAC)
        self.IN_IDX300 = SA_CRC_IN_IDX0(self, 0x1CB0)
        self.IN_IDX301 = SA_CRC_IN_IDX0(self, 0x1CB4)
        self.IN_IDX302 = SA_CRC_IN_IDX0(self, 0x1CB8)
        self.IN_IDX303 = SA_CRC_IN_IDX0(self, 0x1CBC)
        self.IN_IDX304 = SA_CRC_IN_IDX0(self, 0x1CC0)
        self.IN_IDX305 = SA_CRC_IN_IDX0(self, 0x1CC4)
        self.IN_IDX306 = SA_CRC_IN_IDX0(self, 0x1CC8)
        self.IN_IDX307 = SA_CRC_IN_IDX0(self, 0x1CCC)
        self.IN_IDX308 = SA_CRC_IN_IDX0(self, 0x1CD0)
        self.IN_IDX309 = SA_CRC_IN_IDX0(self, 0x1CD4)
        self.IN_IDX310 = SA_CRC_IN_IDX0(self, 0x1CD8)
        self.IN_IDX311 = SA_CRC_IN_IDX0(self, 0x1CDC)
        self.IN_IDX312 = SA_CRC_IN_IDX0(self, 0x1CE0)
        self.IN_IDX313 = SA_CRC_IN_IDX0(self, 0x1CE4)
        self.IN_IDX314 = SA_CRC_IN_IDX0(self, 0x1CE8)
        self.IN_IDX315 = SA_CRC_IN_IDX0(self, 0x1CEC)
        self.IN_IDX316 = SA_CRC_IN_IDX0(self, 0x1CF0)
        self.IN_IDX317 = SA_CRC_IN_IDX0(self, 0x1CF4)
        self.IN_IDX318 = SA_CRC_IN_IDX0(self, 0x1CF8)
        self.IN_IDX319 = SA_CRC_IN_IDX0(self, 0x1CFC)
        self.IN_IDX320 = SA_CRC_IN_IDX0(self, 0x1D00)
        self.IN_IDX321 = SA_CRC_IN_IDX0(self, 0x1D04)
        self.IN_IDX322 = SA_CRC_IN_IDX0(self, 0x1D08)
        self.IN_IDX323 = SA_CRC_IN_IDX0(self, 0x1D0C)
        self.IN_IDX324 = SA_CRC_IN_IDX0(self, 0x1D10)
        self.IN_IDX325 = SA_CRC_IN_IDX0(self, 0x1D14)
        self.IN_IDX326 = SA_CRC_IN_IDX0(self, 0x1D18)
        self.IN_IDX327 = SA_CRC_IN_IDX0(self, 0x1D1C)
        self.IN_IDX328 = SA_CRC_IN_IDX0(self, 0x1D20)
        self.IN_IDX329 = SA_CRC_IN_IDX0(self, 0x1D24)
        self.IN_IDX330 = SA_CRC_IN_IDX0(self, 0x1D28)
        self.IN_IDX331 = SA_CRC_IN_IDX0(self, 0x1D2C)
        self.IN_IDX332 = SA_CRC_IN_IDX0(self, 0x1D30)
        self.IN_IDX333 = SA_CRC_IN_IDX0(self, 0x1D34)
        self.IN_IDX334 = SA_CRC_IN_IDX0(self, 0x1D38)
        self.IN_IDX335 = SA_CRC_IN_IDX0(self, 0x1D3C)
        self.IN_IDX336 = SA_CRC_IN_IDX0(self, 0x1D40)
        self.IN_IDX337 = SA_CRC_IN_IDX0(self, 0x1D44)
        self.IN_IDX338 = SA_CRC_IN_IDX0(self, 0x1D48)
        self.IN_IDX339 = SA_CRC_IN_IDX0(self, 0x1D4C)
        self.IN_IDX340 = SA_CRC_IN_IDX0(self, 0x1D50)
        self.IN_IDX341 = SA_CRC_IN_IDX0(self, 0x1D54)
        self.IN_IDX342 = SA_CRC_IN_IDX0(self, 0x1D58)
        self.IN_IDX343 = SA_CRC_IN_IDX0(self, 0x1D5C)
        self.IN_IDX344 = SA_CRC_IN_IDX0(self, 0x1D60)
        self.IN_IDX345 = SA_CRC_IN_IDX0(self, 0x1D64)
        self.IN_IDX346 = SA_CRC_IN_IDX0(self, 0x1D68)
        self.IN_IDX347 = SA_CRC_IN_IDX0(self, 0x1D6C)
        self.IN_IDX348 = SA_CRC_IN_IDX0(self, 0x1D70)
        self.IN_IDX349 = SA_CRC_IN_IDX0(self, 0x1D74)
        self.IN_IDX350 = SA_CRC_IN_IDX0(self, 0x1D78)
        self.IN_IDX351 = SA_CRC_IN_IDX0(self, 0x1D7C)
        self.IN_IDX352 = SA_CRC_IN_IDX0(self, 0x1D80)
        self.IN_IDX353 = SA_CRC_IN_IDX0(self, 0x1D84)
        self.IN_IDX354 = SA_CRC_IN_IDX0(self, 0x1D88)
        self.IN_IDX355 = SA_CRC_IN_IDX0(self, 0x1D8C)
        self.IN_IDX356 = SA_CRC_IN_IDX0(self, 0x1D90)
        self.IN_IDX357 = SA_CRC_IN_IDX0(self, 0x1D94)
        self.IN_IDX358 = SA_CRC_IN_IDX0(self, 0x1D98)
        self.IN_IDX359 = SA_CRC_IN_IDX0(self, 0x1D9C)
        self.IN_IDX360 = SA_CRC_IN_IDX0(self, 0x1DA0)
        self.IN_IDX361 = SA_CRC_IN_IDX0(self, 0x1DA4)
        self.IN_IDX362 = SA_CRC_IN_IDX0(self, 0x1DA8)
        self.IN_IDX363 = SA_CRC_IN_IDX0(self, 0x1DAC)
        self.IN_IDX364 = SA_CRC_IN_IDX0(self, 0x1DB0)
        self.IN_IDX365 = SA_CRC_IN_IDX0(self, 0x1DB4)
        self.IN_IDX366 = SA_CRC_IN_IDX0(self, 0x1DB8)
        self.IN_IDX367 = SA_CRC_IN_IDX0(self, 0x1DBC)
        self.IN_IDX368 = SA_CRC_IN_IDX0(self, 0x1DC0)
        self.IN_IDX369 = SA_CRC_IN_IDX0(self, 0x1DC4)
        self.IN_IDX370 = SA_CRC_IN_IDX0(self, 0x1DC8)
        self.IN_IDX371 = SA_CRC_IN_IDX0(self, 0x1DCC)
        self.IN_IDX372 = SA_CRC_IN_IDX0(self, 0x1DD0)
        self.IN_IDX373 = SA_CRC_IN_IDX0(self, 0x1DD4)
        self.IN_IDX374 = SA_CRC_IN_IDX0(self, 0x1DD8)
        self.IN_IDX375 = SA_CRC_IN_IDX0(self, 0x1DDC)
        self.IN_IDX376 = SA_CRC_IN_IDX0(self, 0x1DE0)
        self.IN_IDX377 = SA_CRC_IN_IDX0(self, 0x1DE4)
        self.IN_IDX378 = SA_CRC_IN_IDX0(self, 0x1DE8)
        self.IN_IDX379 = SA_CRC_IN_IDX0(self, 0x1DEC)
        self.IN_IDX380 = SA_CRC_IN_IDX0(self, 0x1DF0)
        self.IN_IDX381 = SA_CRC_IN_IDX0(self, 0x1DF4)
        self.IN_IDX382 = SA_CRC_IN_IDX0(self, 0x1DF8)
        self.IN_IDX383 = SA_CRC_IN_IDX0(self, 0x1DFC)
        self.IN_IDX384 = SA_CRC_IN_IDX0(self, 0x1E00)
        self.IN_IDX385 = SA_CRC_IN_IDX0(self, 0x1E04)
        self.IN_IDX386 = SA_CRC_IN_IDX0(self, 0x1E08)
        self.IN_IDX387 = SA_CRC_IN_IDX0(self, 0x1E0C)
        self.IN_IDX388 = SA_CRC_IN_IDX0(self, 0x1E10)
        self.IN_IDX389 = SA_CRC_IN_IDX0(self, 0x1E14)
        self.IN_IDX390 = SA_CRC_IN_IDX0(self, 0x1E18)
        self.IN_IDX391 = SA_CRC_IN_IDX0(self, 0x1E1C)
        self.IN_IDX392 = SA_CRC_IN_IDX0(self, 0x1E20)
        self.IN_IDX393 = SA_CRC_IN_IDX0(self, 0x1E24)
        self.IN_IDX394 = SA_CRC_IN_IDX0(self, 0x1E28)
        self.IN_IDX395 = SA_CRC_IN_IDX0(self, 0x1E2C)
        self.IN_IDX396 = SA_CRC_IN_IDX0(self, 0x1E30)
        self.IN_IDX397 = SA_CRC_IN_IDX0(self, 0x1E34)
        self.IN_IDX398 = SA_CRC_IN_IDX0(self, 0x1E38)
        self.IN_IDX399 = SA_CRC_IN_IDX0(self, 0x1E3C)
        self.IN_IDX400 = SA_CRC_IN_IDX0(self, 0x1E40)
        self.IN_IDX401 = SA_CRC_IN_IDX0(self, 0x1E44)
        self.IN_IDX402 = SA_CRC_IN_IDX0(self, 0x1E48)
        self.IN_IDX403 = SA_CRC_IN_IDX0(self, 0x1E4C)
        self.IN_IDX404 = SA_CRC_IN_IDX0(self, 0x1E50)
        self.IN_IDX405 = SA_CRC_IN_IDX0(self, 0x1E54)
        self.IN_IDX406 = SA_CRC_IN_IDX0(self, 0x1E58)
        self.IN_IDX407 = SA_CRC_IN_IDX0(self, 0x1E5C)
        self.IN_IDX408 = SA_CRC_IN_IDX0(self, 0x1E60)
        self.IN_IDX409 = SA_CRC_IN_IDX0(self, 0x1E64)
        self.IN_IDX410 = SA_CRC_IN_IDX0(self, 0x1E68)
        self.IN_IDX411 = SA_CRC_IN_IDX0(self, 0x1E6C)
        self.IN_IDX412 = SA_CRC_IN_IDX0(self, 0x1E70)
        self.IN_IDX413 = SA_CRC_IN_IDX0(self, 0x1E74)
        self.IN_IDX414 = SA_CRC_IN_IDX0(self, 0x1E78)
        self.IN_IDX415 = SA_CRC_IN_IDX0(self, 0x1E7C)
        self.IN_IDX416 = SA_CRC_IN_IDX0(self, 0x1E80)
        self.IN_IDX417 = SA_CRC_IN_IDX0(self, 0x1E84)
        self.IN_IDX418 = SA_CRC_IN_IDX0(self, 0x1E88)
        self.IN_IDX419 = SA_CRC_IN_IDX0(self, 0x1E8C)
        self.IN_IDX420 = SA_CRC_IN_IDX0(self, 0x1E90)
        self.IN_IDX421 = SA_CRC_IN_IDX0(self, 0x1E94)
        self.IN_IDX422 = SA_CRC_IN_IDX0(self, 0x1E98)
        self.IN_IDX423 = SA_CRC_IN_IDX0(self, 0x1E9C)
        self.IN_IDX424 = SA_CRC_IN_IDX0(self, 0x1EA0)
        self.IN_IDX425 = SA_CRC_IN_IDX0(self, 0x1EA4)
        self.IN_IDX426 = SA_CRC_IN_IDX0(self, 0x1EA8)
        self.IN_IDX427 = SA_CRC_IN_IDX0(self, 0x1EAC)
        self.IN_IDX428 = SA_CRC_IN_IDX0(self, 0x1EB0)
        self.IN_IDX429 = SA_CRC_IN_IDX0(self, 0x1EB4)
        self.IN_IDX430 = SA_CRC_IN_IDX0(self, 0x1EB8)
        self.IN_IDX431 = SA_CRC_IN_IDX0(self, 0x1EBC)
        self.IN_IDX432 = SA_CRC_IN_IDX0(self, 0x1EC0)
        self.IN_IDX433 = SA_CRC_IN_IDX0(self, 0x1EC4)
        self.IN_IDX434 = SA_CRC_IN_IDX0(self, 0x1EC8)
        self.IN_IDX435 = SA_CRC_IN_IDX0(self, 0x1ECC)
        self.IN_IDX436 = SA_CRC_IN_IDX0(self, 0x1ED0)
        self.IN_IDX437 = SA_CRC_IN_IDX0(self, 0x1ED4)
        self.IN_IDX438 = SA_CRC_IN_IDX0(self, 0x1ED8)
        self.IN_IDX439 = SA_CRC_IN_IDX0(self, 0x1EDC)
        self.IN_IDX440 = SA_CRC_IN_IDX0(self, 0x1EE0)
        self.IN_IDX441 = SA_CRC_IN_IDX0(self, 0x1EE4)
        self.IN_IDX442 = SA_CRC_IN_IDX0(self, 0x1EE8)
        self.IN_IDX443 = SA_CRC_IN_IDX0(self, 0x1EEC)
        self.IN_IDX444 = SA_CRC_IN_IDX0(self, 0x1EF0)
        self.IN_IDX445 = SA_CRC_IN_IDX0(self, 0x1EF4)
        self.IN_IDX446 = SA_CRC_IN_IDX0(self, 0x1EF8)
        self.IN_IDX447 = SA_CRC_IN_IDX0(self, 0x1EFC)
        self.IN_IDX448 = SA_CRC_IN_IDX0(self, 0x1F00)
        self.IN_IDX449 = SA_CRC_IN_IDX0(self, 0x1F04)
        self.IN_IDX450 = SA_CRC_IN_IDX0(self, 0x1F08)
        self.IN_IDX451 = SA_CRC_IN_IDX0(self, 0x1F0C)
        self.IN_IDX452 = SA_CRC_IN_IDX0(self, 0x1F10)
        self.IN_IDX453 = SA_CRC_IN_IDX0(self, 0x1F14)
        self.IN_IDX454 = SA_CRC_IN_IDX0(self, 0x1F18)
        self.IN_IDX455 = SA_CRC_IN_IDX0(self, 0x1F1C)
        self.IN_IDX456 = SA_CRC_IN_IDX0(self, 0x1F20)
        self.IN_IDX457 = SA_CRC_IN_IDX0(self, 0x1F24)
        self.IN_IDX458 = SA_CRC_IN_IDX0(self, 0x1F28)
        self.IN_IDX459 = SA_CRC_IN_IDX0(self, 0x1F2C)
        self.IN_IDX460 = SA_CRC_IN_IDX0(self, 0x1F30)
        self.IN_IDX461 = SA_CRC_IN_IDX0(self, 0x1F34)
        self.IN_IDX462 = SA_CRC_IN_IDX0(self, 0x1F38)
        self.IN_IDX463 = SA_CRC_IN_IDX0(self, 0x1F3C)
        self.IN_IDX464 = SA_CRC_IN_IDX0(self, 0x1F40)
        self.IN_IDX465 = SA_CRC_IN_IDX0(self, 0x1F44)
        self.IN_IDX466 = SA_CRC_IN_IDX0(self, 0x1F48)
        self.IN_IDX467 = SA_CRC_IN_IDX0(self, 0x1F4C)
        self.IN_IDX468 = SA_CRC_IN_IDX0(self, 0x1F50)
        self.IN_IDX469 = SA_CRC_IN_IDX0(self, 0x1F54)
        self.IN_IDX470 = SA_CRC_IN_IDX0(self, 0x1F58)
        self.IN_IDX471 = SA_CRC_IN_IDX0(self, 0x1F5C)
        self.IN_IDX472 = SA_CRC_IN_IDX0(self, 0x1F60)
        self.IN_IDX473 = SA_CRC_IN_IDX0(self, 0x1F64)
        self.IN_IDX474 = SA_CRC_IN_IDX0(self, 0x1F68)
        self.IN_IDX475 = SA_CRC_IN_IDX0(self, 0x1F6C)
        self.IN_IDX476 = SA_CRC_IN_IDX0(self, 0x1F70)
        self.IN_IDX477 = SA_CRC_IN_IDX0(self, 0x1F74)
        self.IN_IDX478 = SA_CRC_IN_IDX0(self, 0x1F78)
        self.IN_IDX479 = SA_CRC_IN_IDX0(self, 0x1F7C)
        self.IN_IDX480 = SA_CRC_IN_IDX0(self, 0x1F80)
        self.IN_IDX481 = SA_CRC_IN_IDX0(self, 0x1F84)
        self.IN_IDX482 = SA_CRC_IN_IDX0(self, 0x1F88)
        self.IN_IDX483 = SA_CRC_IN_IDX0(self, 0x1F8C)
        self.IN_IDX484 = SA_CRC_IN_IDX0(self, 0x1F90)
        self.IN_IDX485 = SA_CRC_IN_IDX0(self, 0x1F94)
        self.IN_IDX486 = SA_CRC_IN_IDX0(self, 0x1F98)
        self.IN_IDX487 = SA_CRC_IN_IDX0(self, 0x1F9C)
        self.IN_IDX488 = SA_CRC_IN_IDX0(self, 0x1FA0)
        self.IN_IDX489 = SA_CRC_IN_IDX0(self, 0x1FA4)
        self.IN_IDX490 = SA_CRC_IN_IDX0(self, 0x1FA8)
        self.IN_IDX491 = SA_CRC_IN_IDX0(self, 0x1FAC)
        self.IN_IDX492 = SA_CRC_IN_IDX0(self, 0x1FB0)
        self.IN_IDX493 = SA_CRC_IN_IDX0(self, 0x1FB4)
        self.IN_IDX494 = SA_CRC_IN_IDX0(self, 0x1FB8)
        self.IN_IDX495 = SA_CRC_IN_IDX0(self, 0x1FBC)
        self.IN_IDX496 = SA_CRC_IN_IDX0(self, 0x1FC0)
        self.IN_IDX497 = SA_CRC_IN_IDX0(self, 0x1FC4)
        self.IN_IDX498 = SA_CRC_IN_IDX0(self, 0x1FC8)
        self.IN_IDX499 = SA_CRC_IN_IDX0(self, 0x1FCC)
        self.IN_IDX500 = SA_CRC_IN_IDX0(self, 0x1FD0)
        self.IN_IDX501 = SA_CRC_IN_IDX0(self, 0x1FD4)
        self.IN_IDX502 = SA_CRC_IN_IDX0(self, 0x1FD8)
        self.IN_IDX503 = SA_CRC_IN_IDX0(self, 0x1FDC)
        self.IN_IDX504 = SA_CRC_IN_IDX0(self, 0x1FE0)
        self.IN_IDX505 = SA_CRC_IN_IDX0(self, 0x1FE4)
        self.IN_IDX506 = SA_CRC_IN_IDX0(self, 0x1FE8)
        self.IN_IDX507 = SA_CRC_IN_IDX0(self, 0x1FEC)
        self.IN_IDX508 = SA_CRC_IN_IDX0(self, 0x1FF0)
        self.IN_IDX509 = SA_CRC_IN_IDX0(self, 0x1FF4)
        self.IN_IDX510 = SA_CRC_IN_IDX0(self, 0x1FF8)
        self.IN_IDX511 = SA_CRC_IN_IDX0(self, 0x1FFC)
        self.IN_IDX = Subscriptor(self, "IN_IDX{}")

CRC = SA_CRC(0x40440000, "CRC")

class SA_WWDT0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power. Note: For safety devices the power cannot be disabled once enabled.")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_WWDT0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear [GPRCM.STAT.RESETSTKY]")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral. Note: For safety devices a watchdog reset by software is not possible.")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_WWDT0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Window Watchdog Timer Status Register")
        self.WWDTSTAT_RUN = BitField(self, 0x00000001, "WWDTSTAT_RUN", "Watchdog running status flag.")

class SA_WWDT0_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")

class SA_WWDT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x0000001F, "STAT", "Module Interrupt Vector Value. This register provides the highest priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC.")

class SA_WWDT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.INTTIM = BitField(self, 0x00000001, "INTTIM", "Interval Timer Interrupt.")

class SA_WWDT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.INTTIM = BitField(self, 0x00000001, "INTTIM", "Interval Timer Interrupt.")

class SA_WWDT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.INTTIM = BitField(self, 0x00000001, "INTTIM", "Interval Timer Interrupt.")

class SA_WWDT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.INTTIM = BitField(self, 0x00000001, "INTTIM", "Interval Timer Interrupt.")

class SA_WWDT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.INTTIM = BitField(self, 0x00000001, "INTTIM", "Interval Timer Interrupt.")

class SA_WWDT0_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")

class SA_WWDT0_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_WWDT0_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x43, "CTL0", "Window Watchdog Timer Control Register 0")
        self.WWDTCTL0_PER = BitField(self, 0x00000070, "WWDTCTL0_PER", "Timer Period of the WWDT. These bits select the total watchdog timer count.")
        self.WWDTCTL0_WINDOW0 = BitField(self, 0x00000700, "WWDTCTL0_WINDOW0", "Closed window period in percentage of the timer interval. WWDTCTL1.WINSEL determines the active window setting (WWDTCTL0.WINDOW0 or WWDTCTL0.WINDOW1).")
        self.WWDTCTL0_MODE = BitField(self, 0x00010000, "WWDTCTL0_MODE", "Window Watchdog Timer Mode")
        self.WWDTCTL0_STISM = BitField(self, 0x00020000, "WWDTCTL0_STISM", "Stop In Sleep Mode. . The functionality of this bit requires that POLICY.HWCEN = 0. If POLICY.HWCEN = 1 the WWDT resets during sleep and needs re-configuration. Note: This bit has no effect for the global Window Watchdog as Sleep Mode is not supported.")
        self.WWDTCTL0_KEY = BitField(self, 0xFF000000, "WWDTCTL0_KEY", "KEY to allow write access to this register. . Writing to this register with an incorrect key activates the WWDT error signal to the ESM. Read as 0.")
        self.WWDTCTL0_CLKDIV = BitField(self, 0x00000007, "WWDTCTL0_CLKDIV", "Module Clock Divider, Divide the clock source by CLKDIV+1.. Divider values from /1 to /8 are possible. The clock divider is currently 4 bits. Bit 4 has no effect and should always be written with 0.")
        self.WWDTCTL0_WINDOW1 = BitField(self, 0x00007000, "WWDTCTL0_WINDOW1", "Closed window period in percentage of the timer interval. WWDTCTL1.WINSEL determines the active window setting (WWDTCTL0.WINDOW0 or WWDTCTL0.WINDOW1).")
        self.WWDTCTL0_WINDOW = Subscriptor(self, "WWDTCTL0_WINDOW{}")

class SA_WWDT0_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL1", "Window Watchdog Timer Control Register 0")
        self.WWDTCTL1_KEY = BitField(self, 0xFF000000, "WWDTCTL1_KEY", "KEY to allow write access to this register. . Writing to this register with an incorrect key activates the WWDT error signal to the ESM. Read as 0.")
        self.WWDTCTL1_WINSEL = BitField(self, 0x00000001, "WWDTCTL1_WINSEL", "Close Window Select")

class SA_WWDT0_CNTRST(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CNTRST", "Window Watchdog Timer Counter Reset Register")
        self.WWDTCNTRST_RESTART = BitField(self, 0xFFFFFFFF, "WWDTCNTRST_RESTART", "Window Watchdog Timer Counter Restart Writing 00A7h to this register restarts the WWDT Counter. . Writing any other value causes an error generation to the ESM. Read as 0.")

class SA_WWDT0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "WWDT")
        self.PWREN = SA_WWDT0_PWREN(self, 0x800)
        self.RSTCTL = SA_WWDT0_RSTCTL(self, 0x804)
        self.STAT = SA_WWDT0_STAT(self, 0x110C)
        self.PDBGCTL = SA_WWDT0_PDBGCTL(self, 0x1018)
        self.IIDX = SA_WWDT0_IIDX(self, 0x1020)
        self.IMASK = SA_WWDT0_IMASK(self, 0x1028)
        self.RIS = SA_WWDT0_RIS(self, 0x1030)
        self.MIS = SA_WWDT0_MIS(self, 0x1038)
        self.ISET = SA_WWDT0_ISET(self, 0x1040)
        self.ICLR = SA_WWDT0_ICLR(self, 0x1048)
        self.EVT_MODE = SA_WWDT0_EVT_MODE(self, 0x10E0)
        self.DESC = SA_WWDT0_DESC(self, 0x10FC)
        self.CTL0 = SA_WWDT0_CTL0(self, 0x1100)
        self.CTL1 = SA_WWDT0_CTL1(self, 0x1104)
        self.CNTRST = SA_WWDT0_CNTRST(self, 0x1108)
        self.CTL = Subscriptor(self, "CTL{}")

WWDT0 = SA_WWDT0(0x40080000, "WWDT0")

class SA_SPI1_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_SPI1_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_SPI1_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_SPI1_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_SPI1_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_SPI1_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.SYSCLK_SEL = BitField(self, 0x00000008, "SYSCLK_SEL", "Selects SYSCLK as clock source if enabled")

class SA_SPI1_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_SPI1_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_SPI1_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.RX = BitField(self, 0x00000008, "RX", "Receive FIFO event.This interrupt is set if the selected Receive FIFO level has been reached")
        self.TX = BitField(self, 0x00000010, "TX", "Transmit FIFO event mask.")
        self.TXEMPTY = BitField(self, 0x00000020, "TXEMPTY", "Transmit FIFO Empty event mask.")
        self.PER = BitField(self, 0x00000002, "PER", "Parity error event mask.")
        self.DMA_DONE_RX = BitField(self, 0x00000080, "DMA_DONE_RX", "DMA Done 1 event for RX event mask.")
        self.RXFIFO_OVF = BitField(self, 0x00000001, "RXFIFO_OVF", "RXFIFO overflow event mask.")
        self.DMA_DONE_TX = BitField(self, 0x00000100, "DMA_DONE_TX", "DMA Done 1 event for TX event mask.")
        self.IDLE = BitField(self, 0x00000040, "IDLE", "SPI Idle event mask.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Enable SPI Receive Time-Out event mask.")
        self.RXFULL = BitField(self, 0x00000400, "RXFULL", "RX FIFO Full Interrupt Mask")
        self.TXFIFO_UNF = BitField(self, 0x00000200, "TXFIFO_UNF", "TX FIFO underflow interrupt mask")

class SA_SPI1_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.RX = BitField(self, 0x00000008, "RX", "Receive FIFO event.This interrupt is set if the selected Receive FIFO level has been reached")
        self.TX = BitField(self, 0x00000010, "TX", "Transmit FIFO event..This interrupt is set if the selected Transmit FIFO level has been reached.")
        self.TXEMPTY = BitField(self, 0x00000020, "TXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been move to the shift register.")
        self.PER = BitField(self, 0x00000002, "PER", "Parity error event: this bit is set if a Parity error has been detected")
        self.DMA_DONE_RX = BitField(self, 0x00000080, "DMA_DONE_RX", "DMA Done 1 event for RX. This interrupt is set if the RX DMA channel sends the DONE signal. This allows the handling of the DMA event inside the mapped peripheral.")
        self.RXFIFO_OVF = BitField(self, 0x00000001, "RXFIFO_OVF", "RXFIFO overflow event. This interrupt is set if an RX FIFO overflow has been detected.")
        self.DMA_DONE_TX = BitField(self, 0x00000100, "DMA_DONE_TX", "DMA Done 1 event for TX. This interrupt is set if the TX DMA channel sends the DONE signal. This allows the handling of the DMA event inside the mapped peripheral.")
        self.IDLE = BitField(self, 0x00000040, "IDLE", "SPI has done finished transfers and changed into IDLE mode. This bit is set when BUSY goes low.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "SPI Receive Time-Out event.")
        self.TXFIFO_UNF = BitField(self, 0x00000200, "TXFIFO_UNF", "TX FIFO Underflow Interrupt")
        self.RXFULL = BitField(self, 0x00000400, "RXFULL", "RX FIFO Full Interrupt")

class SA_SPI1_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.RX = BitField(self, 0x00000008, "RX", "Masked receive FIFO event.This interrupt is set if the selected Receive FIFO level has been reached")
        self.TX = BitField(self, 0x00000010, "TX", "Masked Transmit FIFO event. This interrupt is set if the selected Transmit FIFO level has been reached.")
        self.TXEMPTY = BitField(self, 0x00000020, "TXEMPTY", "Masked Transmit FIFO Empty event.")
        self.PER = BitField(self, 0x00000002, "PER", "Masked Parity error event: this bit if a Parity error has been detected")
        self.DMA_DONE_RX = BitField(self, 0x00000080, "DMA_DONE_RX", "Masked DMA Done 1 event for RX.")
        self.RXFIFO_OVF = BitField(self, 0x00000001, "RXFIFO_OVF", "Masked RXFIFO overflow event. This interrupt is set if an RX FIFO overflow has been detected.")
        self.DMA_DONE_TX = BitField(self, 0x00000100, "DMA_DONE_TX", "Masked DMA Done 1 event for TX.")
        self.IDLE = BitField(self, 0x00000040, "IDLE", "Masked SPI IDLE mode event.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Masked SPI Receive Time-Out Interrupt.")
        self.RXFULL = BitField(self, 0x00000400, "RXFULL", "RX FIFO Full Interrupt")
        self.TXFIFO_UNF = BitField(self, 0x00000200, "TXFIFO_UNF", "TX FIFO underflow interrupt")

class SA_SPI1_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.RX = BitField(self, 0x00000008, "RX", "Set Receive FIFO event.")
        self.TX = BitField(self, 0x00000010, "TX", "Set Transmit FIFO event.")
        self.TXEMPTY = BitField(self, 0x00000020, "TXEMPTY", "Set Transmit FIFO Empty event.")
        self.PER = BitField(self, 0x00000002, "PER", "Set Parity error event.")
        self.DMA_DONE_RX = BitField(self, 0x00000080, "DMA_DONE_RX", "Set DMA Done 1 event for RX.")
        self.RXFIFO_OVF = BitField(self, 0x00000001, "RXFIFO_OVF", "Set RXFIFO overflow event.")
        self.DMA_DONE_TX = BitField(self, 0x00000100, "DMA_DONE_TX", "Set DMA Done 1 event for TX.")
        self.IDLE = BitField(self, 0x00000040, "IDLE", "Set SPI IDLE mode event.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Set SPI Receive Time-Out Event.")
        self.TXFIFO_UNF = BitField(self, 0x00000200, "TXFIFO_UNF", "Set TX FIFO Underflow Event")
        self.RXFULL = BitField(self, 0x00000400, "RXFULL", "Set RX FIFO Full Event")

class SA_SPI1_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.RX = BitField(self, 0x00000008, "RX", "Clear Receive FIFO event.")
        self.TX = BitField(self, 0x00000010, "TX", "Clear Transmit FIFO event.")
        self.TXEMPTY = BitField(self, 0x00000020, "TXEMPTY", "Clear Transmit FIFO Empty event.")
        self.PER = BitField(self, 0x00000002, "PER", "Clear Parity error event.")
        self.DMA_DONE_RX = BitField(self, 0x00000080, "DMA_DONE_RX", "Clear DMA Done 1 event for RX.")
        self.RXFIFO_OVF = BitField(self, 0x00000001, "RXFIFO_OVF", "Clear RXFIFO overflow event.")
        self.DMA_DONE_TX = BitField(self, 0x00000100, "DMA_DONE_TX", "Clear DMA Done 1 event for TX.")
        self.IDLE = BitField(self, 0x00000040, "IDLE", "Clear SPI IDLE mode event.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Clear SPI Receive Time-Out Event.")
        self.TXFIFO_UNF = BitField(self, 0x00000200, "TXFIFO_UNF", "Clear TXFIFO underflow event")
        self.RXFULL = BitField(self, 0x00000400, "RXFULL", "Clear RX FIFO underflow event")

class SA_SPI1_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_SPI1_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.RX = BitField(self, 0x00000008, "RX", "Receive FIFO event mask.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "SPI Receive Time-Out event mask.")

class SA_SPI1_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.RX = BitField(self, 0x00000008, "RX", "Receive FIFO event.This interrupt is set if the selected Receive FIFO level has been reached")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "SPI Receive Time-Out Event.")

class SA_SPI1_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.RX = BitField(self, 0x00000008, "RX", "Receive FIFO event mask.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "SPI Receive Time-Out event mask.")

class SA_SPI1_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.RX = BitField(self, 0x00000008, "RX", "Set Receive FIFO event.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Set SPI Receive Time-Out event.")

class SA_SPI1_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.RX = BitField(self, 0x00000008, "RX", "Clear Receive FIFO event.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Clear SPI Receive Time-Out event.")

class SA_SPI1_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_SPI1_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.TX = BitField(self, 0x00000010, "TX", "Transmit FIFO event mask.")

class SA_SPI1_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.TX = BitField(self, 0x00000010, "TX", "Transmit FIFO event:. A read returns the current mask for transmit FIFO interrupt. On a write of 1, the mask for transmit FIFO interrupt is set which means the interrupt state will be reflected in MIS.TXMIS. A write of 0 clears the mask which means MIS.TXMIS will not reflect the interrupt.")

class SA_SPI1_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.TX = BitField(self, 0x00000010, "TX", "Masked Transmit FIFO event")

class SA_SPI1_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.TX = BitField(self, 0x00000010, "TX", "Set Transmit FIFO event.")

class SA_SPI1_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.TX = BitField(self, 0x00000010, "TX", "Clear Transmit FIFO event.")

class SA_SPI1_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.INT1_CFG = BitField(self, 0x0000000C, "INT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.INT2_CFG = BitField(self, 0x00000030, "INT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.INT_CFG = Subscriptor(self, "INT{}_CFG")

class SA_SPI1_INTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INTCTL", "Interrupt control register")
        self.INTEVAL = BitField(self, 0x00000001, "INTEVAL", "Writing a 1 to this field re-evaluates the interrupt sources.")

class SA_SPI1_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL0", "SPI control register 0")
        self.DSS = BitField(self, 0x0000001F, "DSS", "Data Size Select.. Values 0 - 2 are reserved and shall not be used. 3h = 4_BIT : 4-bit data SPI allows only values up to 16 Bit")
        self.FRF = BitField(self, 0x00000060, "FRF", "Frame format Select")
        self.SPO = BitField(self, 0x00000100, "SPO", "CLKOUT polarity (Motorola SPI frame format only)")
        self.SPH = BitField(self, 0x00000200, "SPH", "CLKOUT phase (Motorola SPI frame format only). This bit selects the clock edge that captures data and enables it to change state. It has the most impact on the first bit transmitted by either permitting or not permitting a clock transition before the first data capture edge.")
        self.CSSEL = BitField(self, 0x00003000, "CSSEL", "Select the CS line to control on data transfer. This bit is for controller mode only.")
        self.CSCLR = BitField(self, 0x00004000, "CSCLR", "Clear shift register counter on CS inactive. This bit is relevant only in the peripheral, CTL1.MS=0.")
        self.PACKEN = BitField(self, 0x00000080, "PACKEN", "Packing Enable.. When 1, packing feature is enabled inside the IP When 0, packing feature is disabled inside the IP")

class SA_SPI1_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x4, "CTL1", "SPI control register 1")
        self.LBM = BitField(self, 0x00000002, "LBM", "Loop back mode")
        self.MS = BitField(self, 0x00000004, "MS", "Controller or peripheral mode select. This bit can be modified only when SPI is disabled, CTL1.ENABLE=0.")
        self.SOD = BitField(self, 0x00000008, "SOD", "Peripheral-mode: Data output disabled. This bit is relevant only in the peripheral mode, CTL1.MS=1. In multiple-peripheral systems, it is possible for an SPI controller to broadcast a message to all peripherals in the system while ensuring that only one peripheral drives data onto its serial output line. In such systems the MISO lines from multiple peripherals could be tied together. To operate in such systems, this bitfield can be set if the SPI peripheral is not supposed to drive the MISO line:")
        self.MSB = BitField(self, 0x00000010, "MSB", "MSB first select. Controls the direction of the receive and transmit shift register.")
        self.PREN = BitField(self, 0x00000020, "PREN", "Parity receive enable. If enabled, parity reception check will be done for both controller and peripheral modes In case of a parity miss-match the parity error flag RIS.PER will be set.")
        self.REPEATTX = BitField(self, 0x00FF0000, "REPEATTX", "Counter to repeat last transfer. 0: repeat last transfer is disabled. x: repeat the last transfer with the given number. The transfer will be started with writing a data into the TX Buffer. Sending the data will be repeated with the given value, so the data will be transferred X+1 times in total. The behavior is identical as if the data would be written into the TX Buffer that many times as defined by the value here. It can be used to clean a transfer or to pull a certain amount of data by a peripheral.")
        self.PES = BitField(self, 0x00000040, "PES", "Even Parity Select")
        self.PBS = BitField(self, 0x00000080, "PBS", "Parity Bit Select")
        self.CDMODE = BitField(self, 0x0000F000, "CDMODE", "Command/Data Mode Value. When CTL1.CDENABLE is 1, CS3 line is used as C/D signal to distinguish between Command (C/D low) and Data (C/D high) information. When a value is written into the CTL1.CDMODE bits, the C/D (CS3) line will go low for the given numbers of byte which are sent by the SPI, starting with the next value to be transmitted after which, C/D line will go high automatically 0: Manual mode with C/D signal as High 1-14: C/D is low while this number of bytes are being sent after which, this field sets to 0 and C/D goes high. Reading this field at any time returns the remaining number of command bytes. 15: Manual mode with C/D signal as Low.")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "SPI enable")
        self.RXTIMEOUT = BitField(self, 0x3F000000, "RXTIMEOUT", "Receive Timeout (only for Peripheral mode). Defines the number of Clock Cycles before after which the Receive Timeout flag RTOUT is set. The time is calculated using the control register for the clock selection and divider in the Controller mode configuration. A value of 0 disables this function.")
        self.CDENABLE = BitField(self, 0x00000800, "CDENABLE", "Command/Data Mode enable")
        self.PTEN = BitField(self, 0x00000100, "PTEN", "Parity transmit enable. If enabled, parity transmission will be done for both controller and peripheral modes.")

class SA_SPI1_CLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCTL", "Clock prescaler and divider register.")
        self.SCR = BitField(self, 0x000003FF, "SCR", "Serial clock divider:. This is used to generate the transmit and receive bit rate of the SPI. The SPI bit rate is (SPI's functional clock frequency)/((SCR+1)*2). SCR is a value from 0-1023.")
        self.DSAMPLE = BitField(self, 0xF0000000, "DSAMPLE", "Delayed sampling value. . In controller mode the data on the input pin will be delayed sampled by the defined clock cycles of internal functional clock hence relaxing the setup time of input data. This setting is useful in systems where the board delays and external peripheral delays are more than the input setup time of the controller. Please refer to the datasheet for values of controller input setup time and assess what DSAMPLE value meets the requirement of the system. Note: High values of DSAMPLE can cause HOLD time violations and must be factored in the calculations.")

class SA_SPI1_IFLS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x12, "IFLS", "UART Interrupt FIFO Level Select Register")
        self.TXIFLSEL = BitField(self, 0x00000007, "TXIFLSEL", "SPI Transmit Interrupt FIFO Level Select The trigger points for the transmit interrupt are as follows:")
        self.RXIFLSEL = BitField(self, 0x00000038, "RXIFLSEL", "SPI Receive Interrupt FIFO Level Select The trigger points for the receive interrupt are as follows:")

class SA_SPI1_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.TFE = BitField(self, 0x00000001, "TFE", "Transmit FIFO empty.")
        self.TNF = BitField(self, 0x00000002, "TNF", "Transmit FIFO not full")
        self.RFE = BitField(self, 0x00000004, "RFE", "Receive FIFO empty.")
        self.RNF = BitField(self, 0x00000008, "RNF", "Receive FIFO not full")
        self.BUSY = BitField(self, 0x00000010, "BUSY", "Busy")

class SA_SPI1_RXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RXDATA", "RXDATA Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "Received Data. When PACKEN=1,two entries of the FIFO are returned as a 32-bit value. When PACKEN=0, 1 entry of FIFO is returned as 16-bit value. As data values are removed by the receive logic from the incoming data frame, they are placed into the entry in the receive FIFO, pointed to by the current FIFO write pointer. Received data less than 16 bits is automatically right justified in the receive buffer.")

class SA_SPI1_TXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TXDATA", "TXDATA Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "Transmit Data. WWhen read, last written value will be returned. If the last write to this field was a 32-bit write (with PACKEN=1), 32-bits will be returned and if the last write was a 16-bit write (PACKEN=0), those 16-bits will be returned. When written, one or two FIFO entries will be written depending on PACKEN value. Data values are removed from the transmit FIFO one value at a time by the transmit logic. It is loaded into the transmit serial shifter, then serially shifted out onto the TXD output pin at the programmed bit rate. When a data size of less than 16 bits is selected, the user must right-justify data written to the transmit FIFO. The transmit logic ignores the unused bits.")

class SA_SPI1(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_SPI1_PWREN(self, 0x800)
        self.RSTCTL = SA_SPI1_RSTCTL(self, 0x804)
        self.CLKCFG = SA_SPI1_CLKCFG(self, 0x808)
        self.GPRCM_STAT = SA_SPI1_GPRCM_STAT(self, 0x814)
        self.CLKDIV = SA_SPI1_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_SPI1_CLKSEL(self, 0x1004)
        self.PDBGCTL = SA_SPI1_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_SPI1_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_SPI1_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_SPI1_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_SPI1_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_SPI1_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_SPI1_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_SPI1_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_SPI1_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_SPI1_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_SPI1_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_SPI1_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_SPI1_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_SPI1_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_SPI1_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_SPI1_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_SPI1_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_SPI1_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_SPI1_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_SPI1_EVT_MODE(self, 0x10E0)
        self.INTCTL = SA_SPI1_INTCTL(self, 0x10E4)
        self.CTL0 = SA_SPI1_CTL0(self, 0x1100)
        self.CTL1 = SA_SPI1_CTL1(self, 0x1104)
        self.CLKCTL = SA_SPI1_CLKCTL(self, 0x1108)
        self.IFLS = SA_SPI1_IFLS(self, 0x110C)
        self.STAT = SA_SPI1_STAT(self, 0x1110)
        self.RXDATA = SA_SPI1_RXDATA(self, 0x1130)
        self.TXDATA = SA_SPI1_TXDATA(self, 0x1140)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.CTL = Subscriptor(self, "CTL{}")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

SPI1 = SA_SPI1(0x4046A000, "SPI1")

class SA_DAC0_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subscriber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. others = connected to channel_ID = CHANID.")

class SA_DAC0_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. others = connected to channel_ID = CHANID.")

class SA_DAC0_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. others = connected to channel_ID = CHANID.")

class SA_DAC0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_DAC0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_DAC0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_DAC0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x0000000F, "STAT", "Interrupt index status")

class SA_DAC0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.MODRDYIFG = BitField(self, 0x00000002, "MODRDYIFG", "Masks MODRDYIFG")
        self.FIFO1B2IFG = BitField(self, 0x00000400, "FIFO1B2IFG", "Masks FIFO1B2IFG")
        self.FIFOEMPTYIFG = BitField(self, 0x00001000, "FIFOEMPTYIFG", "Masks FIFOEMPTYIFG")
        self.FIFO1B4IFG = BitField(self, 0x00000200, "FIFO1B4IFG", "Masks FIFO1B4IFG")
        self.FIFO3B4IFG = BitField(self, 0x00000800, "FIFO3B4IFG", "Masks FIFO3B4IFG")
        self.FIFOFULLIFG = BitField(self, 0x00000100, "FIFOFULLIFG", "Masks FIFOFULLIFG")
        self.FIFOURUNIFG = BitField(self, 0x00002000, "FIFOURUNIFG", "Masks FIFOURUNIFG")
        self.DMADONEIFG = BitField(self, 0x00004000, "DMADONEIFG", "Masks DMADONEIFG")

class SA_DAC0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x1E00, "RIS", "Raw interrupt status")
        self.MODRDYIFG = BitField(self, 0x00000002, "MODRDYIFG", "Raw interrupt status for MODRDYIFG")
        self.FIFOEMPTYIFG = BitField(self, 0x00001000, "FIFOEMPTYIFG", "Raw interrupt status for FIFOEMPTYIFG")
        self.FIFO1B4IFG = BitField(self, 0x00000200, "FIFO1B4IFG", "Raw interrupt status for FIFO1B4IFG")
        self.FIFO1B2IFG = BitField(self, 0x00000400, "FIFO1B2IFG", "Raw interrupt status for FIFO1B2IFG")
        self.FIFO3B4IFG = BitField(self, 0x00000800, "FIFO3B4IFG", "Raw interrupt status for FIFO3B4IFG")
        self.FIFOFULLIFG = BitField(self, 0x00000100, "FIFOFULLIFG", "Raw interrupt status for FIFOFULLIFG")
        self.FIFOURUNIFG = BitField(self, 0x00002000, "FIFOURUNIFG", "Raw interrupt status for FIFOURUNIFG")
        self.DMADONEIFG = BitField(self, 0x00004000, "DMADONEIFG", "Raw interrupt status for DMADONEIFG")

class SA_DAC0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.MODRDYIFG = BitField(self, 0x00000002, "MODRDYIFG", "Masked interrupt status for MODRDYIFG")
        self.FIFOEMPTYIFG = BitField(self, 0x00001000, "FIFOEMPTYIFG", "Masked interrupt status for FIFOEMPTYIFG")
        self.FIFO1B4IFG = BitField(self, 0x00000200, "FIFO1B4IFG", "Masked interrupt status for FIFO1B4IFG")
        self.FIFO1B2IFG = BitField(self, 0x00000400, "FIFO1B2IFG", "Masked interrupt status for FIFO1B2IFG")
        self.FIFO3B4IFG = BitField(self, 0x00000800, "FIFO3B4IFG", "Masked interrupt status for FIFO3B4IFG")
        self.FIFOFULLIFG = BitField(self, 0x00000100, "FIFOFULLIFG", "Masked interrupt status for FIFOFULLIFG")
        self.FIFOURUNIFG = BitField(self, 0x00002000, "FIFOURUNIFG", "Masked interrupt status for FIFOURUNIFG")
        self.DMADONEIFG = BitField(self, 0x00004000, "DMADONEIFG", "Masked interrupt status for DMADONEIFG")

class SA_DAC0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.MODRDYIFG = BitField(self, 0x00000002, "MODRDYIFG", "Sets MODRDYIFG in RIS register")
        self.FIFOEMPTYIFG = BitField(self, 0x00001000, "FIFOEMPTYIFG", "Sets FIFOEMPTYIFG in RIS register")
        self.FIFO1B4IFG = BitField(self, 0x00000200, "FIFO1B4IFG", "Sets FIFO1B4IFG in RIS register")
        self.FIFO1B2IFG = BitField(self, 0x00000400, "FIFO1B2IFG", "Sets FIFO1B2IFG in RIS register")
        self.FIFO3B4IFG = BitField(self, 0x00000800, "FIFO3B4IFG", "Sets FIFO3B4IFG in RIS register")
        self.FIFOFULLIFG = BitField(self, 0x00000100, "FIFOFULLIFG", "Sets FIFOFULLIFG in RIS register")
        self.FIFOURUNIFG = BitField(self, 0x00002000, "FIFOURUNIFG", "Sets FIFOURUNIFG in RIS register")
        self.DMADONEIFG = BitField(self, 0x00004000, "DMADONEIFG", "Sets DMADONEIFG in RIS register")

class SA_DAC0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.MODRDYIFG = BitField(self, 0x00000002, "MODRDYIFG", "Clears MODRDYIFG in RIS register")
        self.FIFOEMPTYIFG = BitField(self, 0x00001000, "FIFOEMPTYIFG", "Clears FIFOEMPTYIFG in RIS register")
        self.FIFO1B4IFG = BitField(self, 0x00000200, "FIFO1B4IFG", "Clears FIFO1B4IFG in RIS register")
        self.FIFO1B2IFG = BitField(self, 0x00000400, "FIFO1B2IFG", "Clears FIFO1B2IFG in RIS register")
        self.FIFO3B4IFG = BitField(self, 0x00000800, "FIFO3B4IFG", "Clears FIFO3B4IFG in RIS register")
        self.FIFOFULLIFG = BitField(self, 0x00000100, "FIFOFULLIFG", "Clears FIFOFULLIFG in RIS register")
        self.FIFOURUNIFG = BitField(self, 0x00002000, "FIFOURUNIFG", "Clears FIFOURUNIFG in RIS register")
        self.DMADONEIFG = BitField(self, 0x00004000, "DMADONEIFG", "Clears DMADONEIFG in RIS register")

class SA_DAC0_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x9, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")

class SA_DAC0_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_DAC0_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL0", "Control 0")
        self.DFM = BitField(self, 0x00010000, "DFM", "This bit defines the DAC input data format.")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "This bit enables the DAC module.")
        self.RES = BitField(self, 0x00000100, "RES", "These bits define the DAC output voltage resolution.")

class SA_DAC0_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL1", "Control 1")
        self.AMPEN = BitField(self, 0x00000001, "AMPEN", "AMP_EN - output amplifier enabled or disabled. 0 : disabled 1 : enabled")
        self.REFSP = BitField(self, 0x00000100, "REFSP", "This bit selects the DAC voltage reference source + input.")
        self.OPS = BitField(self, 0x01000000, "OPS", "These bits select the DAC output on device pin.")
        self.REFSN = BitField(self, 0x00000200, "REFSN", "This bit selects the DAC voltage reference source + input.")
        self.AMPHIZ = BitField(self, 0x00000002, "AMPHIZ", "AMPHIZ - amplifier output value. 0 : amplifier output is high impedance 1 : amplifier output is pulled down to ground")

class SA_DAC0_CTL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL2", "Control 2")
        self.FIFOEN = BitField(self, 0x00000001, "FIFOEN", "This bit enables the FIFO and the FIFO hardware control state machine.")
        self.FIFOTH = BitField(self, 0x00000300, "FIFOTH", "These bits determine the FIFO threshold. In case of DMA based operation, DAC generates new DMA trigger when the number of empty locations in FIFO match the selected FIFO threshold level. . In case of CPU based operation, the FIFO threshold bits are don't care and FIFO level is directly indicated through the respective bits in the RIS register.")
        self.FIFOTRIGSEL = BitField(self, 0x00030000, "FIFOTRIGSEL", "These bits select the source for FIFO read trigger. When the selected FIFO read trigger is asserted, the data from FIFO (as indicated by read pointer) is moved into internal DAC data register.")
        self.DMATRIGEN = BitField(self, 0x01000000, "DMATRIGEN", "This bit enables the DMA trigger generation mechanism. When this bit is set along with FIFOEN, the DMA trigger is generated based on the empty FIFO locations qualified by FIFOTH settings. This bit needs to be cleared by SW to stop further DMA triggers")

class SA_DAC0_CTL3(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL3", "Control 3")
        self.STIMEN = BitField(self, 0x00000001, "STIMEN", "This bit enables the sample time generator.")
        self.STIMCONFIG = BitField(self, 0x00000F00, "STIMCONFIG", "These bits are used to configure the trigger rate from the sample time generator.. The STIMCONFIG values 10 to 15 are reserved and default to same effect as value 0 (500SPS).")

class SA_DAC0_CALCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CALCTL", "Calibration control")
        self.CALON = BitField(self, 0x00000001, "CALON", "This bit when set initiates the DAC offset error calibration sequence and is automatically reset when the offset error calibration completes.")
        self.CALSEL = BitField(self, 0x00000002, "CALSEL", "This bit is used to select between factory trim or self calibration trim.")

class SA_DAC0_CALDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CALDATA", "Calibration data")
        self.DATA = BitField(self, 0x0000007F, "DATA", "DAC offset error calibration data. The DAC offset error calibration data is represented in twos complement format providing a range of 64 to +63.. This is read-only bit, reflecting the calibration data. Writing to this register will have no effect, it will not change the calibration value.")

class SA_DAC0_DATA0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DATA0", "Data 0")
        self.DATA_VALUE = BitField(self, 0x00000FFF, "DATA_VALUE", "This is the data written for digital to analog conversion.")

class SA_DAC0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_DAC0_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_DAC0_FSUB_1(self, 0x404)
        self.FPUB_1 = SA_DAC0_FPUB_1(self, 0x444)
        self.PWREN = SA_DAC0_PWREN(self, 0x800)
        self.RSTCTL = SA_DAC0_RSTCTL(self, 0x804)
        self.STAT = SA_DAC0_STAT(self, 0x814)
        self.IIDX = SA_DAC0_IIDX(self, 0x1020)
        self.IMASK = SA_DAC0_IMASK(self, 0x1028)
        self.RIS = SA_DAC0_RIS(self, 0x1030)
        self.MIS = SA_DAC0_MIS(self, 0x1038)
        self.ISET = SA_DAC0_ISET(self, 0x1040)
        self.ICLR = SA_DAC0_ICLR(self, 0x1048)
        self.EVT_MODE = SA_DAC0_EVT_MODE(self, 0x10E0)
        self.DESC = SA_DAC0_DESC(self, 0x10FC)
        self.CTL0 = SA_DAC0_CTL0(self, 0x1100)
        self.CTL1 = SA_DAC0_CTL1(self, 0x1110)
        self.CTL2 = SA_DAC0_CTL2(self, 0x1120)
        self.CTL3 = SA_DAC0_CTL3(self, 0x1130)
        self.CALCTL = SA_DAC0_CALCTL(self, 0x1140)
        self.CALDATA = SA_DAC0_CALDATA(self, 0x1160)
        self.DATA0 = SA_DAC0_DATA0(self, 0x1200)
        self.CTL = Subscriptor(self, "CTL{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")

DAC0 = SA_DAC0(0x40018000, "DAC0")

class SA_I2C1_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_I2C1_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_I2C1_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_I2C1_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_I2C1_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_I2C1_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUSCLK as clock source if enabled")

class SA_I2C1_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_I2C1_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "I2C Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC. 15h-1Fh = Reserved")

class SA_I2C1_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.MRXDONE = BitField(self, 0x00000001, "MRXDONE", "Master Receive Transaction completed Interrupt")
        self.TIMEOUTA = BitField(self, 0x00004000, "TIMEOUTA", "Timeout A Interrupt")
        self.MNACK = BitField(self, 0x00000080, "MNACK", "Address/Data NACK Interrupt")
        self.MSTART = BitField(self, 0x00000100, "MSTART", "START Detection Interrupt")
        self.MSTOP = BitField(self, 0x00000200, "MSTOP", "STOP Detection Interrupt")
        self.MARBLOST = BitField(self, 0x00000400, "MARBLOST", "Arbitration Lost Interrupt")
        self.MTXDONE = BitField(self, 0x00000002, "MTXDONE", "Master Transmit Transaction completed Interrupt")
        self.MRXFIFOFULL = BitField(self, 0x00000010, "MRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.MTXEMPTY = BitField(self, 0x00000020, "MTXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.MRXFIFOTRG = BitField(self, 0x00000004, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000008, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.MDMA_DONE1_2 = BitField(self, 0x00000800, "MDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.MDMA_DONE1_3 = BitField(self, 0x00001000, "MDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.SRXDONE = BitField(self, 0x00010000, "SRXDONE", "Slave Receive Data Interrupt. Signals that a byte has been received")
        self.STXDONE = BitField(self, 0x00020000, "STXDONE", "Slave Transmit Transaction completed Interrupt")
        self.SGENCALL = BitField(self, 0x01000000, "SGENCALL", "General Call Interrupt")
        self.STXEMPTY = BitField(self, 0x00200000, "STXEMPTY", "Slave Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.SRXFIFOFULL = BitField(self, 0x00100000, "SRXFIFOFULL", "RXFIFO full event. This interrupt is set if an Slave RX FIFO is full.")
        self.SRXFIFOTRG = BitField(self, 0x00040000, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00080000, "STXFIFOTRG", "Slave Transmit FIFO Trigger")
        self.SSTART = BitField(self, 0x00400000, "SSTART", "Start Condition Interrupt")
        self.SSTOP = BitField(self, 0x00800000, "SSTOP", "Stop Condition Interrupt")
        self.SDMA_DONE1_2 = BitField(self, 0x02000000, "SDMA_DONE1_2", "Slave DMA Done 1 on Event Channel 2")
        self.SDMA_DONE1_3 = BitField(self, 0x04000000, "SDMA_DONE1_3", "Slave DMA Done 1 on Event Channel 3")
        self.MPEC_RX_ERR = BitField(self, 0x00002000, "MPEC_RX_ERR", "Master RX Pec Error Interrupt")
        self.TIMEOUTB = BitField(self, 0x00008000, "TIMEOUTB", "Timeout B Interrupt")
        self.SPEC_RX_ERR = BitField(self, 0x08000000, "SPEC_RX_ERR", "Slave RX Pec Error Interrupt")
        self.STX_UNFL = BitField(self, 0x10000000, "STX_UNFL", "Slave TX FIFO underflow")
        self.SRX_OVFL = BitField(self, 0x20000000, "SRX_OVFL", "Slave RX FIFO overflow")
        self.SARBLOST = BitField(self, 0x40000000, "SARBLOST", "Slave Arbitration Lost")
        self.INTR_OVFL = BitField(self, 0x80000000, "INTR_OVFL", "Interrupt Overflow Interrupt Mask")
        self.SDMA_DONE1 = Subscriptor(self, "SDMA_DONE1_{}")
        self.MDMA_DONE1 = Subscriptor(self, "MDMA_DONE1_{}")

class SA_I2C1_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.MRXDONE = BitField(self, 0x00000001, "MRXDONE", "Master Receive Transaction completed Interrupt")
        self.TIMEOUTA = BitField(self, 0x00004000, "TIMEOUTA", "Timeout A Interrupt")
        self.MNACK = BitField(self, 0x00000080, "MNACK", "Address/Data NACK Interrupt")
        self.MSTART = BitField(self, 0x00000100, "MSTART", "START Detection Interrupt")
        self.MSTOP = BitField(self, 0x00000200, "MSTOP", "STOP Detection Interrupt")
        self.MARBLOST = BitField(self, 0x00000400, "MARBLOST", "Arbitration Lost Interrupt")
        self.MTXDONE = BitField(self, 0x00000002, "MTXDONE", "Master Transmit Transaction completed Interrupt")
        self.MRXFIFOFULL = BitField(self, 0x00000010, "MRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.MTXEMPTY = BitField(self, 0x00000020, "MTXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.MRXFIFOTRG = BitField(self, 0x00000004, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000008, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.MDMA_DONE1_2 = BitField(self, 0x00000800, "MDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.MDMA_DONE1_3 = BitField(self, 0x00001000, "MDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.SRXDONE = BitField(self, 0x00010000, "SRXDONE", "Slave Receive Data Interrupt. Signals that a byte has been received")
        self.STXDONE = BitField(self, 0x00020000, "STXDONE", "Slave Transmit Transaction completed Interrupt")
        self.SGENCALL = BitField(self, 0x01000000, "SGENCALL", "General Call Interrupt")
        self.STXEMPTY = BitField(self, 0x00200000, "STXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.SRXFIFOFULL = BitField(self, 0x00100000, "SRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.SRXFIFOTRG = BitField(self, 0x00040000, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00080000, "STXFIFOTRG", "Slave Transmit FIFO Trigger")
        self.SSTART = BitField(self, 0x00400000, "SSTART", "Start Condition Interrupt")
        self.SSTOP = BitField(self, 0x00800000, "SSTOP", "Stop Condition Interrupt")
        self.SDMA_DONE1_2 = BitField(self, 0x02000000, "SDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.SDMA_DONE1_3 = BitField(self, 0x04000000, "SDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.MPEC_RX_ERR = BitField(self, 0x00002000, "MPEC_RX_ERR", "Master RX Pec Error Interrupt")
        self.TIMEOUTB = BitField(self, 0x00008000, "TIMEOUTB", "Timeout B Interrupt")
        self.SPEC_RX_ERR = BitField(self, 0x08000000, "SPEC_RX_ERR", "Slave RX Pec Error Interrupt")
        self.STX_UNFL = BitField(self, 0x10000000, "STX_UNFL", "Slave TX FIFO underflow")
        self.SRX_OVFL = BitField(self, 0x20000000, "SRX_OVFL", "Slave RX FIFO overflow")
        self.SARBLOST = BitField(self, 0x40000000, "SARBLOST", "Slave Arbitration Lost")
        self.INTR_OVFL = BitField(self, 0x80000000, "INTR_OVFL", "Interrupt overflow interrupt. It is set when SSTART or SSTOP interrupts overflow i.e. occur twice without being serviced")
        self.SDMA_DONE1 = Subscriptor(self, "SDMA_DONE1_{}")
        self.MDMA_DONE1 = Subscriptor(self, "MDMA_DONE1_{}")

class SA_I2C1_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.MRXDONE = BitField(self, 0x00000001, "MRXDONE", "Master Receive Data Interrupt")
        self.TIMEOUTA = BitField(self, 0x00004000, "TIMEOUTA", "Timeout A Interrupt")
        self.MNACK = BitField(self, 0x00000080, "MNACK", "Address/Data NACK Interrupt")
        self.MSTART = BitField(self, 0x00000100, "MSTART", "START Detection Interrupt")
        self.MSTOP = BitField(self, 0x00000200, "MSTOP", "STOP Detection Interrupt")
        self.MARBLOST = BitField(self, 0x00000400, "MARBLOST", "Arbitration Lost Interrupt")
        self.MTXDONE = BitField(self, 0x00000002, "MTXDONE", "Master Transmit Transaction completed Interrupt")
        self.MRXFIFOFULL = BitField(self, 0x00000010, "MRXFIFOFULL", "RXFIFO full event. This interrupt is set if the RX FIFO is full.")
        self.MTXEMPTY = BitField(self, 0x00000020, "MTXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.MRXFIFOTRG = BitField(self, 0x00000004, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000008, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.MDMA_DONE1_2 = BitField(self, 0x00000800, "MDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.MDMA_DONE1_3 = BitField(self, 0x00001000, "MDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.SRXDONE = BitField(self, 0x00010000, "SRXDONE", "Slave Receive Data Interrupt. Signals that a byte has been received")
        self.STXDONE = BitField(self, 0x00020000, "STXDONE", "Slave Transmit Transaction completed Interrupt")
        self.SGENCALL = BitField(self, 0x01000000, "SGENCALL", "General Call Interrupt")
        self.STXEMPTY = BitField(self, 0x00200000, "STXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.SRXFIFOFULL = BitField(self, 0x00100000, "SRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.SRXFIFOTRG = BitField(self, 0x00040000, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00080000, "STXFIFOTRG", "Slave Transmit FIFO Trigger")
        self.SSTART = BitField(self, 0x00400000, "SSTART", "Slave START Detection Interrupt")
        self.SSTOP = BitField(self, 0x00800000, "SSTOP", "Slave STOP Detection Interrupt")
        self.SDMA_DONE1_2 = BitField(self, 0x02000000, "SDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.SDMA_DONE1_3 = BitField(self, 0x04000000, "SDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.MPEC_RX_ERR = BitField(self, 0x00002000, "MPEC_RX_ERR", "Master RX Pec Error Interrupt")
        self.TIMEOUTB = BitField(self, 0x00008000, "TIMEOUTB", "Timeout B Interrupt")
        self.SPEC_RX_ERR = BitField(self, 0x08000000, "SPEC_RX_ERR", "Slave RX Pec Error Interrupt")
        self.STX_UNFL = BitField(self, 0x10000000, "STX_UNFL", "Slave TX FIFO underflow")
        self.SRX_OVFL = BitField(self, 0x20000000, "SRX_OVFL", "Slave RX FIFO overflow")
        self.SARBLOST = BitField(self, 0x40000000, "SARBLOST", "Slave Arbitration Lost")
        self.INTR_OVFL = BitField(self, 0x80000000, "INTR_OVFL", "Interrupt overflow")
        self.SDMA_DONE1 = Subscriptor(self, "SDMA_DONE1_{}")
        self.MDMA_DONE1 = Subscriptor(self, "MDMA_DONE1_{}")

class SA_I2C1_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.MRXDONE = BitField(self, 0x00000001, "MRXDONE", "Master Receive Data Interrupt. Signals that a byte has been received")
        self.TIMEOUTA = BitField(self, 0x00004000, "TIMEOUTA", "Timeout A interrupt")
        self.MNACK = BitField(self, 0x00000080, "MNACK", "Address/Data NACK Interrupt")
        self.MSTART = BitField(self, 0x00000100, "MSTART", "START Detection Interrupt")
        self.MSTOP = BitField(self, 0x00000200, "MSTOP", "STOP Detection Interrupt")
        self.MARBLOST = BitField(self, 0x00000400, "MARBLOST", "Arbitration Lost Interrupt")
        self.MTXDONE = BitField(self, 0x00000002, "MTXDONE", "Master Transmit Transaction completed Interrupt")
        self.MRXFIFOFULL = BitField(self, 0x00000010, "MRXFIFOFULL", "RXFIFO full event.")
        self.MTXEMPTY = BitField(self, 0x00000020, "MTXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.MRXFIFOTRG = BitField(self, 0x00000004, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000008, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.MDMA_DONE1_2 = BitField(self, 0x00000800, "MDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.MDMA_DONE1_3 = BitField(self, 0x00001000, "MDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.SRXDONE = BitField(self, 0x00010000, "SRXDONE", "Slave Receive Data Interrupt. Signals that a byte has been received")
        self.STXDONE = BitField(self, 0x00020000, "STXDONE", "Slave Transmit Transaction completed Interrupt")
        self.SGENCALL = BitField(self, 0x01000000, "SGENCALL", "General Call Interrupt")
        self.STXEMPTY = BitField(self, 0x00200000, "STXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.SRXFIFOFULL = BitField(self, 0x00100000, "SRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.SRXFIFOTRG = BitField(self, 0x00040000, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00080000, "STXFIFOTRG", "Slave Transmit FIFO Trigger")
        self.SSTART = BitField(self, 0x00400000, "SSTART", "Start Condition Interrupt")
        self.SSTOP = BitField(self, 0x00800000, "SSTOP", "Stop Condition Interrupt")
        self.SDMA_DONE1_2 = BitField(self, 0x02000000, "SDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.SDMA_DONE1_3 = BitField(self, 0x04000000, "SDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.MPEC_RX_ERR = BitField(self, 0x00002000, "MPEC_RX_ERR", "Master RX Pec Error Interrupt")
        self.TIMEOUTB = BitField(self, 0x00008000, "TIMEOUTB", "Timeout B Interrupt")
        self.SPEC_RX_ERR = BitField(self, 0x08000000, "SPEC_RX_ERR", "Slave RX Pec Error Interrupt")
        self.STX_UNFL = BitField(self, 0x10000000, "STX_UNFL", "Slave TX FIFO underflow")
        self.SRX_OVFL = BitField(self, 0x20000000, "SRX_OVFL", "Slave RX FIFO overflow")
        self.SARBLOST = BitField(self, 0x40000000, "SARBLOST", "Slave Arbitration Lost")
        self.INTR_OVFL = BitField(self, 0x80000000, "INTR_OVFL", "Interrupt overflow")
        self.SDMA_DONE1 = Subscriptor(self, "SDMA_DONE1_{}")
        self.MDMA_DONE1 = Subscriptor(self, "MDMA_DONE1_{}")

class SA_I2C1_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.MRXDONE = BitField(self, 0x00000001, "MRXDONE", "Master Receive Data Interrupt. Signals that a byte has been received")
        self.TIMEOUTA = BitField(self, 0x00004000, "TIMEOUTA", "Timeout A interrupt")
        self.MNACK = BitField(self, 0x00000080, "MNACK", "Address/Data NACK Interrupt")
        self.MSTART = BitField(self, 0x00000100, "MSTART", "START Detection Interrupt")
        self.MSTOP = BitField(self, 0x00000200, "MSTOP", "STOP Detection Interrupt")
        self.MARBLOST = BitField(self, 0x00000400, "MARBLOST", "Arbitration Lost Interrupt")
        self.MTXDONE = BitField(self, 0x00000002, "MTXDONE", "Master Transmit Transaction completed Interrupt")
        self.MRXFIFOFULL = BitField(self, 0x00000010, "MRXFIFOFULL", "RXFIFO full event.")
        self.MTXEMPTY = BitField(self, 0x00000020, "MTXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.MRXFIFOTRG = BitField(self, 0x00000004, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000008, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.MDMA_DONE1_2 = BitField(self, 0x00000800, "MDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.MDMA_DONE1_3 = BitField(self, 0x00001000, "MDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.SRXDONE = BitField(self, 0x00010000, "SRXDONE", "Slave Receive Data Interrupt. Signals that a byte has been received")
        self.STXDONE = BitField(self, 0x00020000, "STXDONE", "Slave Transmit Transaction completed Interrupt")
        self.SGENCALL = BitField(self, 0x01000000, "SGENCALL", "General Call Interrupt")
        self.STXEMPTY = BitField(self, 0x00200000, "STXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.")
        self.SRXFIFOFULL = BitField(self, 0x00100000, "SRXFIFOFULL", "RXFIFO full event. This interrupt is set if an RX FIFO is full.")
        self.SRXFIFOTRG = BitField(self, 0x00040000, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00080000, "STXFIFOTRG", "Slave Transmit FIFO Trigger")
        self.SSTART = BitField(self, 0x00400000, "SSTART", "Slave START Detection Interrupt")
        self.SSTOP = BitField(self, 0x00800000, "SSTOP", "Slave STOP Detection Interrupt")
        self.SDMA_DONE1_2 = BitField(self, 0x02000000, "SDMA_DONE1_2", "DMA Done 1 on Event Channel 2")
        self.SDMA_DONE1_3 = BitField(self, 0x04000000, "SDMA_DONE1_3", "DMA Done 1 on Event Channel 3")
        self.MPEC_RX_ERR = BitField(self, 0x00002000, "MPEC_RX_ERR", "Master RX Pec Error Interrupt")
        self.TIMEOUTB = BitField(self, 0x00008000, "TIMEOUTB", "Timeout B Interrupt")
        self.SPEC_RX_ERR = BitField(self, 0x08000000, "SPEC_RX_ERR", "Slave RX Pec Error Interrupt")
        self.STX_UNFL = BitField(self, 0x10000000, "STX_UNFL", "Slave TX FIFO underflow")
        self.SRX_OVFL = BitField(self, 0x20000000, "SRX_OVFL", "Slave RX FIFO overflow")
        self.SARBLOST = BitField(self, 0x40000000, "SARBLOST", "Slave Arbitration Lost")
        self.INTR_OVFL = BitField(self, 0x80000000, "INTR_OVFL", "Interrupt overflow")
        self.SDMA_DONE1 = Subscriptor(self, "SDMA_DONE1_{}")
        self.MDMA_DONE1 = Subscriptor(self, "MDMA_DONE1_{}")

class SA_I2C1_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "I2C Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC. 15h-1Fh = Reserved")

class SA_I2C1_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C1_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C1_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C1_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C1_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C1_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "I2C Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC. 15h-1Fh = Reserved")

class SA_I2C1_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C1_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C1_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C1_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C1_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.MRXFIFOTRG = BitField(self, 0x00000001, "MRXFIFOTRG", "Master Receive FIFO Trigger. Trigger when RX FIFO contains &gt;= defined bytes")
        self.MTXFIFOTRG = BitField(self, 0x00000002, "MTXFIFOTRG", "Master Transmit FIFO Trigger. Trigger when Transmit FIFO contains &lt;= defined bytes")
        self.SRXFIFOTRG = BitField(self, 0x00000004, "SRXFIFOTRG", "Slave Receive FIFO Trigger")
        self.STXFIFOTRG = BitField(self, 0x00000008, "STXFIFOTRG", "Slave Transmit FIFO Trigger")

class SA_I2C1_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.INT1_CFG = BitField(self, 0x0000000C, "INT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.INT_CFG = Subscriptor(self, "INT{}_CFG")

class SA_I2C1_INTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INTCTL", "Interrupt control register")
        self.INTEVAL = BitField(self, 0x00000001, "INTEVAL", "Writing a 1 to this field re-evaluates the interrupt sources.")

class SA_I2C1_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_I2C1_GFCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GFCTL", "I2C Glitch Filter Control")
        self.AGFSEL = BitField(self, 0x00000600, "AGFSEL", "Analog Glitch Suppression Pulse Width. This field controls the pulse width select for the analog glitch suppression on SCL and SDA lines. See device datasheet for exact values. (ULP I2C only)")
        self.DGFSEL = BitField(self, 0x00000007, "DGFSEL", "Glitch Suppression Pulse Width. This field controls the pulse width select for glitch suppression on the SCL and SDA lines. The following values are the glitch suppression values in terms of functional clocks. (Core Domain only)")
        self.AGFEN = BitField(self, 0x00000100, "AGFEN", "Analog Glitch Suppression Enable")
        self.CHAIN = BitField(self, 0x00000800, "CHAIN", "Analog and digital noise filters chaining enable.")

class SA_I2C1_TIMEOUT_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x20002, "TIMEOUT_CTL", "I2C Timeout Count Control Register")
        self.TCNTLA = BitField(self, 0x000000FF, "TCNTLA", "Timeout counter A load value. Counter A is used for SCL low detection. This field contains the upper 8 bits of a 12-bit pre-load value for the Timeout A count. NOTE: The value of CNTLA must be greater than 1h. Each count is equal to 520 times the timeout period of functional clock. For example, with 8MHz functional clock and a 100KHz operating I2C clock, one timeout period will be equal to (1 / 8MHz) * 520 or 65 us.")
        self.TCNTAEN = BitField(self, 0x00008000, "TCNTAEN", "Timeout Counter A Enable")
        self.TCNTLB = BitField(self, 0x00FF0000, "TCNTLB", "Timeout Count B Load: Counter B is used for SCL High Detection. This field contains the upper 8 bits of a 12-bit pre-load value for the Timeout B count. NOTE: The value of CNTLB must be greater than 1h. . Each count is equal to 1* clock period. For example, with 10MHz functional clock one timeout period will be equal to1*100ns.")
        self.TCNTBEN = BitField(self, 0x80000000, "TCNTBEN", "Timeout Counter B Enable")

class SA_I2C1_TIMEOUT_CNT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x20002, "TIMEOUT_CNT", "I2C Timeout Count Register")
        self.TCNTA = BitField(self, 0x000000FF, "TCNTA", "Timeout Count A Current Count: This field contains the upper 8 bits of a 12-bit current counter for timeout counter A")
        self.TCNTB = BitField(self, 0x00FF0000, "TCNTB", "Timeout Count B Current Count: This field contains the upper 8 bits of a 12-bit current counter for timeout counter B")

class SA_I2C1_MSA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MSA", "I2C Master Slave Address Register")
        self.DIR = BitField(self, 0x00000001, "DIR", "Receive/Send. The DIR bit specifies if the next master operation is a Receive (High) or Transmit (Low). 0h = Transmit 1h = Receive")
        self.SADDR = BitField(self, 0x000007FE, "SADDR", "I2C Slave Address This field specifies bits A9 through A0 of the slave address.. In 7-bit addressing mode as selected by MSA.MODE bit, the top 3 bits are don't care")
        self.MMODE = BitField(self, 0x00008000, "MMODE", "This bit selects the adressing mode to be used in master mode. When 0, 7-bit addressing is used. When 1, 10-bit addressing is used.")

class SA_I2C1_MCTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCTR", "I2C Master Control Register")
        self.BURSTRUN = BitField(self, 0x00000001, "BURSTRUN", "I2C Master Enable. and start transaction")
        self.START = BitField(self, 0x00000002, "START", "Generate START")
        self.STOP = BitField(self, 0x00000004, "STOP", "Generate STOP")
        self.ACK = BitField(self, 0x00000008, "ACK", "Data Acknowledge Enable.. Software needs to configure this bit to send the ACK or NACK. See field decoding in Table: MCTR Field decoding.")
        self.MBLEN = BitField(self, 0x0FFF0000, "MBLEN", "I2C transaction length. This field contains the programmed length of bytes of the Transaction.")
        self.MACKOEN = BitField(self, 0x00000010, "MACKOEN", "Master ACK overrride Enable")
        self.RD_ON_TXEMPTY = BitField(self, 0x00000020, "RD_ON_TXEMPTY", "Read on TX Empty")

class SA_I2C1_MSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MSR", "I2C Master Status Register")
        self.BUSY = BitField(self, 0x00000001, "BUSY", "I2C Master FSM Busy. The BUSY bit is set during an ongoing transaction, so is set during the transmit/receive of the amount of data set in MBLEN including START, RESTART, Address and STOP signal generation when required for the current transaction.")
        self.ERR = BitField(self, 0x00000002, "ERR", "Error. The error can be from the slave address not being acknowledged or the transmit data not being acknowledged.")
        self.ADRACK = BitField(self, 0x00000004, "ADRACK", "Acknowledge Address")
        self.DATACK = BitField(self, 0x00000008, "DATACK", "Acknowledge Data")
        self.ARBLST = BitField(self, 0x00000010, "ARBLST", "Arbitration Lost")
        self.IDLE = BitField(self, 0x00000020, "IDLE", "I2C Idle")
        self.BUSBSY = BitField(self, 0x00000040, "BUSBSY", "I2C Bus is Busy. Master State Machine will wait until this bit is cleared before starting a transaction. When first enabling the Master in multi master environments, FW should wait for one I2C clock period after setting ACTIVE high before writing to the MTCR register to start the transaction so that if SCL goes low it will trigger the BUSBSY.")
        self.MBCNT = BitField(self, 0x0FFF0000, "MBCNT", "I2C Master Transaction Count. This field contains the current count-down value of the transaction.")

class SA_I2C1_MRXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MRXDATA", "I2C Master RXData")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Received Data. . This field contains the last received data.")

class SA_I2C1_MTXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MTXDATA", "I2C Master TXData")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Transmit Data. This byte contains the data to be transferred during the next transaction.")

class SA_I2C1_MTPR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x1, "MTPR", "I2C Master Timer Period")
        self.TPR = BitField(self, 0x0000007F, "TPR", "Timer Period . This field is used in the equation to configure SCL_PERIOD : SCL_PERIOD = (1 + TPR ) * (SCL_LP + SCL_HP ) * INT_CLK_PRD where: SCL_PRD is the SCL line period (I2C clock). TPR is the Timer Period register value (range of 1 to 127). SCL_LP is the SCL Low period (fixed at 6). SCL_HP is the SCL High period (fixed at 4). CLK_PRD is the functional clock period in ns.")

class SA_I2C1_MCR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MCR", "I2C Master Configuration")
        self.LPBK = BitField(self, 0x00000100, "LPBK", "I2C Loopback")
        self.MMST = BitField(self, 0x00000002, "MMST", "Multimaster mode. In Multimaster mode the SCL high time counts once the SCL line has been detected high. If this is not enabled the high time counts as soon as the SCL line has been set high by the I2C controller.")
        self.ACTIVE = BitField(self, 0x00000001, "ACTIVE", "Device Active After this bit has been set, it should not be set again unless it has been cleared by writing a 0 or by a reset, otherwise transfer failures may occur.")
        self.CLKSTRETCH = BitField(self, 0x00000004, "CLKSTRETCH", "Clock Stretching. This bit controls the support for clock stretching of the I2C bus.")

class SA_I2C1_MBMON(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x3, "MBMON", "I2C Master Bus Monitor")
        self.SCL = BitField(self, 0x00000001, "SCL", "I2C SCL Status")
        self.SDA = BitField(self, 0x00000002, "SDA", "I2C SDA Status")

class SA_I2C1_MFIFOCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MFIFOCTL", "I2C Master FIFO Control")
        self.TXTRIG = BitField(self, 0x00000007, "TXTRIG", "TX FIFO Trigger. Indicates at what fill level in the TX FIFO a trigger will be generated.")
        self.TXFLUSH = BitField(self, 0x00000080, "TXFLUSH", "TX FIFO Flush. Setting this bit will Flush the TX FIFO. Before reseting this bit to stop Flush the TXFIFOCNT should be checked to be 8 and indicating that the Flush has completed.")
        self.RXTRIG = BitField(self, 0x00000700, "RXTRIG", "RX FIFO Trigger. Indicates at what fill level in the RX FIFO a trigger will be generated. Note: Programming RXTRIG to 0x0 has no effect since no data is present to transfer out of RX FIFO.")
        self.RXFLUSH = BitField(self, 0x00008000, "RXFLUSH", "RX FIFO Flush. Setting this bit will Flush the RX FIFO. Before reseting this bit to stop Flush the RXFIFOCNT should be checked to be 0 and indicating that the Flush has completed.")

class SA_I2C1_MFIFOSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x800, "MFIFOSR", "I2C Master FIFO Status Register")
        self.RXFIFOCNT = BitField(self, 0x0000000F, "RXFIFOCNT", "Number of Bytes which could be read from the RX FIFO")
        self.TXFIFOCNT = BitField(self, 0x00000F00, "TXFIFOCNT", "Number of Bytes which could be put into the TX FIFO")
        self.RXFLUSH = BitField(self, 0x00000080, "RXFLUSH", "RX FIFO Flush. When this bit is set a Flush operation for the RX FIFO is active. Clear the RXFLUSH bit in the control register to stop.")
        self.TXFLUSH = BitField(self, 0x00008000, "TXFLUSH", "TX FIFO Flush. When this bit is set a Flush operation for the TX FIFO is active. Clear the TXFLUSH bit in the control register to stop.")

class SA_I2C1_MASTER_I2CPECCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MASTER_I2CPECCTL", "I2C master PEC control register")
        self.PECCNT = BitField(self, 0x000001FF, "PECCNT", "PEC Count. When this field is non zero, the number of I2C bytes are counted (Note that although the PEC is calculated on the I2C address it is not counted at a byte). When the byte count = PECCNT and the state machine is transmitting, the contents of the LSFR is loaded into the shift register instead of the byte received from the Tx FIFO. When the state machine is receiving, after the last bit of this byte is received the LSFR is checked and if it is non-zero, a PEC RX Error interrupt is generated. The I2C packet must be padded to include the PEC byte for both transmit and receive. In transmit mode the FIFO must be loaded with a dummy PEC byte. In receive mode the PEC byte will be passed to the Rx FIFO. In the normal Master use case, FW would set PECEN=1 and PECCNT=SMB packet length (Not including Slave Address byte, but including the PEC byte). FW would then configure DMA to allow the packet to complete unassisted and write MCTR to initiate the transaction. Note that when the byte count = PEC CNT, the byte count is reset to 0 and multiple PEC calculation can automatically occur within a single I2C transaction. Note that any write to the MASTER_I2CPECCTL Register will clear the current PEC Byte Count in the Master State Machine.")
        self.PECEN = BitField(self, 0x00001000, "PECEN", "PEC Enable. This bit enables the SMB Packet Error Checking (PEC). When enabled the PEC is calculated on all bits accept the Start, Stop, Ack and Nack. The PEC LSFR and the Byte Counter is set to 0 when the State Machine is in the IDLE state, which occur following a Stop or when a timeout occurs. The Counter is also set to 0 after the PEC byte is sent or received. Note that the NACK is automatically send following a PEC byte that results in a PEC error. The PEC Polynomial is x^8 + x^2 + x^1 + 1.")

class SA_I2C1_MASTER_PECSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MASTER_PECSR", "I2C master PEC status register")
        self.PECBYTECNT = BitField(self, 0x000001FF, "PECBYTECNT", "PEC Byte Count . This is the current PEC Byte Count of the Master State Machine.")
        self.PECSTS_CHECK = BitField(self, 0x00010000, "PECSTS_CHECK", "This status bit indicates if the PEC was checked in the transaction that occurred before the last Stop. Latched on Stop.")
        self.PECSTS_ERROR = BitField(self, 0x00020000, "PECSTS_ERROR", "This status bit indicates if a PEC check error occurred in the transaction that occurred before the last Stop. Latched on Stop.")

class SA_I2C1_SOAR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x4000, "SOAR", "I2C Slave Own Address")
        self.OAR = BitField(self, 0x000003FF, "OAR", "I2C Slave Own Address: This field specifies bits A9 through A0 of the slave address.. In 7-bit addressing mode as selected by I2CSOAR.MODE bit, the top 3 bits are don't care")
        self.OAREN = BitField(self, 0x00004000, "OAREN", "I2C Slave Own Address Enable")
        self.SMODE = BitField(self, 0x00008000, "SMODE", "This bit selects the adressing mode to be used in slave mode.. When 0, 7-bit addressing is used. When 1, 10-bit addressing is used.")

class SA_I2C1_SOAR2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SOAR2", "I2C Slave Own Address 2")
        self.OAR2 = BitField(self, 0x0000007F, "OAR2", "I2C Slave Own Address 2. This field specifies the alternate OAR2 address.")
        self.OAR2EN = BitField(self, 0x00000080, "OAR2EN", "I2C Slave Own Address 2 Enable")
        self.OAR2_MASK = BitField(self, 0x007F0000, "OAR2_MASK", "I2C Slave Own Address 2 Mask: This field specifies bits A6 through A0 of the slave address.. The bits with value 1 in SOAR2.OAR2_MASK field will make the corresponding incoming address bits to match by default regardless of the value inside SOAR2.OAR2 i.e. corresponding SOAR2.OAR2 bit is a dont care.")

class SA_I2C1_SCTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x404, "SCTR", "I2C Slave Control Register")
        self.ACTIVE = BitField(self, 0x00000001, "ACTIVE", "Device Active. Setting this bit enables the slave functionality.")
        self.GENCALL = BitField(self, 0x00000002, "GENCALL", "General call response enable. This bit is only available in UCBxI2COA0.. Modify only when UCSWRST = 1. 0b = Do not respond to a general call 1b = Respond to a general call")
        self.SCLKSTRETCH = BitField(self, 0x00000004, "SCLKSTRETCH", "Slave Clock Stretch Enable")
        self.TXEMPTY_ON_TREQ = BitField(self, 0x00000008, "TXEMPTY_ON_TREQ", "Tx Empty Interrupt on TREQ")
        self.TXTRIG_TXMODE = BitField(self, 0x00000010, "TXTRIG_TXMODE", "Tx Trigger when slave FSM is in Tx Mode")
        self.TXWAIT_STALE_TXFIFO = BitField(self, 0x00000020, "TXWAIT_STALE_TXFIFO", "Tx transfer waits when stale data in Tx FIFO.. This prevents stale bytes left in the TX FIFO from automatically being sent on the next I2C packet. Note: this should be used with TXEMPTY_ON_TREQ set to prevent the Slave State Machine from waiting for TX FIFO data without an interrupt notification when the FIFO data is stale.")
        self.RXFULL_ON_RREQ = BitField(self, 0x00000040, "RXFULL_ON_RREQ", "Rx full interrupt generated on RREQ condition as indicated in SSR")
        self.EN_DEFHOSTADR = BitField(self, 0x00000080, "EN_DEFHOSTADR", "Enable Default Host Address")
        self.EN_ALRESPADR = BitField(self, 0x00000100, "EN_ALRESPADR", "Enable Alert Response Address")
        self.EN_DEFDEVADR = BitField(self, 0x00000200, "EN_DEFDEVADR", "Enable Deault device address")
        self.SWUEN = BitField(self, 0x00000400, "SWUEN", "Slave Wakeup Enable")

class SA_I2C1_SSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SSR", "I2C Slave Status Register")
        self.RREQ = BitField(self, 0x00000001, "RREQ", "Receive Request")
        self.TREQ = BitField(self, 0x00000002, "TREQ", "Transmit Request")
        self.OAR2SEL = BitField(self, 0x00000008, "OAR2SEL", "OAR2 Address Matched. This bit gets reevaluated after every address comparison.")
        self.QCMDST = BitField(self, 0x00000010, "QCMDST", "Quick Command Status. Value Description: 0: The last transaction was a normal transaction or a transaction has not occurred. 1: The last transaction was a Quick Command transaction")
        self.QCMDRW = BitField(self, 0x00000020, "QCMDRW", "Quick Command Read / Write . This bit only has meaning when the QCMDST bit is set. Value Description: 0: Quick command was a write 1: Quick command was a read")
        self.RXMODE = BitField(self, 0x00000004, "RXMODE", "Slave FSM is in Rx MODE")
        self.BUSBSY = BitField(self, 0x00000040, "BUSBSY", "I2C bus is busy")
        self.TXMODE = BitField(self, 0x00000080, "TXMODE", "Slave FSM is in TX MODE")
        self.STALE_TXFIFO = BitField(self, 0x00000100, "STALE_TXFIFO", "Stale Tx FIFO")
        self.ADDRMATCH = BitField(self, 0x0007FE00, "ADDRMATCH", "Indicates the address for which slave address match happened")

class SA_I2C1_SRXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SRXDATA", "I2C Slave RXData")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Received Data. . This field contains the last received data.")

class SA_I2C1_STXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STXDATA", "I2C Slave TXData")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Transmit Data. This byte contains the data to be transferred during the next transaction.")

class SA_I2C1_SACKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SACKCTL", "I2C Slave ACK Control")
        self.ACKOEN = BitField(self, 0x00000001, "ACKOEN", "I2C Slave ACK Override Enable")
        self.ACKOVAL = BitField(self, 0x00000002, "ACKOVAL", "I2C Slave ACK Override Value. Note: for General Call this bit will be ignored if set to NACK and slave continues to receive data.")
        self.ACKOEN_ON_START = BitField(self, 0x00000004, "ACKOEN_ON_START", "When set this bit will automatically turn on the Slave ACKOEN field following a Start Condition.")
        self.ACKOEN_ON_PECNEXT = BitField(self, 0x00000008, "ACKOEN_ON_PECNEXT", "When set this bit will automatically turn on the Slave ACKOEN field following the ACK/NACK of the byte received just prior to the PEC byte.. Note that when ACKOEN is set the PEC byte will not automatically be ACKed/NACKed by the State Machine and FW must perform this function by writing SLAVE_SACKCTL.")
        self.ACKOEN_ON_PECDONE = BitField(self, 0x00000010, "ACKOEN_ON_PECDONE", "When set this bit will automatically turn on the Slave ACKOEN field following the ACK/NACK of the received PEC byte.")

class SA_I2C1_SFIFOCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SFIFOCTL", "I2C Slave FIFO Control")
        self.TXTRIG = BitField(self, 0x00000007, "TXTRIG", "TX FIFO Trigger. Indicates at what fill level in the TX FIFO a trigger will be generated.")
        self.TXFLUSH = BitField(self, 0x00000080, "TXFLUSH", "TX FIFO Flush. Setting this bit will Flush the TX FIFO. Before reseting this bit to stop Flush the TXFIFOCNT should be checked to be 8 and indicating that the Flush has completed.")
        self.RXFLUSH = BitField(self, 0x00008000, "RXFLUSH", "RX FIFO Flush. Setting this bit will Flush the RX FIFO. Before reseting this bit to stop Flush the RXFIFOCNT should be checked to be 0 and indicating that the Flush has completed.")
        self.RXTRIG = BitField(self, 0x00000700, "RXTRIG", "RX FIFO Trigger. Indicates at what fill level in the RX FIFO a trigger will be generated. Note: Programming RXTRIG to 0x0 has no effect since no data is present to transfer out of RX FIFO.")

class SA_I2C1_SFIFOSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x800, "SFIFOSR", "I2C Slave FIFO Status Register")
        self.RXFIFOCNT = BitField(self, 0x0000000F, "RXFIFOCNT", "Number of Bytes which could be read from the RX FIFO")
        self.TXFIFOCNT = BitField(self, 0x00000F00, "TXFIFOCNT", "Number of Bytes which could be put into the TX FIFO")
        self.TXFLUSH = BitField(self, 0x00008000, "TXFLUSH", "TX FIFO Flush. When this bit is set a Flush operation for the TX FIFO is active. Clear the TXFLUSH bit in the control register to stop.")
        self.RXFLUSH = BitField(self, 0x00000080, "RXFLUSH", "RX FIFO Flush. When this bit is set a Flush operation for the RX FIFO is active. Clear the RXFLUSH bit in the control register to stop.")

class SA_I2C1_SLAVE_PECCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SLAVE_PECCTL", "I2C Slave PEC control register")
        self.PECCNT = BitField(self, 0x000001FF, "PECCNT", "When this field is non zero, the number of I2C data bytes are counted. When the byte count = PECCNT and the state machine is transmitting, the contents of the LSFR is loaded into the shift register instead of the byte received from the Tx FIFO. When the state machine is receiving, after the last bit of this byte is received the LSFR is checked and if it is non-zero, a PEC RX Error interrupt is generated. The I2C packet must be padded to include the PEC byte for both transmit and receive. In transmit mode the FIFO must be loaded with a dummy PEC byte. In receive mode the PEC byte will be passed to the Rx FIFO.. In the normal Slave use case, FW would set PECEN=1 and PECCNT=0 and use the ACKOEN until the remaining SMB packet length is known. FW would then set the PECCNT to the remaining packet length (Including PEC bye). FW would then configure DMA to allow the packet to complete unassisted and exit NoAck mode. Note that when the byte count = PEC CNT, the byte count is reset to 0 and multiple PEC calculation can automatically occur within a single I2C transaction")
        self.PECEN = BitField(self, 0x00001000, "PECEN", "PEC Enable. This bit enables the SMB Packet Error Checking (PEC). When enabled the PEC is calculated on all bits accept the Start, Stop, Ack and Nack. The PEC LSFR and the Byte Counter is set to 0 when the State Machine is in the IDLE state, which occur following a Stop or when a timeout occurs. The Counter is also set to 0 after the PEC byte is sent or received. Note that the NACK is automatically send following a PEC byte that results in a PEC error. The PEC Polynomial is x^8 + x^2 + x^1 + 1.")

class SA_I2C1_SLAVE_PECSR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SLAVE_PECSR", "I2C slave PEC status register")
        self.PECBYTECNT = BitField(self, 0x000001FF, "PECBYTECNT", "This is the current PEC Byte Count of the Slave State Machine.")
        self.PECSTS_CHECK = BitField(self, 0x00010000, "PECSTS_CHECK", "This status bit indicates if the PEC was checked in the transaction that occurred before the last Stop. Latched on Stop.")
        self.PECSTS_ERROR = BitField(self, 0x00020000, "PECSTS_ERROR", "This status bit indicates if a PEC check error occurred in the transaction that occurred before the last Stop. Latched on Stop.")

class SA_I2C1(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_I2C1_PWREN(self, 0x800)
        self.RSTCTL = SA_I2C1_RSTCTL(self, 0x804)
        self.CLKCFG = SA_I2C1_CLKCFG(self, 0x808)
        self.STAT = SA_I2C1_STAT(self, 0x814)
        self.CLKDIV = SA_I2C1_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_I2C1_CLKSEL(self, 0x1004)
        self.PDBGCTL = SA_I2C1_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_I2C1_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_I2C1_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_I2C1_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_I2C1_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_I2C1_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_I2C1_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_I2C1_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_I2C1_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_I2C1_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_I2C1_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_I2C1_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_I2C1_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_I2C1_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_I2C1_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_I2C1_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_I2C1_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_I2C1_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_I2C1_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_I2C1_EVT_MODE(self, 0x10E0)
        self.INTCTL = SA_I2C1_INTCTL(self, 0x10E4)
        self.DESC = SA_I2C1_DESC(self, 0x10FC)
        self.GFCTL = SA_I2C1_GFCTL(self, 0x1200)
        self.TIMEOUT_CTL = SA_I2C1_TIMEOUT_CTL(self, 0x1204)
        self.TIMEOUT_CNT = SA_I2C1_TIMEOUT_CNT(self, 0x1208)
        self.MSA = SA_I2C1_MSA(self, 0x1210)
        self.MCTR = SA_I2C1_MCTR(self, 0x1214)
        self.MSR = SA_I2C1_MSR(self, 0x1218)
        self.MRXDATA = SA_I2C1_MRXDATA(self, 0x121C)
        self.MTXDATA = SA_I2C1_MTXDATA(self, 0x1220)
        self.MTPR = SA_I2C1_MTPR(self, 0x1224)
        self.MCR = SA_I2C1_MCR(self, 0x1228)
        self.MBMON = SA_I2C1_MBMON(self, 0x1234)
        self.MFIFOCTL = SA_I2C1_MFIFOCTL(self, 0x1238)
        self.MFIFOSR = SA_I2C1_MFIFOSR(self, 0x123C)
        self.MASTER_I2CPECCTL = SA_I2C1_MASTER_I2CPECCTL(self, 0x1240)
        self.MASTER_PECSR = SA_I2C1_MASTER_PECSR(self, 0x1244)
        self.SOAR = SA_I2C1_SOAR(self, 0x1250)
        self.SOAR2 = SA_I2C1_SOAR2(self, 0x1254)
        self.SCTR = SA_I2C1_SCTR(self, 0x1258)
        self.SSR = SA_I2C1_SSR(self, 0x125C)
        self.SRXDATA = SA_I2C1_SRXDATA(self, 0x1260)
        self.STXDATA = SA_I2C1_STXDATA(self, 0x1264)
        self.SACKCTL = SA_I2C1_SACKCTL(self, 0x1268)
        self.SFIFOCTL = SA_I2C1_SFIFOCTL(self, 0x126C)
        self.SFIFOSR = SA_I2C1_SFIFOSR(self, 0x1270)
        self.SLAVE_PECCTL = SA_I2C1_SLAVE_PECCTL(self, 0x1274)
        self.SLAVE_PECSR = SA_I2C1_SLAVE_PECSR(self, 0x1278)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

I2C1 = SA_I2C1(0x400F2000, "I2C1")

class SA_GPIOA_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subsciber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_GPIOA_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_GPIOA_FPUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_0", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_GPIOA_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_GPIOA_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_GPIOA_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_GPIOA_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_GPIOA_CLKOVR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKOVR", "Clock Override")
        self.OVERRIDE = BitField(self, 0x00000001, "OVERRIDE", "Unlocks the functionality of [RUN_STOP] to override the automatic peripheral clock request")
        self.RUN_STOP = BitField(self, 0x00000002, "RUN_STOP", "If [OVERRIDE] is enabled, this register is used to manually control the peripheral's clock request to the system")

class SA_GPIOA_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x1, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")

class SA_GPIOA_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_GPIOA_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event mask")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event mask")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event mask")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event mask")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event mask")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event mask")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event mask")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event mask")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event mask")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event mask")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event mask")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event mask")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event mask")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event mask")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event mask")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event mask")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event mask")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event mask")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event mask")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event mask")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event mask")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event mask")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event mask")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event mask")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event mask")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event mask")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event mask")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event mask")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event mask")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event mask")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event mask")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event mask")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_GPIOA_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event mask")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event mask")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event mask")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event mask")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event mask")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event mask")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event mask")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event mask")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event mask")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event mask")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event mask")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event mask")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event mask")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event mask")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event mask")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event mask")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "DIO0 event")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "DIO1 event")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "DIO2 event")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "DIO3 event")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "DIO4 event")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "DIO5 event")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "DIO6 event")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "DIO7 event")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "DIO8 event")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "DIO9 event")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "DIO10 event")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "DIO11 event")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "DIO12 event")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "DIO13 event")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "DIO14 event")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "DIO15 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_GPIOA_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event mask")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event mask")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event mask")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event mask")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event mask")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event mask")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event mask")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event mask")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event mask")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event mask")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event mask")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event mask")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event mask")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event mask")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event mask")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event mask")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "DIO16 event")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "DIO17 event")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "DIO18 event")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "DIO19 event")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "DIO20 event")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "DIO21 event")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "DIO22 event")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "DIO23 event")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "DIO24 event")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "DIO25 event")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "DIO26 event")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "DIO27 event")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "DIO28 event")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "DIO29 event")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "DIO30 event")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "DIO31 event")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_GPIOA_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_GPIOA_DOUT3_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT3_0", "Data output 3 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "This bit sets the value of the pin configured as DIO0 when the output is enabled through DOE31_0 register.")
        self.DIO1 = BitField(self, 0x00000100, "DIO1", "This bit sets the value of the pin configured as DIO1 when the output is enabled through DOE31_0 register.")
        self.DIO2 = BitField(self, 0x00010000, "DIO2", "This bit sets the value of the pin configured as DIO2 when the output is enabled through DOE31_0 register.")
        self.DIO3 = BitField(self, 0x01000000, "DIO3", "This bit sets the value of the pin configured as DIO3 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUT7_4(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT7_4", "Data output 7 to 4")
        self.DIO4 = BitField(self, 0x00000001, "DIO4", "This bit sets the value of the pin configured as DIO4 when the output is enabled through DOE31_0 register.")
        self.DIO5 = BitField(self, 0x00000100, "DIO5", "This bit sets the value of the pin configured as DIO5 when the output is enabled through DOE31_0 register.")
        self.DIO6 = BitField(self, 0x00010000, "DIO6", "This bit sets the value of the pin configured as DIO6 when the output is enabled through DOE31_0 register.")
        self.DIO7 = BitField(self, 0x01000000, "DIO7", "This bit sets the value of the pin configured as DIO7 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUT11_8(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT11_8", "Data output 11 to 8")
        self.DIO8 = BitField(self, 0x00000001, "DIO8", "This bit sets the value of the pin configured as DIO8 when the output is enabled through DOE31_0 register.")
        self.DIO9 = BitField(self, 0x00000100, "DIO9", "This bit sets the value of the pin configured as DIO9 when the output is enabled through DOE31_0 register.")
        self.DIO10 = BitField(self, 0x00010000, "DIO10", "This bit sets the value of the pin configured as DIO10 when the output is enabled through DOE31_0 register.")
        self.DIO11 = BitField(self, 0x01000000, "DIO11", "This bit sets the value of the pin configured as DIO11 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUT15_12(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT15_12", "Data output 15 to 12")
        self.DIO12 = BitField(self, 0x00000001, "DIO12", "This bit sets the value of the pin configured as DIO12 when the output is enabled through DOE31_0 register.")
        self.DIO13 = BitField(self, 0x00000100, "DIO13", "This bit sets the value of the pin configured as DIO13 when the output is enabled through DOE31_0 register.")
        self.DIO14 = BitField(self, 0x00010000, "DIO14", "This bit sets the value of the pin configured as DIO14 when the output is enabled through DOE31_0 register.")
        self.DIO15 = BitField(self, 0x01000000, "DIO15", "This bit sets the value of the pin configured as DIO15 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUT19_16(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT19_16", "Data output 19 to 16")
        self.DIO16 = BitField(self, 0x00000001, "DIO16", "This bit sets the value of the pin configured as DIO16 when the output is enabled through DOE31_0 register.")
        self.DIO17 = BitField(self, 0x00000100, "DIO17", "This bit sets the value of the pin configured as DIO17 when the output is enabled through DOE31_0 register.")
        self.DIO18 = BitField(self, 0x00010000, "DIO18", "This bit sets the value of the pin configured as DIO18 when the output is enabled through DOE31_0 register.")
        self.DIO19 = BitField(self, 0x01000000, "DIO19", "This bit sets the value of the pin configured as DIO19 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUT23_20(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT23_20", "Data output 23 to 20")
        self.DIO20 = BitField(self, 0x00000001, "DIO20", "This bit sets the value of the pin configured as DIO20 when the output is enabled through DOE31_0 register.")
        self.DIO21 = BitField(self, 0x00000100, "DIO21", "This bit sets the value of the pin configured as DIO21 when the output is enabled through DOE31_0 register.")
        self.DIO22 = BitField(self, 0x00010000, "DIO22", "This bit sets the value of the pin configured as DIO22 when the output is enabled through DOE31_0 register.")
        self.DIO23 = BitField(self, 0x01000000, "DIO23", "This bit sets the value of the pin configured as DIO23 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUT27_24(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT27_24", "Data output 27 to 24")
        self.DIO24 = BitField(self, 0x00000001, "DIO24", "This bit sets the value of the pin configured as DIO24 when the output is enabled through DOE31_0 register.")
        self.DIO25 = BitField(self, 0x00000100, "DIO25", "This bit sets the value of the pin configured as DIO25 when the output is enabled through DOE31_0 register.")
        self.DIO26 = BitField(self, 0x00010000, "DIO26", "This bit sets the value of the pin configured as DIO26 when the output is enabled through DOE31_0 register.")
        self.DIO27 = BitField(self, 0x01000000, "DIO27", "This bit sets the value of the pin configured as DIO27 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUT31_28(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT31_28", "Data output 31 to 28")
        self.DIO28 = BitField(self, 0x00000001, "DIO28", "This bit sets the value of the pin configured as DIO28 when the output is enabled through DOE31_0 register.")
        self.DIO29 = BitField(self, 0x00000100, "DIO29", "This bit sets the value of the pin configured as DIO29 when the output is enabled through DOE31_0 register.")
        self.DIO30 = BitField(self, 0x00010000, "DIO30", "This bit sets the value of the pin configured as DIO30 when the output is enabled through DOE31_0 register.")
        self.DIO31 = BitField(self, 0x01000000, "DIO31", "This bit sets the value of the pin configured as DIO31 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUT31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUT31_0", "Data output 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "This bit sets the value of the pin configured as DIO0 when the output is enabled through DOE31_0 register.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "This bit sets the value of the pin configured as DIO1 when the output is enabled through DOE31_0 register.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "This bit sets the value of the pin configured as DIO2 when the output is enabled through DOE31_0 register.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "This bit sets the value of the pin configured as DIO3 when the output is enabled through DOE31_0 register.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "This bit sets the value of the pin configured as DIO4 when the output is enabled through DOE31_0 register.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "This bit sets the value of the pin configured as DIO5 when the output is enabled through DOE31_0 register.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "This bit sets the value of the pin configured as DIO6 when the output is enabled through DOE31_0 register.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "This bit sets the value of the pin configured as DIO7 when the output is enabled through DOE31_0 register.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "This bit sets the value of the pin configured as DIO8 when the output is enabled through DOE31_0 register.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "This bit sets the value of the pin configured as DIO9 when the output is enabled through DOE31_0 register.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "This bit sets the value of the pin configured as DIO10 when the output is enabled through DOE31_0 register.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "This bit sets the value of the pin configured as DIO11 when the output is enabled through DOE31_0 register.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "This bit sets the value of the pin configured as DIO12 when the output is enabled through DOE31_0 register.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "This bit sets the value of the pin configured as DIO13 when the output is enabled through DOE31_0 register.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "This bit sets the value of the pin configured as DIO14 when the output is enabled through DOE31_0 register.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "This bit sets the value of the pin configured as DIO15 when the output is enabled through DOE31_0 register.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "This bit sets the value of the pin configured as DIO16 when the output is enabled through DOE31_0 register.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "This bit sets the value of the pin configured as DIO17 when the output is enabled through DOE31_0 register.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "This bit sets the value of the pin configured as DIO18 when the output is enabled through DOE31_0 register.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "This bit sets the value of the pin configured as DIO19 when the output is enabled through DOE31_0 register.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "This bit sets the value of the pin configured as DIO20 when the output is enabled through DOE31_0 register.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "This bit sets the value of the pin configured as DIO21 when the output is enabled through DOE31_0 register.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "This bit sets the value of the pin configured as DIO22 when the output is enabled through DOE31_0 register.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "This bit sets the value of the pin configured as DIO23 when the output is enabled through DOE31_0 register.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "This bit sets the value of the pin configured as DIO24 when the output is enabled through DOE31_0 register.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "This bit sets the value of the pin configured as DIO25 when the output is enabled through DOE31_0 register.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "This bit sets the value of the pin configured as DIO26 when the output is enabled through DOE31_0 register.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "This bit sets the value of the pin configured as DIO27 when the output is enabled through DOE31_0 register.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "This bit sets the value of the pin configured as DIO28 when the output is enabled through DOE31_0 register.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "This bit sets the value of the pin configured as DIO29 when the output is enabled through DOE31_0 register.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "This bit sets the value of the pin configured as DIO30 when the output is enabled through DOE31_0 register.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "This bit sets the value of the pin configured as DIO31 when the output is enabled through DOE31_0 register.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUTSET31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUTSET31_0", "Data output set 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "Writing 1 to this bit sets the DIO0 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "Writing 1 to this bit sets the DIO1 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "Writing 1 to this bit sets the DIO2 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "Writing 1 to this bit sets the DIO3 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "Writing 1 to this bit sets the DIO4 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "Writing 1 to this bit sets the DIO5 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "Writing 1 to this bit sets the DIO6 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "Writing 1 to this bit sets the DIO7 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "Writing 1 to this bit sets the DIO8 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "Writing 1 to this bit sets the DIO9 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "Writing 1 to this bit sets the DIO10 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "Writing 1 to this bit sets the DIO11 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "Writing 1 to this bit sets the DIO12 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "Writing 1 to this bit sets the DIO13 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "Writing 1 to this bit sets the DIO14 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "Writing 1 to this bit sets the DIO15 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "Writing 1 to this bit sets the DIO16 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "Writing 1 to this bit sets the DIO17 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "Writing 1 to this bit sets the DIO18 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "Writing 1 to this bit sets the DIO19 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "Writing 1 to this bit sets the DIO20 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "Writing 1 to this bit sets the DIO21 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "Writing 1 to this bit sets the DIO22 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "Writing 1 to this bit sets the DIO23 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "Writing 1 to this bit sets the DIO24 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "Writing 1 to this bit sets the DIO25 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "Writing 1 to this bit sets the DIO26 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "Writing 1 to this bit sets the DIO27 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "Writing 1 to this bit sets the DIO28 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "Writing 1 to this bit sets the DIO29 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "Writing 1 to this bit sets the DIO30 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "Writing 1 to this bit sets the DIO31 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUTCLR31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUTCLR31_0", "Data output clear 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "Writing 1 to this bit clears the DIO0 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "Writing 1 to this bit clears the DIO1 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "Writing 1 to this bit clears the DIO2 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "Writing 1 to this bit clears the DIO3 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "Writing 1 to this bit clears the DIO4 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "Writing 1 to this bit clears the DIO5 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "Writing 1 to this bit clears the DIO6 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "Writing 1 to this bit clears the DIO7 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "Writing 1 to this bit clears the DIO8 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "Writing 1 to this bit clears the DIO9 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "Writing 1 to this bit clears the DIO10 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "Writing 1 to this bit clears the DIO11 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "Writing 1 to this bit clears the DIO12 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "Writing 1 to this bit clears the DIO13 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "Writing 1 to this bit clears the DIO14 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "Writing 1 to this bit clears the DIO15 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "Writing 1 to this bit clears the DIO16 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "Writing 1 to this bit clears the DIO17 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "Writing 1 to this bit clears the DIO18 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "Writing 1 to this bit clears the DIO19 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "Writing 1 to this bit clears the DIO20 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "Writing 1 to this bit clears the DIO21 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "Writing 1 to this bit clears the DIO22 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "Writing 1 to this bit clears the DIO23 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "Writing 1 to this bit clears the DIO24 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "Writing 1 to this bit clears the DIO25 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "Writing 1 to this bit clears the DIO26 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "Writing 1 to this bit clears the DIO27 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "Writing 1 to this bit clears the DIO28 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "Writing 1 to this bit clears the DIO29 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "Writing 1 to this bit clears the DIO30 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "Writing 1 to this bit clears the DIO31 bit in the DOUT31_0 register. Writing 0 has no effect.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOUTTGL31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOUTTGL31_0", "Data output toggle 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "This bit is used to toggle DIO0 output.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "This bit is used to toggle DIO1 output.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "This bit is used to toggle DIO2 output.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "This bit is used to toggle DIO3 output.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "This bit is used to toggle DIO4 output.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "This bit is used to toggle DIO5 output.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "This bit is used to toggle DIO6 output.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "This bit is used to toggle DIO7 output.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "This bit is used to toggle DIO8 output.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "This bit is used to toggle DIO9 output.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "This bit is used to toggle DIO10 output.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "This bit is used to toggle DIO11 output.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "This bit is used to toggle DIO12 output.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "This bit is used to toggle DIO13 output.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "This bit is used to toggle DIO14 output.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "This bit is used to toggle DIO15 output.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "This bit is used to toggle DIO16 output.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "This bit is used to toggle DIO17 output.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "This bit is used to toggle DIO18 output.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "This bit is used to toggle DIO19 output.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "This bit is used to toggle DIO20 output.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "This bit is used to toggle DIO21 output.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "This bit is used to toggle DIO22 output.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "This bit is used to toggle DIO23 output.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "This bit is used to toggle DIO24 output.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "This bit is used to toggle DIO25 output.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "This bit is used to toggle DIO26 output.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "This bit is used to toggle DIO27 output.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "This bit is used to toggle DIO28 output.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "This bit is used to toggle DIO29 output.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "This bit is used to toggle DIO30 output.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "This bit is used to toggle DIO31 output.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOE31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOE31_0", "Data output enable 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "Enables data output for DIO0.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "Enables data output for DIO1.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "Enables data output for DIO2.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "Enables data output for DIO3.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "Enables data output for DIO4.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "Enables data output for DIO5.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "Enables data output for DIO6.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "Enables data output for DIO7.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "Enables data output for DIO8.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "Enables data output for DIO9.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "Enables data output for DIO10.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "Enables data output for DIO11.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "Enables data output for DIO12.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "Enables data output for DIO13.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "Enables data output for DIO14.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "Enables data output for DIO15.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "Enables data output for DIO16.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "Enables data output for DIO17.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "Enables data output for DIO18.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "Enables data output for DIO19.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "Enables data output for DIO20.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "Enables data output for DIO21.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "Enables data output for DIO22.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "Enables data output for DIO23.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "Enables data output for DIO24.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "Enables data output for DIO25.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "Enables data output for DIO26.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "Enables data output for DIO27.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "Enables data output for DIO28.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "Enables data output for DIO29.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "Enables data output for DIO30.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "Enables data output for DIO31.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOESET31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOESET31_0", "Data output enable set 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "Writing 1 to this bit sets the DIO0 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "Writing 1 to this bit sets the DIO1 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "Writing 1 to this bit sets the DIO2 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "Writing 1 to this bit sets the DIO3 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "Writing 1 to this bit sets the DIO4 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "Writing 1 to this bit sets the DIO5 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "Writing 1 to this bit sets the DIO6 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "Writing 1 to this bit sets the DIO7 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "Writing 1 to this bit sets the DIO8 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "Writing 1 to this bit sets the DIO9 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "Writing 1 to this bit sets the DIO10 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "Writing 1 to this bit sets the DIO11 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "Writing 1 to this bit sets the DIO12 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "Writing 1 to this bit sets the DIO13 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "Writing 1 to this bit sets the DIO14 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "Writing 1 to this bit sets the DIO15 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "Writing 1 to this bit sets the DIO16 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "Writing 1 to this bit sets the DIO17 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "Writing 1 to this bit sets the DIO18 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "Writing 1 to this bit sets the DIO19 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "Writing 1 to this bit sets the DIO20 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "Writing 1 to this bit sets the DIO21 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "Writing 1 to this bit sets the DIO22 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "Writing 1 to this bit sets the DIO23 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "Writing 1 to this bit sets the DIO24 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "Writing 1 to this bit sets the DIO25 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "Writing 1 to this bit sets the DIO26 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "Writing 1 to this bit sets the DIO27 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "Writing 1 to this bit sets the DIO28 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "Writing 1 to this bit sets the DIO29 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "Writing 1 to this bit sets the DIO30 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "Writing 1 to this bit sets the DIO31 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DOECLR31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DOECLR31_0", "Data output enable clear 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "Writing 1 to this bit clears the DIO0 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "Writing 1 to this bit clears the DIO1 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "Writing 1 to this bit clears the DIO2 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "Writing 1 to this bit clears the DIO3 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "Writing 1 to this bit clears the DIO4 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "Writing 1 to this bit clears the DIO5 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "Writing 1 to this bit clears the DIO6 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "Writing 1 to this bit clears the DIO7 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "Writing 1 to this bit clears the DIO8 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "Writing 1 to this bit clears the DIO9 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "Writing 1 to this bit clears the DIO10 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "Writing 1 to this bit clears the DIO11 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "Writing 1 to this bit clears the DIO12 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "Writing 1 to this bit clears the DIO13 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "Writing 1 to this bit clears the DIO14 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "Writing 1 to this bit clears the DIO15 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "Writing 1 to this bit clears the DIO16 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "Writing 1 to this bit clears the DIO17 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "Writing 1 to this bit clears the DIO18 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "Writing 1 to this bit clears the DIO19 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "Writing 1 to this bit clears the DIO20 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "Writing 1 to this bit clears the DIO21 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "Writing 1 to this bit clears the DIO22 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "Writing 1 to this bit clears the DIO23 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "Writing 1 to this bit clears the DIO24 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "Writing 1 to this bit clears the DIO25 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "Writing 1 to this bit clears the DIO26 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "Writing 1 to this bit clears the DIO27 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "Writing 1 to this bit clears the DIO28 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "Writing 1 to this bit clears the DIO29 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "Writing 1 to this bit clears the DIO30 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "Writing 1 to this bit clears the DIO31 bit in the DOE31_0 register. Writing 0 has no effect.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DIN3_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN3_0", "Data input 3 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "This bit reads the data input value of DIO0.")
        self.DIO1 = BitField(self, 0x00000100, "DIO1", "This bit reads the data input value of DIO1.")
        self.DIO2 = BitField(self, 0x00010000, "DIO2", "This bit reads the data input value of DIO2.")
        self.DIO3 = BitField(self, 0x01000000, "DIO3", "This bit reads the data input value of DIO3.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DIN7_4(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN7_4", "Data input 7 to 4")
        self.DIO4 = BitField(self, 0x00000001, "DIO4", "This bit reads the data input value of DIO4.")
        self.DIO5 = BitField(self, 0x00000100, "DIO5", "This bit reads the data input value of DIO5.")
        self.DIO6 = BitField(self, 0x00010000, "DIO6", "This bit reads the data input value of DIO6.")
        self.DIO7 = BitField(self, 0x01000000, "DIO7", "This bit reads the data input value of DIO7.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DIN11_8(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN11_8", "Data input 11 to 8")
        self.DIO8 = BitField(self, 0x00000001, "DIO8", "This bit reads the data input value of DIO8.")
        self.DIO9 = BitField(self, 0x00000100, "DIO9", "This bit reads the data input value of DIO9.")
        self.DIO10 = BitField(self, 0x00010000, "DIO10", "This bit reads the data input value of DIO10.")
        self.DIO11 = BitField(self, 0x01000000, "DIO11", "This bit reads the data input value of DIO11.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DIN15_12(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN15_12", "Data input 15 to 12")
        self.DIO12 = BitField(self, 0x00000001, "DIO12", "This bit reads the data input value of DIO12.")
        self.DIO13 = BitField(self, 0x00000100, "DIO13", "This bit reads the data input value of DIO13.")
        self.DIO14 = BitField(self, 0x00010000, "DIO14", "This bit reads the data input value of DIO14.")
        self.DIO15 = BitField(self, 0x01000000, "DIO15", "This bit reads the data input value of DIO15.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DIN19_16(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN19_16", "Data input 19 to 16")
        self.DIO16 = BitField(self, 0x00000001, "DIO16", "This bit reads the data input value of DIO16.")
        self.DIO17 = BitField(self, 0x00000100, "DIO17", "This bit reads the data input value of DIO17.")
        self.DIO18 = BitField(self, 0x00010000, "DIO18", "This bit reads the data input value of DIO18.")
        self.DIO19 = BitField(self, 0x01000000, "DIO19", "This bit reads the data input value of DIO19.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DIN23_20(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN23_20", "Data input 23 to 20")
        self.DIO20 = BitField(self, 0x00000001, "DIO20", "This bit reads the data input value of DIO20.")
        self.DIO21 = BitField(self, 0x00000100, "DIO21", "This bit reads the data input value of DIO21.")
        self.DIO22 = BitField(self, 0x00010000, "DIO22", "This bit reads the data input value of DIO22.")
        self.DIO23 = BitField(self, 0x01000000, "DIO23", "This bit reads the data input value of DIO23.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DIN27_24(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN27_24", "Data input 27 to 24")
        self.DIO24 = BitField(self, 0x00000001, "DIO24", "This bit reads the data input value of DIO24.")
        self.DIO25 = BitField(self, 0x00000100, "DIO25", "This bit reads the data input value of DIO25.")
        self.DIO26 = BitField(self, 0x00010000, "DIO26", "This bit reads the data input value of DIO26.")
        self.DIO27 = BitField(self, 0x01000000, "DIO27", "This bit reads the data input value of DIO27.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DIN31_28(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN31_28", "Data input 31 to 28")
        self.DIO28 = BitField(self, 0x00000001, "DIO28", "This bit reads the data input value of DIO28.")
        self.DIO29 = BitField(self, 0x00000100, "DIO29", "This bit reads the data input value of DIO29.")
        self.DIO30 = BitField(self, 0x00010000, "DIO30", "This bit reads the data input value of DIO30.")
        self.DIO31 = BitField(self, 0x01000000, "DIO31", "This bit reads the data input value of DIO31.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_DIN31_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DIN31_0", "Data input 31 to 0")
        self.DIO0 = BitField(self, 0x00000001, "DIO0", "This bit reads the data input value of DIO0.")
        self.DIO1 = BitField(self, 0x00000002, "DIO1", "This bit reads the data input value of DIO1.")
        self.DIO2 = BitField(self, 0x00000004, "DIO2", "This bit reads the data input value of DIO2.")
        self.DIO3 = BitField(self, 0x00000008, "DIO3", "This bit reads the data input value of DIO3.")
        self.DIO4 = BitField(self, 0x00000010, "DIO4", "This bit reads the data input value of DIO4.")
        self.DIO5 = BitField(self, 0x00000020, "DIO5", "This bit reads the data input value of DIO5.")
        self.DIO6 = BitField(self, 0x00000040, "DIO6", "This bit reads the data input value of DIO6.")
        self.DIO7 = BitField(self, 0x00000080, "DIO7", "This bit reads the data input value of DIO7.")
        self.DIO8 = BitField(self, 0x00000100, "DIO8", "This bit reads the data input value of DIO8.")
        self.DIO9 = BitField(self, 0x00000200, "DIO9", "This bit reads the data input value of DIO9.")
        self.DIO10 = BitField(self, 0x00000400, "DIO10", "This bit reads the data input value of DIO10.")
        self.DIO11 = BitField(self, 0x00000800, "DIO11", "This bit reads the data input value of DIO11.")
        self.DIO12 = BitField(self, 0x00001000, "DIO12", "This bit reads the data input value of DIO12.")
        self.DIO13 = BitField(self, 0x00002000, "DIO13", "This bit reads the data input value of DIO13.")
        self.DIO14 = BitField(self, 0x00004000, "DIO14", "This bit reads the data input value of DIO14.")
        self.DIO15 = BitField(self, 0x00008000, "DIO15", "This bit reads the data input value of DIO15.")
        self.DIO16 = BitField(self, 0x00010000, "DIO16", "This bit reads the data input value of DIO16.")
        self.DIO17 = BitField(self, 0x00020000, "DIO17", "This bit reads the data input value of DIO17.")
        self.DIO18 = BitField(self, 0x00040000, "DIO18", "This bit reads the data input value of DIO18.")
        self.DIO19 = BitField(self, 0x00080000, "DIO19", "This bit reads the data input value of DIO19.")
        self.DIO20 = BitField(self, 0x00100000, "DIO20", "This bit reads the data input value of DIO20.")
        self.DIO21 = BitField(self, 0x00200000, "DIO21", "This bit reads the data input value of DIO21.")
        self.DIO22 = BitField(self, 0x00400000, "DIO22", "This bit reads the data input value of DIO22.")
        self.DIO23 = BitField(self, 0x00800000, "DIO23", "This bit reads the data input value of DIO23.")
        self.DIO24 = BitField(self, 0x01000000, "DIO24", "This bit reads the data input value of DIO24.")
        self.DIO25 = BitField(self, 0x02000000, "DIO25", "This bit reads the data input value of DIO25.")
        self.DIO26 = BitField(self, 0x04000000, "DIO26", "This bit reads the data input value of DIO26.")
        self.DIO27 = BitField(self, 0x08000000, "DIO27", "This bit reads the data input value of DIO27.")
        self.DIO28 = BitField(self, 0x10000000, "DIO28", "This bit reads the data input value of DIO28.")
        self.DIO29 = BitField(self, 0x20000000, "DIO29", "This bit reads the data input value of DIO29.")
        self.DIO30 = BitField(self, 0x40000000, "DIO30", "This bit reads the data input value of DIO30.")
        self.DIO31 = BitField(self, 0x80000000, "DIO31", "This bit reads the data input value of DIO31.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_POLARITY15_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "POLARITY15_0", "Polarity 15 to 0")
        self.DIO0 = BitField(self, 0x00000003, "DIO0", "Enables and configures edge detection polarity for DIO0.")
        self.DIO1 = BitField(self, 0x0000000C, "DIO1", "Enables and configures edge detection polarity for DIO1.")
        self.DIO2 = BitField(self, 0x00000030, "DIO2", "Enables and configures edge detection polarity for DIO2.")
        self.DIO3 = BitField(self, 0x000000C0, "DIO3", "Enables and configures edge detection polarity for DIO3.")
        self.DIO4 = BitField(self, 0x00000300, "DIO4", "Enables and configures edge detection polarity for DIO4.")
        self.DIO5 = BitField(self, 0x00000C00, "DIO5", "Enables and configures edge detection polarity for DIO5.")
        self.DIO6 = BitField(self, 0x00003000, "DIO6", "Enables and configures edge detection polarity for DIO6.")
        self.DIO7 = BitField(self, 0x0000C000, "DIO7", "Enables and configures edge detection polarity for DIO7.")
        self.DIO8 = BitField(self, 0x00030000, "DIO8", "Enables and configures edge detection polarity for DIO8.")
        self.DIO9 = BitField(self, 0x000C0000, "DIO9", "Enables and configures edge detection polarity for DIO9.")
        self.DIO10 = BitField(self, 0x00300000, "DIO10", "Enables and configures edge detection polarity for DIO10.")
        self.DIO11 = BitField(self, 0x00C00000, "DIO11", "Enables and configures edge detection polarity for DIO11.")
        self.DIO12 = BitField(self, 0x03000000, "DIO12", "Enables and configures edge detection polarity for DIO12.")
        self.DIO13 = BitField(self, 0x0C000000, "DIO13", "Enables and configures edge detection polarity for DIO13.")
        self.DIO14 = BitField(self, 0x30000000, "DIO14", "Enables and configures edge detection polarity for DIO14.")
        self.DIO15 = BitField(self, 0xC0000000, "DIO15", "Enables and configures edge detection polarity for DIO15.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_POLARITY31_16(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "POLARITY31_16", "Polarity 31 to 16")
        self.DIO16 = BitField(self, 0x00000003, "DIO16", "Enables and configures edge detection polarity for DIO16.")
        self.DIO17 = BitField(self, 0x0000000C, "DIO17", "Enables and configures edge detection polarity for DIO17.")
        self.DIO18 = BitField(self, 0x00000030, "DIO18", "Enables and configures edge detection polarity for DIO18.")
        self.DIO19 = BitField(self, 0x000000C0, "DIO19", "Enables and configures edge detection polarity for DIO19.")
        self.DIO20 = BitField(self, 0x00000300, "DIO20", "Enables and configures edge detection polarity for DIO20.")
        self.DIO21 = BitField(self, 0x00000C00, "DIO21", "Enables and configures edge detection polarity for DIO21.")
        self.DIO22 = BitField(self, 0x00003000, "DIO22", "Enables and configures edge detection polarity for DIO22.")
        self.DIO23 = BitField(self, 0x0000C000, "DIO23", "Enables and configures edge detection polarity for DIO23.")
        self.DIO24 = BitField(self, 0x00030000, "DIO24", "Enables and configures edge detection polarity for DIO24.")
        self.DIO25 = BitField(self, 0x000C0000, "DIO25", "Enables and configures edge detection polarity for DIO25.")
        self.DIO26 = BitField(self, 0x00300000, "DIO26", "Enables and configures edge detection polarity for DIO26.")
        self.DIO27 = BitField(self, 0x00C00000, "DIO27", "Enables and configures edge detection polarity for DIO27.")
        self.DIO28 = BitField(self, 0x03000000, "DIO28", "Enables and configures edge detection polarity for DIO28.")
        self.DIO29 = BitField(self, 0x0C000000, "DIO29", "Enables and configures edge detection polarity for DIO29.")
        self.DIO30 = BitField(self, 0x30000000, "DIO30", "Enables and configures edge detection polarity for DIO30.")
        self.DIO31 = BitField(self, 0xC0000000, "DIO31", "Enables and configures edge detection polarity for DIO31.")
        self.DIO = Subscriptor(self, "DIO{}")

class SA_GPIOA_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL", "FAST WAKE GLOBAL EN")
        self.FASTWAKEONLY = BitField(self, 0x00000001, "FASTWAKEONLY", "FASTWAKEONLY for the global control of fastwake")

class SA_GPIOA_FASTWAKE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FASTWAKE", "FAST WAKE ENABLE")
        self.DIN0 = BitField(self, 0x00000001, "DIN0", "Enable fastwake feature for DIN0")
        self.DIN1 = BitField(self, 0x00000002, "DIN1", "Enable fastwake feature for DIN1")
        self.DIN2 = BitField(self, 0x00000004, "DIN2", "Enable fastwake feature for DIN2")
        self.DIN3 = BitField(self, 0x00000008, "DIN3", "Enable fastwake feature for DIN3")
        self.DIN4 = BitField(self, 0x00000010, "DIN4", "Enable fastwake feature for DIN4")
        self.DIN5 = BitField(self, 0x00000020, "DIN5", "Enable fastwake feature for DIN5")
        self.DIN6 = BitField(self, 0x00000040, "DIN6", "Enable fastwake feature for DIN6")
        self.DIN7 = BitField(self, 0x00000080, "DIN7", "Enable fastwake feature for DIN7")
        self.DIN8 = BitField(self, 0x00000100, "DIN8", "Enable fastwake feature for DIN8")
        self.DIN9 = BitField(self, 0x00000200, "DIN9", "Enable fastwake feature for DIN9")
        self.DIN10 = BitField(self, 0x00000400, "DIN10", "Enable fastwake feature for DIN10")
        self.DIN11 = BitField(self, 0x00000800, "DIN11", "Enable fastwake feature for DIN11")
        self.DIN12 = BitField(self, 0x00001000, "DIN12", "Enable fastwake feature for DIN12")
        self.DIN13 = BitField(self, 0x00002000, "DIN13", "Enable fastwake feature for DIN13")
        self.DIN14 = BitField(self, 0x00004000, "DIN14", "Enable fastwake feature for DIN14")
        self.DIN15 = BitField(self, 0x00008000, "DIN15", "Enable fastwake feature for DIN15")
        self.DIN16 = BitField(self, 0x00010000, "DIN16", "Enable fastwake feature for DIN16")
        self.DIN17 = BitField(self, 0x00020000, "DIN17", "Enable fastwake feature for DIN17")
        self.DIN18 = BitField(self, 0x00040000, "DIN18", "Enable fastwake feature for DIN18")
        self.DIN19 = BitField(self, 0x00080000, "DIN19", "Enable fastwake feature for DIN19")
        self.DIN20 = BitField(self, 0x00100000, "DIN20", "Enable fastwake feature for DIN20")
        self.DIN21 = BitField(self, 0x00200000, "DIN21", "Enable fastwake feature for DIN21")
        self.DIN22 = BitField(self, 0x00400000, "DIN22", "Enable fastwake feature for DIN22")
        self.DIN23 = BitField(self, 0x00800000, "DIN23", "Enable fastwake feature for DIN23")
        self.DIN24 = BitField(self, 0x01000000, "DIN24", "Enable fastwake feature for DIN24")
        self.DIN25 = BitField(self, 0x02000000, "DIN25", "Enable fastwake feature for DIN25")
        self.DIN26 = BitField(self, 0x04000000, "DIN26", "Enable fastwake feature for DIN26")
        self.DIN27 = BitField(self, 0x08000000, "DIN27", "Enable fastwake feature for DIN27")
        self.DIN28 = BitField(self, 0x10000000, "DIN28", "Enable fastwake feature for DIN29")
        self.DIN29 = BitField(self, 0x20000000, "DIN29", "Enable fastwake feature for DIN29")
        self.DIN30 = BitField(self, 0x40000000, "DIN30", "Enable fastwake feature for DIN30")
        self.DIN31 = BitField(self, 0x80000000, "DIN31", "Enable fastwake feature for DIN31")
        self.DIN = Subscriptor(self, "DIN{}")

class SA_GPIOA_SUB0CFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SUB0CFG", "Subscriber 0 configuration")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "This bit is used to enable subscriber 0 event.")
        self.OUTPOLICY = BitField(self, 0x00000300, "OUTPOLICY", "These bits configure the output policy for subscriber 0 event.")
        self.INDEX = BitField(self, 0x000F0000, "INDEX", "Indicates the specific bit among lower 16 bits that is targeted by the subscriber action")

class SA_GPIOA_FILTEREN15_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FILTEREN15_0", "Filter Enable 15 to 0")
        self.DIN0 = BitField(self, 0x00000003, "DIN0", "Programmable counter length of digital glitch filter for DIN0")
        self.DIN1 = BitField(self, 0x0000000C, "DIN1", "Programmable counter length of digital glitch filter for DIN1")
        self.DIN2 = BitField(self, 0x00000030, "DIN2", "Programmable counter length of digital glitch filter for DIN2")
        self.DIN3 = BitField(self, 0x000000C0, "DIN3", "Programmable counter length of digital glitch filter for DIN3")
        self.DIN4 = BitField(self, 0x00000300, "DIN4", "Programmable counter length of digital glitch filter for DIN4")
        self.DIN5 = BitField(self, 0x00000C00, "DIN5", "Programmable counter length of digital glitch filter for DIN5")
        self.DIN6 = BitField(self, 0x00003000, "DIN6", "Programmable counter length of digital glitch filter for DIN6")
        self.DIN7 = BitField(self, 0x0000C000, "DIN7", "Programmable counter length of digital glitch filter for DIN7")
        self.DIN8 = BitField(self, 0x00030000, "DIN8", "Programmable counter length of digital glitch filter for DIN8")
        self.DIN9 = BitField(self, 0x000C0000, "DIN9", "Programmable counter length of digital glitch filter for DIN9")
        self.DIN10 = BitField(self, 0x00300000, "DIN10", "Programmable counter length of digital glitch filter for DIN10")
        self.DIN11 = BitField(self, 0x00C00000, "DIN11", "Programmable counter length of digital glitch filter for DIN11")
        self.DIN12 = BitField(self, 0x03000000, "DIN12", "Programmable counter length of digital glitch filter for DIN12")
        self.DIN13 = BitField(self, 0x0C000000, "DIN13", "Programmable counter length of digital glitch filter for DIN13")
        self.DIN14 = BitField(self, 0x30000000, "DIN14", "Programmable counter length of digital glitch filter for DIN14")
        self.DIN15 = BitField(self, 0xC0000000, "DIN15", "Programmable counter length of digital glitch filter for DIN15")
        self.DIN = Subscriptor(self, "DIN{}")

class SA_GPIOA_FILTEREN31_16(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FILTEREN31_16", "Filter Enable 31 to 16")
        self.DIN16 = BitField(self, 0x00000003, "DIN16", "Programmable counter length of digital glitch filter for DIN16")
        self.DIN17 = BitField(self, 0x0000000C, "DIN17", "Programmable counter length of digital glitch filter for DIN17")
        self.DIN18 = BitField(self, 0x00000030, "DIN18", "Programmable counter length of digital glitch filter for DIN18")
        self.DIN19 = BitField(self, 0x000000C0, "DIN19", "Programmable counter length of digital glitch filter for DIN19")
        self.DIN20 = BitField(self, 0x00000300, "DIN20", "Programmable counter length of digital glitch filter for DIN20")
        self.DIN21 = BitField(self, 0x00000C00, "DIN21", "Programmable counter length of digital glitch filter for DIN21")
        self.DIN22 = BitField(self, 0x00003000, "DIN22", "Programmable counter length of digital glitch filter for DIN22")
        self.DIN23 = BitField(self, 0x0000C000, "DIN23", "Programmable counter length of digital glitch filter for DIN23")
        self.DIN24 = BitField(self, 0x00030000, "DIN24", "Programmable counter length of digital glitch filter for DIN24")
        self.DIN25 = BitField(self, 0x000C0000, "DIN25", "Programmable counter length of digital glitch filter for DIN25")
        self.DIN26 = BitField(self, 0x00300000, "DIN26", "Programmable counter length of digital glitch filter for DIN26")
        self.DIN27 = BitField(self, 0x00C00000, "DIN27", "Programmable counter length of digital glitch filter for DIN27")
        self.DIN28 = BitField(self, 0x03000000, "DIN28", "Programmable counter length of digital glitch filter for DIN28")
        self.DIN29 = BitField(self, 0x0C000000, "DIN29", "Programmable counter length of digital glitch filter for DIN29")
        self.DIN30 = BitField(self, 0x30000000, "DIN30", "Programmable counter length of digital glitch filter for DIN30")
        self.DIN31 = BitField(self, 0xC0000000, "DIN31", "Programmable counter length of digital glitch filter for DIN31")
        self.DIN = Subscriptor(self, "DIN{}")

class SA_GPIOA_DMAMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DMAMASK", "DMA Write MASK")
        self.DOUT0 = BitField(self, 0x00000001, "DOUT0", "DMA is allowed to modify DOUT0")
        self.DOUT1 = BitField(self, 0x00000002, "DOUT1", "DMA is allowed to modify DOUT1")
        self.DOUT2 = BitField(self, 0x00000004, "DOUT2", "DMA is allowed to modify DOUT2")
        self.DOUT3 = BitField(self, 0x00000008, "DOUT3", "DMA is allowed to modify DOUT3")
        self.DOUT4 = BitField(self, 0x00000010, "DOUT4", "DMA is allowed to modify DOUT4")
        self.DOUT5 = BitField(self, 0x00000020, "DOUT5", "DMA is allowed to modify DOUT5")
        self.DOUT6 = BitField(self, 0x00000040, "DOUT6", "DMA is allowed to modify DOUT6")
        self.DOUT7 = BitField(self, 0x00000080, "DOUT7", "DMA is allowed to modify DOUT7")
        self.DOUT8 = BitField(self, 0x00000100, "DOUT8", "DMA is allowed to modify DOUT8")
        self.DOUT9 = BitField(self, 0x00000200, "DOUT9", "DMA is allowed to modify DOUT9")
        self.DOUT10 = BitField(self, 0x00000400, "DOUT10", "DMA is allowed to modify DOUT10")
        self.DOUT11 = BitField(self, 0x00000800, "DOUT11", "DMA is allowed to modify DOUT11")
        self.DOUT12 = BitField(self, 0x00001000, "DOUT12", "DMA is allowed to modify DOUT12")
        self.DOUT13 = BitField(self, 0x00002000, "DOUT13", "DMA is allowed to modify DOUT13")
        self.DOUT14 = BitField(self, 0x00004000, "DOUT14", "DMA is allowed to modify DOUT14")
        self.DOUT15 = BitField(self, 0x00008000, "DOUT15", "DMA is allowed to modify DOUT15")
        self.DOUT16 = BitField(self, 0x00010000, "DOUT16", "DMA is allowed to modify DOUT16")
        self.DOUT17 = BitField(self, 0x00020000, "DOUT17", "DMA is allowed to modify DOUT17")
        self.DOUT18 = BitField(self, 0x00040000, "DOUT18", "DMA is allowed to modify DOUT18")
        self.DOUT19 = BitField(self, 0x00080000, "DOUT19", "DMA is allowed to modify DOUT19")
        self.DOUT20 = BitField(self, 0x00100000, "DOUT20", "DMA is allowed to modify DOUT20")
        self.DOUT21 = BitField(self, 0x00200000, "DOUT21", "DMA is allowed to modify DOUT21")
        self.DOUT22 = BitField(self, 0x00400000, "DOUT22", "DMA is allowed to modify DOUT22")
        self.DOUT23 = BitField(self, 0x00800000, "DOUT23", "DMA is allowed to modify DOUT23")
        self.DOUT24 = BitField(self, 0x01000000, "DOUT24", "DMA is allowed to modify DOUT24")
        self.DOUT25 = BitField(self, 0x02000000, "DOUT25", "DMA is allowed to modify DOUT25")
        self.DOUT26 = BitField(self, 0x04000000, "DOUT26", "DMA is allowed to modify DOUT26")
        self.DOUT27 = BitField(self, 0x08000000, "DOUT27", "DMA is allowed to modify DOUT27")
        self.DOUT28 = BitField(self, 0x10000000, "DOUT28", "DMA is allowed to modify DOUT28")
        self.DOUT29 = BitField(self, 0x20000000, "DOUT29", "DMA is allowed to modify DOUT29")
        self.DOUT30 = BitField(self, 0x40000000, "DOUT30", "DMA is allowed to modify DOUT30")
        self.DOUT31 = BitField(self, 0x80000000, "DOUT31", "DMA is allowed to modify DOUT31")
        self.DOUT = Subscriptor(self, "DOUT{}")

class SA_GPIOA_SUB1CFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SUB1CFG", "Subscriber 1 configuration")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "This bit is used to enable subscriber 1 event.")
        self.OUTPOLICY = BitField(self, 0x00000300, "OUTPOLICY", "These bits configure the output policy for subscriber 1 event.")
        self.INDEX = BitField(self, 0x000F0000, "INDEX", "indicates the specific bit in the upper 16 bits that is targeted by the subscriber action")

class SA_GPIOA(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_GPIOA_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_GPIOA_FSUB_1(self, 0x404)
        self.FPUB_0 = SA_GPIOA_FPUB_0(self, 0x444)
        self.FPUB_1 = SA_GPIOA_FPUB_1(self, 0x448)
        self.PWREN = SA_GPIOA_PWREN(self, 0x800)
        self.RSTCTL = SA_GPIOA_RSTCTL(self, 0x804)
        self.STAT = SA_GPIOA_STAT(self, 0x814)
        self.CLKOVR = SA_GPIOA_CLKOVR(self, 0x1010)
        self.PDBGCTL = SA_GPIOA_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_GPIOA_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_GPIOA_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_GPIOA_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_GPIOA_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_GPIOA_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_GPIOA_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_GPIOA_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_GPIOA_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_GPIOA_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_GPIOA_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_GPIOA_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_GPIOA_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_GPIOA_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_GPIOA_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_GPIOA_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_GPIOA_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_GPIOA_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_GPIOA_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_GPIOA_EVT_MODE(self, 0x10E0)
        self.DESC = SA_GPIOA_DESC(self, 0x10FC)
        self.DOUT3_0 = SA_GPIOA_DOUT3_0(self, 0x1200)
        self.DOUT7_4 = SA_GPIOA_DOUT7_4(self, 0x1204)
        self.DOUT11_8 = SA_GPIOA_DOUT11_8(self, 0x1208)
        self.DOUT15_12 = SA_GPIOA_DOUT15_12(self, 0x120C)
        self.DOUT19_16 = SA_GPIOA_DOUT19_16(self, 0x1210)
        self.DOUT23_20 = SA_GPIOA_DOUT23_20(self, 0x1214)
        self.DOUT27_24 = SA_GPIOA_DOUT27_24(self, 0x1218)
        self.DOUT31_28 = SA_GPIOA_DOUT31_28(self, 0x121C)
        self.DOUT31_0 = SA_GPIOA_DOUT31_0(self, 0x1280)
        self.DOUTSET31_0 = SA_GPIOA_DOUTSET31_0(self, 0x1290)
        self.DOUTCLR31_0 = SA_GPIOA_DOUTCLR31_0(self, 0x12A0)
        self.DOUTTGL31_0 = SA_GPIOA_DOUTTGL31_0(self, 0x12B0)
        self.DOE31_0 = SA_GPIOA_DOE31_0(self, 0x12C0)
        self.DOESET31_0 = SA_GPIOA_DOESET31_0(self, 0x12D0)
        self.DOECLR31_0 = SA_GPIOA_DOECLR31_0(self, 0x12E0)
        self.DIN3_0 = SA_GPIOA_DIN3_0(self, 0x1300)
        self.DIN7_4 = SA_GPIOA_DIN7_4(self, 0x1304)
        self.DIN11_8 = SA_GPIOA_DIN11_8(self, 0x1308)
        self.DIN15_12 = SA_GPIOA_DIN15_12(self, 0x130C)
        self.DIN19_16 = SA_GPIOA_DIN19_16(self, 0x1310)
        self.DIN23_20 = SA_GPIOA_DIN23_20(self, 0x1314)
        self.DIN27_24 = SA_GPIOA_DIN27_24(self, 0x1318)
        self.DIN31_28 = SA_GPIOA_DIN31_28(self, 0x131C)
        self.DIN31_0 = SA_GPIOA_DIN31_0(self, 0x1380)
        self.POLARITY15_0 = SA_GPIOA_POLARITY15_0(self, 0x1390)
        self.POLARITY31_16 = SA_GPIOA_POLARITY31_16(self, 0x13A0)
        self.CTL = SA_GPIOA_CTL(self, 0x1400)
        self.FASTWAKE = SA_GPIOA_FASTWAKE(self, 0x1404)
        self.SUB0CFG = SA_GPIOA_SUB0CFG(self, 0x1500)
        self.FILTEREN15_0 = SA_GPIOA_FILTEREN15_0(self, 0x1508)
        self.FILTEREN31_16 = SA_GPIOA_FILTEREN31_16(self, 0x150C)
        self.DMAMASK = SA_GPIOA_DMAMASK(self, 0x1510)
        self.SUB1CFG = SA_GPIOA_SUB1CFG(self, 0x1520)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.FSUB = Subscriptor(self, "FSUB_{}")
        self.SUBCFG = Subscriptor(self, "SUB{}CFG")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.FPUB = Subscriptor(self, "FPUB_{}")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

GPIOA = SA_GPIOA(0x400A0000, "GPIOA")

class SA_TRNG_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_TRNG_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_TRNG_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_TRNG_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_TRNG_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.IRQ_HEALTH_FAIL = BitField(self, 0x00000001, "IRQ_HEALTH_FAIL", "Mask for IRQ_HEALTH_FAIL. Indicates that a health test has failed.")
        self.IRQ_CAPTURED_RDY = BitField(self, 0x00000008, "IRQ_CAPTURED_RDY", "Mask for IRQ_CAPTURED_RDY. Indicates to the CPU that the Captured Word is ready to be read.")
        self.IRQ_CMD_DONE = BitField(self, 0x00000004, "IRQ_CMD_DONE", "Mask for IRQ_CMD_DONE. Indicates that a command has finished")
        self.IRQ_CMD_FAIL = BitField(self, 0x00000002, "IRQ_CMD_FAIL", "Masked interrupt source for IRQ_CMD_FAIL. Indicates that the just issued command/mode has been rejected.")

class SA_TRNG_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.IRQ_CAPTURED_RDY = BitField(self, 0x00000008, "IRQ_CAPTURED_RDY", "Indicates to the CPU that the Captured Word is ready to be read. Reading the IIDX will clear this interrupt.")
        self.IRQ_HEALTH_FAIL = BitField(self, 0x00000001, "IRQ_HEALTH_FAIL", "Indicates to the CPU that any of the health tests have failed. Reading the IIDX will clear this interrupt.")
        self.IRQ_CMD_DONE = BitField(self, 0x00000004, "IRQ_CMD_DONE", "Raw interrupt source for IRQ_CMD_DONE. Indicates that the issued command/mode has completed.")
        self.IRQ_CMD_FAIL = BitField(self, 0x00000002, "IRQ_CMD_FAIL", "Masked interrupt source for IRQ_CMD_FAIL. Indicates that the just issued command/mode has been rejected.")

class SA_TRNG_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.IRQ_CAPTURED_RDY = BitField(self, 0x00000008, "IRQ_CAPTURED_RDY", "Masked interrupt result for CAPTURED_READY. Indicates to the CPU that the Captured Word is ready to be read. Reading the IIDX will clear this interrupt.")
        self.IRQ_HEALTH_FAIL = BitField(self, 0x00000001, "IRQ_HEALTH_FAIL", "Masked interrupt result for HEALTH_FAIL. Indicates to the CPU that any of the health tests have failed for the latest 1024-bit window.")
        self.IRQ_CMD_DONE = BitField(self, 0x00000004, "IRQ_CMD_DONE", "Masked interrupt source for IRQ_CMD_DONE. Indicates that the issued command/mode has completed.")
        self.IRQ_CMD_FAIL = BitField(self, 0x00000002, "IRQ_CMD_FAIL", "Masked interrupt source for IRQ_CMD_FAIL. Indicates that the just issued command/mode has been rejected.")

class SA_TRNG_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.IRQ_CAPTURED_RDY = BitField(self, 0x00000008, "IRQ_CAPTURED_RDY", "Indicates to the CPU that the Captured Word is ready to be read. Reading the IIDX or DATA_CAPTURE registers will clear this interrupt.")
        self.IRQ_HEALTH_FAIL = BitField(self, 0x00000001, "IRQ_HEALTH_FAIL", "Indicates to the CPU that any of the health tests have failed. Reading the IIDX or DATA_CAPTURE registers will clear this interrupt.")
        self.IRQ_CMD_DONE = BitField(self, 0x00000004, "IRQ_CMD_DONE", "Write to turn on CMD_DONE IRQ. Indicates that the last issued TRNG command has finished.")
        self.IRQ_CMD_FAIL = BitField(self, 0x00000002, "IRQ_CMD_FAIL", "Masked interrupt source for IRQ_CMD_FAIL. Indicates that the just issued command/mode has been rejected.")

class SA_TRNG_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.IRQ_CAPTURED_RDY = BitField(self, 0x00000008, "IRQ_CAPTURED_RDY", "Indicates to the CPU that the Captured Word is ready to be read. Reading the IIDX or DATA_CAPTURE registers will clear this interrupt.")
        self.IRQ_HEALTH_FAIL = BitField(self, 0x00000001, "IRQ_HEALTH_FAIL", "Indicates to the CPU that any of the health tests have failed. Reading the IIDX or DATA_CAPTURE registers will clear this interrupt.")
        self.IRQ_CMD_DONE = BitField(self, 0x00000004, "IRQ_CMD_DONE", "Write to turn off CMD_DONE IRQ. Indicates that the last issued TRNG command has finished.")
        self.IRQ_CMD_FAIL = BitField(self, 0x00000002, "IRQ_CMD_FAIL", "Masked interrupt source for IRQ_CMD_FAIL. Indicates that the just issued command/mode has been rejected.")

class SA_TRNG_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x5110000, "DESC", "Module descriptions")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module Identifier - An internal TI page has been created to request unique module IDs")

class SA_TRNG_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x140000, "CTL", "Controls the command and decimation rate")
        self.DECIM_RATE = BitField(self, 0x00000700, "DECIM_RATE", "Set decimation rate. Decimate by n. 0x0 = Decimation by 1 (no decimation) 0x1 = Decimation by 2 (Skip every other sample) 0x7 = Decimation by 8 (Take every 8th sample)")
        self.PWRUP_CLKDIV = BitField(self, 0x00010000, "PWRUP_CLKDIV", "When '1', the powerup sequence will take twice as long (i.e., clock frequency halved)")
        self.PWRUP_PCHRG_CFG = BitField(self, 0x00060000, "PWRUP_PCHRG_CFG", "Configure PCHARGE sequence length. b00 = Disabled b01 = 20 us PCHARGE b10 = 30 us PCHARGE (default) b11 = 40 us PCHARGE")
        self.PWRUP_PSTART_CFG = BitField(self, 0x00180000, "PWRUP_PSTART_CFG", "Configure pusle startup sequence length. b00 = Disabled b01 = rise at 10us, fall at 50us b10 = rise at 10us, fall at 70us (default) b11 = rise at 10us, fall at 90us")
        self.CMD = BitField(self, 0x00000003, "CMD", "Sets the TRNG mode through a command. The mode will not be updated until the previous command is done, as indicated by IRQ_CMD_DONE.. 00 --&gt; OFF 01 --&gt; PWRUP_DIG 10 --&gt; PWRUP_ANA 11 --&gt; NORM_FUNC")

class SA_TRNG_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status register that informs health test results and last issued command")
        self.ADAP_FAIL = BitField(self, 0x00000001, "ADAP_FAIL", "Indicates that the Adaptive Proportion Test (1,2,3, or 4-bit counters) failed by having too many or too few counted samples in the last 1024 bit window.")
        self.ISSUED_CMD = BitField(self, 0x00000300, "ISSUED_CMD", "Indicates the last accepted command that is issued to the TRNG interface.. Upon writing a valid command, this register will update and the command will be in progress until CMD_DONE_IRQ is set. CMD_DONE_IRQ indicates that the state is in PWROFF, NORM_FUNC, or ERROR. These states will accept new commands. 00 --&gt; OFF 01 --&gt; PWRUP_DIG 10 --&gt; PWRUP_ANA 11 --&gt; NORM_FUNC")
        self.FSM_STATE = BitField(self, 0x000F0000, "FSM_STATE", "Current state of the front end FSM (behind a clock domain crossing).. 2 reads are REQUIRED as there is a chance of metastability when reading this States: 0000: OFF 0001: PWRUP_ES 0011: NORM_FUNC 0111: TEST_DIG 1011: TEST_ANA 1010: ERROR 0010: PWRDOWN_ES")
        self.REP_FAIL = BitField(self, 0x00000002, "REP_FAIL", "Indicates that the repetition counter test caused the most recent failure. Thus, the health count numbers are most likely not for a complete 1024-bit window.")

class SA_TRNG_DATA_CAPTURE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DATA_CAPTURE", "Captured word buffer of RNG data")
        self.BUFFER = BitField(self, 0xFFFFFFFF, "BUFFER", "Captured Data from the Decimation Block")

class SA_TRNG_TEST_RESULTS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TEST_RESULTS", "Test results from TEST_ANA and TEST_DIG")
        self.DIG_TEST = BitField(self, 0x000000FF, "DIG_TEST", "Bit 0 indicates if the first decimation rate test and health test(verifies conditioning, decimation, and captured buffer) fails and Bit 1 indicates if the second decimation test and health test fails. Bit 0 - decim_test0 (decim = 0x0) Bit 1 - decim_test1 (decim = 0x1) ...")
        self.ANA_TEST = BitField(self, 0x00000100, "ANA_TEST", "Runs through 4096 samples from an enabled entropy source and verifies that none of the health tests failed, indicating sufficient entropy was produced by the analog components")

class SA_TRNG_CLKDIVIDE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIVIDE", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_TRNG(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_TRNG_PWREN(self, 0x800)
        self.RSTCTL = SA_TRNG_RSTCTL(self, 0x804)
        self.GPRCM_STAT = SA_TRNG_GPRCM_STAT(self, 0x814)
        self.IIDX = SA_TRNG_IIDX(self, 0x1020)
        self.IMASK = SA_TRNG_IMASK(self, 0x1028)
        self.RIS = SA_TRNG_RIS(self, 0x1030)
        self.MIS = SA_TRNG_MIS(self, 0x1038)
        self.ISET = SA_TRNG_ISET(self, 0x1040)
        self.ICLR = SA_TRNG_ICLR(self, 0x1048)
        self.DESC = SA_TRNG_DESC(self, 0x10FC)
        self.CTL = SA_TRNG_CTL(self, 0x1100)
        self.STAT = SA_TRNG_STAT(self, 0x1104)
        self.DATA_CAPTURE = SA_TRNG_DATA_CAPTURE(self, 0x1108)
        self.TEST_RESULTS = SA_TRNG_TEST_RESULTS(self, 0x110C)
        self.CLKDIVIDE = SA_TRNG_CLKDIVIDE(self, 0x1110)

TRNG = SA_TRNG(0x40444000, "TRNG")

class SA_RTC_FPUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_0", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_RTC_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_RTC_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_RTC_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_RTC_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_RTC_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")

class SA_RTC_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_RTC_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.RTCA2 = BitField(self, 0x00000008, "RTCA2", "Enable Alarm-2 interrupt")
        self.RT0PS = BitField(self, 0x00000010, "RT0PS", "Enable Prescaler-0 interrupt")
        self.RT1PS = BitField(self, 0x00000020, "RT1PS", "Enable Prescaler-1 interrupt")
        self.RTCTEV = BitField(self, 0x00000002, "RTCTEV", "Enable Time-Event interrupt")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Enable RTC-Ready interrupt")
        self.RTCA1 = BitField(self, 0x00000004, "RTCA1", "Enable Alarm-1 interrupt")
        self.RTCA = Subscriptor(self, "RTCA{}")
        self.RTPS = Subscriptor(self, "RT{}PS")

class SA_RTC_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Raw RTC-Ready interrupts status")
        self.RTCTEV = BitField(self, 0x00000002, "RTCTEV", "Raw Time-Event interrupt status")
        self.RTCA1 = BitField(self, 0x00000004, "RTCA1", "Raw Alarm-1 interrupt status")
        self.RTCA2 = BitField(self, 0x00000008, "RTCA2", "Raw Alarm-2 interrupts status")
        self.RT0PS = BitField(self, 0x00000010, "RT0PS", "Raw Prescaler-0 interrupt status")
        self.RT1PS = BitField(self, 0x00000020, "RT1PS", "Raw Prescaler-1 interrupt status")
        self.RTCA = Subscriptor(self, "RTCA{}")
        self.RTPS = Subscriptor(self, "RT{}PS")

class SA_RTC_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Masked RTC-Ready interrupt status")
        self.RTCTEV = BitField(self, 0x00000002, "RTCTEV", "Masked Time-Event interrupt status")
        self.RTCA1 = BitField(self, 0x00000004, "RTCA1", "Masked Alarm-1 interrupt status")
        self.RTCA2 = BitField(self, 0x00000008, "RTCA2", "Masked Alarm-2 interrupt status")
        self.RT0PS = BitField(self, 0x00000010, "RT0PS", "Masked Prescaler-0 interrupt status")
        self.RT1PS = BitField(self, 0x00000020, "RT1PS", "Masked Prescaler-1 interrupt status")
        self.RTCA = Subscriptor(self, "RTCA{}")
        self.RTPS = Subscriptor(self, "RT{}PS")

class SA_RTC_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Set RTC-Ready interrupt")
        self.RTCTEV = BitField(self, 0x00000002, "RTCTEV", "Set Time-Event interrupt")
        self.RTCA1 = BitField(self, 0x00000004, "RTCA1", "Set Alarm-1 interrupt")
        self.RTCA2 = BitField(self, 0x00000008, "RTCA2", "Set Alarm-2 interrupt")
        self.RT0PS = BitField(self, 0x00000010, "RT0PS", "Set Prescaler-0 interrupt")
        self.RT1PS = BitField(self, 0x00000020, "RT1PS", "Set Prescaler-1 interrupt")
        self.RTCA = Subscriptor(self, "RTCA{}")
        self.RTPS = Subscriptor(self, "RT{}PS")

class SA_RTC_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Clear RTC-Ready interrupt")
        self.RTCTEV = BitField(self, 0x00000002, "RTCTEV", "Clear Time-Event interrupt")
        self.RTCA1 = BitField(self, 0x00000004, "RTCA1", "Clear Alarm-1 interrupt")
        self.RTCA2 = BitField(self, 0x00000008, "RTCA2", "Clear Alarm-2 interrupt")
        self.RT0PS = BitField(self, 0x00000010, "RT0PS", "Clear Prescaler-0 interrupt")
        self.RT1PS = BitField(self, 0x00000020, "RT1PS", "Clear Prescaler-1 interrupt")
        self.RTCA = Subscriptor(self, "RTCA{}")
        self.RTPS = Subscriptor(self, "RT{}PS")

class SA_RTC_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_RTC_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.RTCA2 = BitField(self, 0x00000008, "RTCA2", "Enable Alarm-2 interrupt")
        self.RT0PS = BitField(self, 0x00000010, "RT0PS", "Enable Prescaler-0 interrupt")
        self.RT1PS = BitField(self, 0x00000020, "RT1PS", "Enable Prescaler-1 interrupt")
        self.RTCTEV = BitField(self, 0x00000002, "RTCTEV", "Enable Time-Event interrupt")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Enable RTC-Ready interrupt")
        self.RTCA1 = BitField(self, 0x00000004, "RTCA1", "Enable Alarm-1 interrupt")
        self.RTCA = Subscriptor(self, "RTCA{}")
        self.RTPS = Subscriptor(self, "RT{}PS")

class SA_RTC_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Raw RTC-Ready interrupts status")
        self.RTCTEV = BitField(self, 0x00000002, "RTCTEV", "Raw Time-Event interrupt status")
        self.RTCA1 = BitField(self, 0x00000004, "RTCA1", "Raw Alarm-1 interrupt status")
        self.RTCA2 = BitField(self, 0x00000008, "RTCA2", "Raw Alarm-2 interrupts status")
        self.RT0PS = BitField(self, 0x00000010, "RT0PS", "Raw Prescaler-0 interrupt status")
        self.RT1PS = BitField(self, 0x00000020, "RT1PS", "Raw Prescaler-1 interrupt status")
        self.RTCA = Subscriptor(self, "RTCA{}")
        self.RTPS = Subscriptor(self, "RT{}PS")

class SA_RTC_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Masked RTC-Ready interrupt status")
        self.RTCTEV = BitField(self, 0x00000002, "RTCTEV", "Masked Time-Event interrupt status")
        self.RTCA1 = BitField(self, 0x00000004, "RTCA1", "Masked Alarm-1 interrupt status")
        self.RTCA2 = BitField(self, 0x00000008, "RTCA2", "Masked Alarm-2 interrupt status")
        self.RT0PS = BitField(self, 0x00000010, "RT0PS", "Masked Prescaler-0 interrupt status")
        self.RT1PS = BitField(self, 0x00000020, "RT1PS", "Masked Prescaler-1 interrupt status")
        self.RTCA = Subscriptor(self, "RTCA{}")
        self.RTPS = Subscriptor(self, "RT{}PS")

class SA_RTC_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Set RTC-Ready interrupt")
        self.RTCTEV = BitField(self, 0x00000002, "RTCTEV", "Set Time-Event interrupt")
        self.RTCA1 = BitField(self, 0x00000004, "RTCA1", "Set Alarm-1 interrupt")
        self.RTCA2 = BitField(self, 0x00000008, "RTCA2", "Set Alarm-2 interrupt")
        self.RT0PS = BitField(self, 0x00000010, "RT0PS", "Set Prescaler-0 interrupt")
        self.RT1PS = BitField(self, 0x00000020, "RT1PS", "Set Prescaler-1 interrupt")
        self.RTCA = Subscriptor(self, "RTCA{}")
        self.RTPS = Subscriptor(self, "RT{}PS")

class SA_RTC_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Clear RTC-Ready interrupt")
        self.RTCTEV = BitField(self, 0x00000002, "RTCTEV", "Clear Time-Event interrupt")
        self.RTCA1 = BitField(self, 0x00000004, "RTCA1", "Clear Alarm-1 interrupt")
        self.RTCA2 = BitField(self, 0x00000008, "RTCA2", "Clear Alarm-2 interrupt")
        self.RT0PS = BitField(self, 0x00000010, "RT0PS", "Clear Prescaler-0 interrupt")
        self.RT1PS = BitField(self, 0x00000020, "RT1PS", "Clear Prescaler-1 interrupt")
        self.RTCA = Subscriptor(self, "RTCA{}")
        self.RTPS = Subscriptor(self, "RT{}PS")

class SA_RTC_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.EVT0_CFG = BitField(self, 0x00000003, "EVT0_CFG", "Event line mode 0 select")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode 1 select")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_RTC_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x9118010, "DESC", "RTC Descriptor Register")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor revision. This number holds the module revision and is incremented by the module developers. n = Minor module revision (see device-specific data sheet)")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major revision. This number holds the module revision and is incremented by the module developers. n = Major version (see device-specific data sheet)")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instantiated version. Describes which instance of the module accessed.")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature set of this module. Differentiates the complexity of the actually instantiated module if there are differences.")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identifier. This ID is unique for each module. 0x0911 = Module ID of the RTC Module")

class SA_RTC_CLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCTL", "RTC Clock Control Register")
        self.MODCLKEN = BitField(self, 0x80000000, "MODCLKEN", "This bit enables the supply of the 32kHz clock to the RTC. It will not power-up the 32kHz crystal oscillator this needs to be done in the Clock System Module.")

class SA_RTC_DBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DBGCTL", "RTC Module Debug Control Register")
        self.DBGRUN = BitField(self, 0x00000001, "DBGRUN", "Debug Run.")
        self.DBGINT = BitField(self, 0x00000002, "DBGINT", "Debug Interrupt Enable.")

class SA_RTC_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL", "RTC Control Register")
        self.RTCTEVTX = BitField(self, 0x00000003, "RTCTEVTX", "Real-time clock time event.")
        self.RTCBCD = BitField(self, 0x00000080, "RTCBCD", "Real-time clock BCD select. Selects BCD counting for real-time clock.")

class SA_RTC_STA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STA", "RTC Status Register")
        self.RTCRDY = BitField(self, 0x00000001, "RTCRDY", "Real-time clock ready. This bit indicates when the real-time clock time values are safe for reading.")
        self.RTCTCRDY = BitField(self, 0x00000002, "RTCTCRDY", "Real-time clock temperature compensation ready. This is a read only bit that indicates when the RTCTCMPx can be written. Write to RTCTCMPx should be avoided when RTCTCRDY is reset.")
        self.RTCTCOK = BitField(self, 0x00000004, "RTCTCOK", "Real-time clock temperature compensation write OK. This is a read-only bit that indicates if the write to RTCTCMP is successful or not.")

class SA_RTC_CAL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CAL", "RTC Clock Offset Calibration Register")
        self.RTCOCALX = BitField(self, 0x000000FF, "RTCOCALX", "Real-time clock offset error calibration. Each LSB represents approximately +1ppm (RTCOCALXS = 1) or -1ppm (RTCOCALXS = 0) adjustment in frequency. Maximum effective calibration value is +/-240ppm. Excess values written above +/-240ppm will be ignored by hardware.")
        self.RTCOCALS = BitField(self, 0x00008000, "RTCOCALS", "Real-time clock offset error calibration sign. This bit decides the sign of offset error calibration.")
        self.RTCCALFX = BitField(self, 0x00030000, "RTCCALFX", "Real-time clock calibration frequency. Selects frequency output to RTC_OUT pin for calibration measurement. The corresponding port must be configured for the peripheral module function.")

class SA_RTC_TCMP(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TCMP", "RTC Temperature Compensation Register")
        self.RTCTCMPX = BitField(self, 0x000000FF, "RTCTCMPX", "Real-time clock temperature compensation. Value written into this register is used for temperature compensation of RTC. Each LSB represents approximately +1ppm (RTCTCMPS = 1) or -1ppm (RTCTCMPS = 0) adjustment in frequency. Maximum effective calibration value is +/-240ppm. Excess values written above +/-240ppm are ignored by hardware. Reading from RTCTCMP register at any time returns the cumulative value which is the signed addition of RTCOCALx and RTCTCMPX values, and the updated sign bit (RTCTCMPS) of the addition result.")
        self.RTCTCMPS = BitField(self, 0x00008000, "RTCTCMPS", "Real-time clock temperature compensation sign. This bit decides the sign of temperature compensation.")

class SA_RTC_SEC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SEC", "RTC Seconds Register - Calendar Mode With Binary / BCD Format")
        self.SECBIN = BitField(self, 0x0000003F, "SECBIN", "Seconds Binary (0 to 59). If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.SECLOWBCD = BitField(self, 0x00000F00, "SECLOWBCD", "Seconds BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.SECHIGHBCD = BitField(self, 0x00007000, "SECHIGHBCD", "Seconds BCD high digit (0 to 5). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")

class SA_RTC_MIN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIN", "RTC Minutes Register - Calendar Mode With Binary / BCD Format")
        self.MINBIN = BitField(self, 0x0000003F, "MINBIN", "Minutes Binary (0 to 59). If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.MINLOWBCD = BitField(self, 0x00000F00, "MINLOWBCD", "Minutes BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.MINHIGHBCD = BitField(self, 0x00007000, "MINHIGHBCD", "Minutes BCD high digit (0 to 5). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")

class SA_RTC_HOUR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "HOUR", "RTC Hours Register - Calendar Mode With Binary / BCD Format")
        self.HOURBIN = BitField(self, 0x0000001F, "HOURBIN", "Hours Binary (0 to 23). If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.HOURLOWBCD = BitField(self, 0x00000F00, "HOURLOWBCD", "Hours BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.HOURHIGHBCD = BitField(self, 0x00003000, "HOURHIGHBCD", "Hours BCD high digit (0 to 2). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")

class SA_RTC_DAY(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DAY", "RTC Day Of Week / Month Register - Calendar Mode With Binary / BCD Format")
        self.DOW = BitField(self, 0x00000007, "DOW", "Day of week (0 to 6). These bits are valid if RTCBCD=1 or RTCBCD=0.")
        self.DOMBIN = BitField(self, 0x00001F00, "DOMBIN", "Day of month Binary (1 to 28, 29, 30, 31). If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.DOMLOWBCD = BitField(self, 0x000F0000, "DOMLOWBCD", "Day of month BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.DOMHIGHBCD = BitField(self, 0x00300000, "DOMHIGHBCD", "Day of month BCD high digit (0 to 3). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")

class SA_RTC_MON(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MON", "RTC Month Register - Calendar Mode With Binary / BCD Format")
        self.MONBIN = BitField(self, 0x0000000F, "MONBIN", "Month Binary (1 to 12). If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.MONLOWBCD = BitField(self, 0x00000F00, "MONLOWBCD", "Month BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.MONHIGHBCD = BitField(self, 0x00001000, "MONHIGHBCD", "Month BCD high digit (0 or 1). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")

class SA_RTC_YEAR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "YEAR", "RTC Year Register - Calendar Mode With Binary / BCD Format")
        self.YEARLOWBIN = BitField(self, 0x000000FF, "YEARLOWBIN", "Year Binary low byte. Valid values for Year are 0 to 4095. If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.YEARHIGHBIN = BitField(self, 0x00000F00, "YEARHIGHBIN", "Year Binary high byte. Valid values for Year are 0 to 4095. If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.YEARLOWESTBCD = BitField(self, 0x000F0000, "YEARLOWESTBCD", "Year BCD lowest digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.DECADEBCD = BitField(self, 0x00F00000, "DECADEBCD", "Decade BCD (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.CENTLOWBCD = BitField(self, 0x0F000000, "CENTLOWBCD", "Century BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.CENTHIGHBCD = BitField(self, 0x70000000, "CENTHIGHBCD", "Century BCD high digit (0 to 4). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")

class SA_RTC_A1MIN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "A1MIN", "RTC Minute Alarm Register - Calendar Mode With Binary / BCD Format")
        self.AMINBIN = BitField(self, 0x0000003F, "AMINBIN", "Alarm Minutes Binary (0 to 59). If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.AMINAEBIN = BitField(self, 0x00000080, "AMINAEBIN", "Alarm Minutes Binary enable. If RTCBCD=1 this bit is always 0. Write to this bit will be ignored.")
        self.AMINLOWBCD = BitField(self, 0x00000F00, "AMINLOWBCD", "Alarm Minutes BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.AMINHIGHBCD = BitField(self, 0x00007000, "AMINHIGHBCD", "Alarm Minutes BCD high digit (0 to 5). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.AMINAEBCD = BitField(self, 0x00008000, "AMINAEBCD", "Alarm Minutes BCD enable. If RTCBCD=0 this bit is always 0. Write to this bit will be ignored.")

class SA_RTC_A1HOUR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "A1HOUR", "RTC Hours Alarm Register - Calendar Mode With Binary / BCD Format")
        self.AHOURBIN = BitField(self, 0x0000001F, "AHOURBIN", "Alarm Hours Binary (0 to 23). If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.AHOURAEBIN = BitField(self, 0x00000080, "AHOURAEBIN", "Alarm Hours Binary enable. If RTCBCD=1 this bit is always 0. Write to this bit will be ignored.")
        self.AHOURLOWBCD = BitField(self, 0x00000F00, "AHOURLOWBCD", "Alarm Hours BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.AHOURHIGHBCD = BitField(self, 0x00003000, "AHOURHIGHBCD", "Alarm Hours BCD high digit (0 to 2). If RTCBCD=0 write to these bits will be ignored and read give the value 0..")
        self.AHOURAEBCD = BitField(self, 0x00008000, "AHOURAEBCD", "Alarm Hours BCD enable. If RTCBCD=0 this bit is always 0. Write to this bit will be ignored.")

class SA_RTC_A1DAY(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "A1DAY", "RTC Alarm Day Of Week / Month Register - Calendar Mode With Binary / BCD Format")
        self.ADOW = BitField(self, 0x00000007, "ADOW", "Alarm Day of week (0 to 6). These bits are valid if RTCBCD=1 or RTCBCD=0.")
        self.ADOWAE = BitField(self, 0x00000080, "ADOWAE", "Alarm Day of week enable. This bit are valid if RTCBCD=1 or RTCBCD=0.")
        self.ADOMBIN = BitField(self, 0x00001F00, "ADOMBIN", "Alarm Day of month Binary (1 to 28, 29, 30, 31) If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.ADOMAEBIN = BitField(self, 0x00008000, "ADOMAEBIN", "Alarm Day of month Binary enable. If RTCBCD=1 this bit is always 0. Write to this bit will be ignored.")
        self.ADOMLOWBCD = BitField(self, 0x000F0000, "ADOMLOWBCD", "Alarm Day of month BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.ADOMHIGHBCD = BitField(self, 0x00300000, "ADOMHIGHBCD", "Alarm Day of month BCD high digit (0 to 3). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.ADOMAEBCD = BitField(self, 0x00800000, "ADOMAEBCD", "Alarm Day of month BCD enable. If RTCBCD=0 this bit is always 0. Write to this bit will be ignored.")

class SA_RTC_A2MIN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "A2MIN", "RTC Minute Alarm Register - Calendar Mode With Binary / BCD Format")
        self.AMINBIN = BitField(self, 0x0000003F, "AMINBIN", "Alarm Minutes Binary (0 to 59). If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.AMINAEBIN = BitField(self, 0x00000080, "AMINAEBIN", "Alarm Minutes Binary enable. If RTCBCD=1 this bit is always 0. Write to this bit will be ignored.")
        self.AMINLOWBCD = BitField(self, 0x00000F00, "AMINLOWBCD", "Alarm Minutes BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.AMINHIGHBCD = BitField(self, 0x00007000, "AMINHIGHBCD", "Alarm Minutes BCD high digit (0 to 5). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.AMINAEBCD = BitField(self, 0x00008000, "AMINAEBCD", "Alarm Minutes BCD enable. If RTCBCD=0 this bit is always 0. Write to this bit will be ignored.")

class SA_RTC_A2HOUR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "A2HOUR", "RTC Hours Alarm Register - Calendar Mode With Binary / BCD Format")
        self.AHOURBIN = BitField(self, 0x0000001F, "AHOURBIN", "Alarm Hours Binary (0 to 23). If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.AHOURAEBIN = BitField(self, 0x00000080, "AHOURAEBIN", "Alarm Hours Binary enable. If RTCBCD=1 this bit is always 0. Write to this bit will be ignored.")
        self.AHOURLOWBCD = BitField(self, 0x00000F00, "AHOURLOWBCD", "Alarm Hours BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.AHOURHIGHBCD = BitField(self, 0x00003000, "AHOURHIGHBCD", "Alarm Hours BCD high digit (0 to 2). If RTCBCD=0 write to these bits will be ignored and read give the value 0..")
        self.AHOURAEBCD = BitField(self, 0x00008000, "AHOURAEBCD", "Alarm Hours BCD enable. If RTCBCD=0 this bit is always 0. Write to this bit will be ignored.")

class SA_RTC_A2DAY(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "A2DAY", "RTC Alarm Day Of Week / Month Register - Calendar Mode With Binary / BCD Format")
        self.ADOW = BitField(self, 0x00000007, "ADOW", "Alarm Day of week (0 to 6). These bits are valid if RTCBCD=1 or RTCBCD=0.")
        self.ADOWAE = BitField(self, 0x00000080, "ADOWAE", "Alarm Day of week enable. This bit are valid if RTCBCD=1 or RTCBCD=0.")
        self.ADOMBIN = BitField(self, 0x00001F00, "ADOMBIN", "Alarm Day of month Binary (1 to 28, 29, 30, 31) If RTCBCD=1 write to these bits will be ignored and read give the value 0.")
        self.ADOMAEBIN = BitField(self, 0x00008000, "ADOMAEBIN", "Alarm Day of month Binary enable. If RTCBCD=1 this bit is always 0. Write to this bit will be ignored.")
        self.ADOMLOWBCD = BitField(self, 0x000F0000, "ADOMLOWBCD", "Alarm Day of month BCD low digit (0 to 9). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.ADOMHIGHBCD = BitField(self, 0x00300000, "ADOMHIGHBCD", "Alarm Day of month BCD high digit (0 to 3). If RTCBCD=0 write to these bits will be ignored and read give the value 0.")
        self.ADOMAEBCD = BitField(self, 0x00800000, "ADOMAEBCD", "Alarm Day of month BCD enable. If RTCBCD=0 this bit is always 0. Write to this bit will be ignored.")

class SA_RTC_PSCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x8, "PSCTL", "RTC Prescale Timer 0/1 Control Register")
        self.RT0IP = BitField(self, 0x0000001C, "RT0IP", "Prescale timer 0 interrupt interval")
        self.RT1IP = BitField(self, 0x001C0000, "RT1IP", "Prescale timer 1 interrupt interval")
        self.RTIP = Subscriptor(self, "RT{}IP")

class SA_RTC(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FPUB_0 = SA_RTC_FPUB_0(self, 0x444)
        self.PWREN = SA_RTC_PWREN(self, 0x800)
        self.RSTCTL = SA_RTC_RSTCTL(self, 0x804)
        self.CLKCFG = SA_RTC_CLKCFG(self, 0x808)
        self.STAT = SA_RTC_STAT(self, 0x814)
        self.CLKSEL = SA_RTC_CLKSEL(self, 0x1004)
        self.INT_EVENT0_IIDX = SA_RTC_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_RTC_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_RTC_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_RTC_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_RTC_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_RTC_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_RTC_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_RTC_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_RTC_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_RTC_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_RTC_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_RTC_INT_EVENT1_ICLR(self, 0x1078)
        self.EVT_MODE = SA_RTC_EVT_MODE(self, 0x10E0)
        self.DESC = SA_RTC_DESC(self, 0x10FC)
        self.CLKCTL = SA_RTC_CLKCTL(self, 0x1100)
        self.DBGCTL = SA_RTC_DBGCTL(self, 0x1104)
        self.CTL = SA_RTC_CTL(self, 0x1108)
        self.STA = SA_RTC_STA(self, 0x110C)
        self.CAL = SA_RTC_CAL(self, 0x1110)
        self.TCMP = SA_RTC_TCMP(self, 0x1114)
        self.SEC = SA_RTC_SEC(self, 0x1118)
        self.MIN = SA_RTC_MIN(self, 0x111C)
        self.HOUR = SA_RTC_HOUR(self, 0x1120)
        self.DAY = SA_RTC_DAY(self, 0x1124)
        self.MON = SA_RTC_MON(self, 0x1128)
        self.YEAR = SA_RTC_YEAR(self, 0x112C)
        self.A1MIN = SA_RTC_A1MIN(self, 0x1130)
        self.A1HOUR = SA_RTC_A1HOUR(self, 0x1134)
        self.A1DAY = SA_RTC_A1DAY(self, 0x1138)
        self.A2MIN = SA_RTC_A2MIN(self, 0x113C)
        self.A2HOUR = SA_RTC_A2HOUR(self, 0x1140)
        self.A2DAY = SA_RTC_A2DAY(self, 0x1144)
        self.PSCTL = SA_RTC_PSCTL(self, 0x1148)
        self.AMIN = Subscriptor(self, "A{}MIN")
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.AHOUR = Subscriptor(self, "A{}HOUR")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.ADAY = Subscriptor(self, "A{}DAY")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

RTC = SA_RTC(0x40094000, "RTC")

class SA_SPI0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_SPI0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_SPI0_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_SPI0_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_SPI0_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_SPI0_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.SYSCLK_SEL = BitField(self, 0x00000008, "SYSCLK_SEL", "Selects SYSCLK as clock source if enabled")

class SA_SPI0_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_SPI0_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_SPI0_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.RX = BitField(self, 0x00000008, "RX", "Receive FIFO event.This interrupt is set if the selected Receive FIFO level has been reached")
        self.TX = BitField(self, 0x00000010, "TX", "Transmit FIFO event mask.")
        self.TXEMPTY = BitField(self, 0x00000020, "TXEMPTY", "Transmit FIFO Empty event mask.")
        self.PER = BitField(self, 0x00000002, "PER", "Parity error event mask.")
        self.DMA_DONE_RX = BitField(self, 0x00000080, "DMA_DONE_RX", "DMA Done 1 event for RX event mask.")
        self.RXFIFO_OVF = BitField(self, 0x00000001, "RXFIFO_OVF", "RXFIFO overflow event mask.")
        self.DMA_DONE_TX = BitField(self, 0x00000100, "DMA_DONE_TX", "DMA Done 1 event for TX event mask.")
        self.IDLE = BitField(self, 0x00000040, "IDLE", "SPI Idle event mask.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Enable SPI Receive Time-Out event mask.")
        self.RXFULL = BitField(self, 0x00000400, "RXFULL", "RX FIFO Full Interrupt Mask")
        self.TXFIFO_UNF = BitField(self, 0x00000200, "TXFIFO_UNF", "TX FIFO underflow interrupt mask")

class SA_SPI0_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.RX = BitField(self, 0x00000008, "RX", "Receive FIFO event.This interrupt is set if the selected Receive FIFO level has been reached")
        self.TX = BitField(self, 0x00000010, "TX", "Transmit FIFO event..This interrupt is set if the selected Transmit FIFO level has been reached.")
        self.TXEMPTY = BitField(self, 0x00000020, "TXEMPTY", "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been move to the shift register.")
        self.PER = BitField(self, 0x00000002, "PER", "Parity error event: this bit is set if a Parity error has been detected")
        self.DMA_DONE_RX = BitField(self, 0x00000080, "DMA_DONE_RX", "DMA Done 1 event for RX. This interrupt is set if the RX DMA channel sends the DONE signal. This allows the handling of the DMA event inside the mapped peripheral.")
        self.RXFIFO_OVF = BitField(self, 0x00000001, "RXFIFO_OVF", "RXFIFO overflow event. This interrupt is set if an RX FIFO overflow has been detected.")
        self.DMA_DONE_TX = BitField(self, 0x00000100, "DMA_DONE_TX", "DMA Done 1 event for TX. This interrupt is set if the TX DMA channel sends the DONE signal. This allows the handling of the DMA event inside the mapped peripheral.")
        self.IDLE = BitField(self, 0x00000040, "IDLE", "SPI has done finished transfers and changed into IDLE mode. This bit is set when BUSY goes low.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "SPI Receive Time-Out event.")
        self.TXFIFO_UNF = BitField(self, 0x00000200, "TXFIFO_UNF", "TX FIFO Underflow Interrupt")
        self.RXFULL = BitField(self, 0x00000400, "RXFULL", "RX FIFO Full Interrupt")

class SA_SPI0_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.RX = BitField(self, 0x00000008, "RX", "Masked receive FIFO event.This interrupt is set if the selected Receive FIFO level has been reached")
        self.TX = BitField(self, 0x00000010, "TX", "Masked Transmit FIFO event. This interrupt is set if the selected Transmit FIFO level has been reached.")
        self.TXEMPTY = BitField(self, 0x00000020, "TXEMPTY", "Masked Transmit FIFO Empty event.")
        self.PER = BitField(self, 0x00000002, "PER", "Masked Parity error event: this bit if a Parity error has been detected")
        self.DMA_DONE_RX = BitField(self, 0x00000080, "DMA_DONE_RX", "Masked DMA Done 1 event for RX.")
        self.RXFIFO_OVF = BitField(self, 0x00000001, "RXFIFO_OVF", "Masked RXFIFO overflow event. This interrupt is set if an RX FIFO overflow has been detected.")
        self.DMA_DONE_TX = BitField(self, 0x00000100, "DMA_DONE_TX", "Masked DMA Done 1 event for TX.")
        self.IDLE = BitField(self, 0x00000040, "IDLE", "Masked SPI IDLE mode event.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Masked SPI Receive Time-Out Interrupt.")
        self.RXFULL = BitField(self, 0x00000400, "RXFULL", "RX FIFO Full Interrupt")
        self.TXFIFO_UNF = BitField(self, 0x00000200, "TXFIFO_UNF", "TX FIFO underflow interrupt")

class SA_SPI0_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.RX = BitField(self, 0x00000008, "RX", "Set Receive FIFO event.")
        self.TX = BitField(self, 0x00000010, "TX", "Set Transmit FIFO event.")
        self.TXEMPTY = BitField(self, 0x00000020, "TXEMPTY", "Set Transmit FIFO Empty event.")
        self.PER = BitField(self, 0x00000002, "PER", "Set Parity error event.")
        self.DMA_DONE_RX = BitField(self, 0x00000080, "DMA_DONE_RX", "Set DMA Done 1 event for RX.")
        self.RXFIFO_OVF = BitField(self, 0x00000001, "RXFIFO_OVF", "Set RXFIFO overflow event.")
        self.DMA_DONE_TX = BitField(self, 0x00000100, "DMA_DONE_TX", "Set DMA Done 1 event for TX.")
        self.IDLE = BitField(self, 0x00000040, "IDLE", "Set SPI IDLE mode event.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Set SPI Receive Time-Out Event.")
        self.TXFIFO_UNF = BitField(self, 0x00000200, "TXFIFO_UNF", "Set TX FIFO Underflow Event")
        self.RXFULL = BitField(self, 0x00000400, "RXFULL", "Set RX FIFO Full Event")

class SA_SPI0_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.RX = BitField(self, 0x00000008, "RX", "Clear Receive FIFO event.")
        self.TX = BitField(self, 0x00000010, "TX", "Clear Transmit FIFO event.")
        self.TXEMPTY = BitField(self, 0x00000020, "TXEMPTY", "Clear Transmit FIFO Empty event.")
        self.PER = BitField(self, 0x00000002, "PER", "Clear Parity error event.")
        self.DMA_DONE_RX = BitField(self, 0x00000080, "DMA_DONE_RX", "Clear DMA Done 1 event for RX.")
        self.RXFIFO_OVF = BitField(self, 0x00000001, "RXFIFO_OVF", "Clear RXFIFO overflow event.")
        self.DMA_DONE_TX = BitField(self, 0x00000100, "DMA_DONE_TX", "Clear DMA Done 1 event for TX.")
        self.IDLE = BitField(self, 0x00000040, "IDLE", "Clear SPI IDLE mode event.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Clear SPI Receive Time-Out Event.")
        self.TXFIFO_UNF = BitField(self, 0x00000200, "TXFIFO_UNF", "Clear TXFIFO underflow event")
        self.RXFULL = BitField(self, 0x00000400, "RXFULL", "Clear RX FIFO underflow event")

class SA_SPI0_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_SPI0_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.RX = BitField(self, 0x00000008, "RX", "Receive FIFO event mask.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "SPI Receive Time-Out event mask.")

class SA_SPI0_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.RX = BitField(self, 0x00000008, "RX", "Receive FIFO event.This interrupt is set if the selected Receive FIFO level has been reached")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "SPI Receive Time-Out Event.")

class SA_SPI0_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.RX = BitField(self, 0x00000008, "RX", "Receive FIFO event mask.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "SPI Receive Time-Out event mask.")

class SA_SPI0_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.RX = BitField(self, 0x00000008, "RX", "Set Receive FIFO event.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Set SPI Receive Time-Out event.")

class SA_SPI0_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.RX = BitField(self, 0x00000008, "RX", "Clear Receive FIFO event.")
        self.RTOUT = BitField(self, 0x00000004, "RTOUT", "Clear SPI Receive Time-Out event.")

class SA_SPI0_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_SPI0_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.TX = BitField(self, 0x00000010, "TX", "Transmit FIFO event mask.")

class SA_SPI0_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.TX = BitField(self, 0x00000010, "TX", "Transmit FIFO event:. A read returns the current mask for transmit FIFO interrupt. On a write of 1, the mask for transmit FIFO interrupt is set which means the interrupt state will be reflected in MIS.TXMIS. A write of 0 clears the mask which means MIS.TXMIS will not reflect the interrupt.")

class SA_SPI0_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.TX = BitField(self, 0x00000010, "TX", "Masked Transmit FIFO event")

class SA_SPI0_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.TX = BitField(self, 0x00000010, "TX", "Set Transmit FIFO event.")

class SA_SPI0_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.TX = BitField(self, 0x00000010, "TX", "Clear Transmit FIFO event.")

class SA_SPI0_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.INT1_CFG = BitField(self, 0x0000000C, "INT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.INT2_CFG = BitField(self, 0x00000030, "INT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.INT_CFG = Subscriptor(self, "INT{}_CFG")

class SA_SPI0_INTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INTCTL", "Interrupt control register")
        self.INTEVAL = BitField(self, 0x00000001, "INTEVAL", "Writing a 1 to this field re-evaluates the interrupt sources.")

class SA_SPI0_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL0", "SPI control register 0")
        self.DSS = BitField(self, 0x0000001F, "DSS", "Data Size Select.. Values 0 - 2 are reserved and shall not be used. 3h = 4_BIT : 4-bit data SPI allows only values up to 16 Bit")
        self.FRF = BitField(self, 0x00000060, "FRF", "Frame format Select")
        self.SPO = BitField(self, 0x00000100, "SPO", "CLKOUT polarity (Motorola SPI frame format only)")
        self.SPH = BitField(self, 0x00000200, "SPH", "CLKOUT phase (Motorola SPI frame format only). This bit selects the clock edge that captures data and enables it to change state. It has the most impact on the first bit transmitted by either permitting or not permitting a clock transition before the first data capture edge.")
        self.CSSEL = BitField(self, 0x00003000, "CSSEL", "Select the CS line to control on data transfer. This bit is for controller mode only.")
        self.CSCLR = BitField(self, 0x00004000, "CSCLR", "Clear shift register counter on CS inactive. This bit is relevant only in the peripheral, CTL1.MS=0.")
        self.PACKEN = BitField(self, 0x00000080, "PACKEN", "Packing Enable.. When 1, packing feature is enabled inside the IP When 0, packing feature is disabled inside the IP")

class SA_SPI0_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x4, "CTL1", "SPI control register 1")
        self.LBM = BitField(self, 0x00000002, "LBM", "Loop back mode")
        self.MS = BitField(self, 0x00000004, "MS", "Controller or peripheral mode select. This bit can be modified only when SPI is disabled, CTL1.ENABLE=0.")
        self.SOD = BitField(self, 0x00000008, "SOD", "Peripheral-mode: Data output disabled. This bit is relevant only in the peripheral mode, CTL1.MS=1. In multiple-peripheral systems, it is possible for an SPI controller to broadcast a message to all peripherals in the system while ensuring that only one peripheral drives data onto its serial output line. In such systems the MISO lines from multiple peripherals could be tied together. To operate in such systems, this bitfield can be set if the SPI peripheral is not supposed to drive the MISO line:")
        self.MSB = BitField(self, 0x00000010, "MSB", "MSB first select. Controls the direction of the receive and transmit shift register.")
        self.PREN = BitField(self, 0x00000020, "PREN", "Parity receive enable. If enabled, parity reception check will be done for both controller and peripheral modes In case of a parity miss-match the parity error flag RIS.PER will be set.")
        self.REPEATTX = BitField(self, 0x00FF0000, "REPEATTX", "Counter to repeat last transfer. 0: repeat last transfer is disabled. x: repeat the last transfer with the given number. The transfer will be started with writing a data into the TX Buffer. Sending the data will be repeated with the given value, so the data will be transferred X+1 times in total. The behavior is identical as if the data would be written into the TX Buffer that many times as defined by the value here. It can be used to clean a transfer or to pull a certain amount of data by a peripheral.")
        self.PES = BitField(self, 0x00000040, "PES", "Even Parity Select")
        self.PBS = BitField(self, 0x00000080, "PBS", "Parity Bit Select")
        self.CDMODE = BitField(self, 0x0000F000, "CDMODE", "Command/Data Mode Value. When CTL1.CDENABLE is 1, CS3 line is used as C/D signal to distinguish between Command (C/D low) and Data (C/D high) information. When a value is written into the CTL1.CDMODE bits, the C/D (CS3) line will go low for the given numbers of byte which are sent by the SPI, starting with the next value to be transmitted after which, C/D line will go high automatically 0: Manual mode with C/D signal as High 1-14: C/D is low while this number of bytes are being sent after which, this field sets to 0 and C/D goes high. Reading this field at any time returns the remaining number of command bytes. 15: Manual mode with C/D signal as Low.")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "SPI enable")
        self.RXTIMEOUT = BitField(self, 0x3F000000, "RXTIMEOUT", "Receive Timeout (only for Peripheral mode). Defines the number of Clock Cycles before after which the Receive Timeout flag RTOUT is set. The time is calculated using the control register for the clock selection and divider in the Controller mode configuration. A value of 0 disables this function.")
        self.CDENABLE = BitField(self, 0x00000800, "CDENABLE", "Command/Data Mode enable")
        self.PTEN = BitField(self, 0x00000100, "PTEN", "Parity transmit enable. If enabled, parity transmission will be done for both controller and peripheral modes.")

class SA_SPI0_CLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCTL", "Clock prescaler and divider register.")
        self.SCR = BitField(self, 0x000003FF, "SCR", "Serial clock divider:. This is used to generate the transmit and receive bit rate of the SPI. The SPI bit rate is (SPI's functional clock frequency)/((SCR+1)*2). SCR is a value from 0-1023.")
        self.DSAMPLE = BitField(self, 0xF0000000, "DSAMPLE", "Delayed sampling value. . In controller mode the data on the input pin will be delayed sampled by the defined clock cycles of internal functional clock hence relaxing the setup time of input data. This setting is useful in systems where the board delays and external peripheral delays are more than the input setup time of the controller. Please refer to the datasheet for values of controller input setup time and assess what DSAMPLE value meets the requirement of the system. Note: High values of DSAMPLE can cause HOLD time violations and must be factored in the calculations.")

class SA_SPI0_IFLS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x12, "IFLS", "UART Interrupt FIFO Level Select Register")
        self.TXIFLSEL = BitField(self, 0x00000007, "TXIFLSEL", "SPI Transmit Interrupt FIFO Level Select The trigger points for the transmit interrupt are as follows:")
        self.RXIFLSEL = BitField(self, 0x00000038, "RXIFLSEL", "SPI Receive Interrupt FIFO Level Select The trigger points for the receive interrupt are as follows:")

class SA_SPI0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.TFE = BitField(self, 0x00000001, "TFE", "Transmit FIFO empty.")
        self.TNF = BitField(self, 0x00000002, "TNF", "Transmit FIFO not full")
        self.RFE = BitField(self, 0x00000004, "RFE", "Receive FIFO empty.")
        self.RNF = BitField(self, 0x00000008, "RNF", "Receive FIFO not full")
        self.BUSY = BitField(self, 0x00000010, "BUSY", "Busy")

class SA_SPI0_RXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RXDATA", "RXDATA Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "Received Data. When PACKEN=1,two entries of the FIFO are returned as a 32-bit value. When PACKEN=0, 1 entry of FIFO is returned as 16-bit value. As data values are removed by the receive logic from the incoming data frame, they are placed into the entry in the receive FIFO, pointed to by the current FIFO write pointer. Received data less than 16 bits is automatically right justified in the receive buffer.")

class SA_SPI0_TXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TXDATA", "TXDATA Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "Transmit Data. WWhen read, last written value will be returned. If the last write to this field was a 32-bit write (with PACKEN=1), 32-bits will be returned and if the last write was a 16-bit write (PACKEN=0), those 16-bits will be returned. When written, one or two FIFO entries will be written depending on PACKEN value. Data values are removed from the transmit FIFO one value at a time by the transmit logic. It is loaded into the transmit serial shifter, then serially shifted out onto the TXD output pin at the programmed bit rate. When a data size of less than 16 bits is selected, the user must right-justify data written to the transmit FIFO. The transmit logic ignores the unused bits.")

class SA_SPI0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_SPI0_PWREN(self, 0x800)
        self.RSTCTL = SA_SPI0_RSTCTL(self, 0x804)
        self.CLKCFG = SA_SPI0_CLKCFG(self, 0x808)
        self.GPRCM_STAT = SA_SPI0_GPRCM_STAT(self, 0x814)
        self.CLKDIV = SA_SPI0_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_SPI0_CLKSEL(self, 0x1004)
        self.PDBGCTL = SA_SPI0_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_SPI0_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_SPI0_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_SPI0_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_SPI0_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_SPI0_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_SPI0_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_SPI0_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_SPI0_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_SPI0_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_SPI0_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_SPI0_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_SPI0_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_SPI0_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_SPI0_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_SPI0_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_SPI0_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_SPI0_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_SPI0_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_SPI0_EVT_MODE(self, 0x10E0)
        self.INTCTL = SA_SPI0_INTCTL(self, 0x10E4)
        self.CTL0 = SA_SPI0_CTL0(self, 0x1100)
        self.CTL1 = SA_SPI0_CTL1(self, 0x1104)
        self.CLKCTL = SA_SPI0_CLKCTL(self, 0x1108)
        self.IFLS = SA_SPI0_IFLS(self, 0x110C)
        self.STAT = SA_SPI0_STAT(self, 0x1110)
        self.RXDATA = SA_SPI0_RXDATA(self, 0x1130)
        self.TXDATA = SA_SPI0_TXDATA(self, 0x1140)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.CTL = Subscriptor(self, "CTL{}")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

SPI0 = SA_SPI0(0x40468000, "SPI0")

class SA_AES_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_AES_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_AES_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_AES_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_AES_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_AES_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.AESRDY = BitField(self, 0x00000001, "AESRDY", "AES ready interrupt, set when the selected AES operation was completed and the result can be read from AESADOUT.")
        self.DMA0 = BitField(self, 0x00000002, "DMA0", "DMA0 event mask.")
        self.DMA1 = BitField(self, 0x00000004, "DMA1", "DMA1 event mask.")
        self.DMA2 = BitField(self, 0x00000008, "DMA2", "DMA2 event mask.")
        self.DMA = Subscriptor(self, "DMA{}")

class SA_AES_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.AESRDY = BitField(self, 0x00000001, "AESRDY", "AES ready interrupt, set when the selected AES operation was completed and the result can be read from AESADOUT.")
        self.DMA0 = BitField(self, 0x00000002, "DMA0", "DMA0 event")
        self.DMA1 = BitField(self, 0x00000004, "DMA1", "DMA1 event")
        self.DMA2 = BitField(self, 0x00000008, "DMA2", "DMA2 event")
        self.DMA = Subscriptor(self, "DMA{}")

class SA_AES_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.AESRDY = BitField(self, 0x00000001, "AESRDY", "AES ready interrupt, set when the selected AES operation was completed and the result can be read from AESADOUT.")
        self.DMA0 = BitField(self, 0x00000002, "DMA0", "DMA0 event")
        self.DMA1 = BitField(self, 0x00000004, "DMA1", "DMA1 event")
        self.DMA2 = BitField(self, 0x00000008, "DMA2", "DMA2 event")
        self.DMA = Subscriptor(self, "DMA{}")

class SA_AES_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.AESRDY = BitField(self, 0x00000001, "AESRDY", "AES ready interrupt, set when the selected AES operation was completed and the result can be read from AESADOUT.")
        self.DMA0 = BitField(self, 0x00000002, "DMA0", "DMA0")
        self.DMA1 = BitField(self, 0x00000004, "DMA1", "DMA1")
        self.DMA2 = BitField(self, 0x00000008, "DMA2", "DMA2")
        self.DMA = Subscriptor(self, "DMA{}")

class SA_AES_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.AESRDY = BitField(self, 0x00000001, "AESRDY", "AES ready interrupt, set when the selected AES operation was completed and the result can be read from AESADOUT.")
        self.DMA0 = BitField(self, 0x00000002, "DMA0", "DMA0")
        self.DMA1 = BitField(self, 0x00000004, "DMA1", "DMA1")
        self.DMA2 = BitField(self, 0x00000008, "DMA2", "DMA2")
        self.DMA = Subscriptor(self, "DMA{}")

class SA_AES_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_AES_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.DMA0 = BitField(self, 0x00000002, "DMA0", "DMA0 event mask.")

class SA_AES_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.DMA0 = BitField(self, 0x00000002, "DMA0", "DMA0 event")

class SA_AES_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.DMA0 = BitField(self, 0x00000002, "DMA0", "DMA0 event")

class SA_AES_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.DMA0 = BitField(self, 0x00000002, "DMA0", "DMA0")

class SA_AES_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.DMA0 = BitField(self, 0x00000002, "DMA0", "DMA0 event")

class SA_AES_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_AES_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.DMA1 = BitField(self, 0x00000004, "DMA1", "DMA1 event mask.")

class SA_AES_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.DMA1 = BitField(self, 0x00000004, "DMA1", "DMA1 event")

class SA_AES_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.DMA1 = BitField(self, 0x00000004, "DMA1", "DMA1 event")

class SA_AES_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.DMA1 = BitField(self, 0x00000004, "DMA1", "DMA1 event")

class SA_AES_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.DMA1 = BitField(self, 0x00000004, "DMA1", "DMA1 event")

class SA_AES_INT_EVENT3_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT3_IIDX", "Interrupt Index Register")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_AES_INT_EVENT3_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT3_IMASK", "Interrupt mask")
        self.DMA2 = BitField(self, 0x00000008, "DMA2", "DMA2 event mask.")

class SA_AES_INT_EVENT3_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT3_RIS", "Raw interrupt status")
        self.DMA2 = BitField(self, 0x00000008, "DMA2", "DMA2 event")

class SA_AES_INT_EVENT3_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT3_MIS", "Masked interrupt status")
        self.DMA2 = BitField(self, 0x00000008, "DMA2", "DMA2 event")

class SA_AES_INT_EVENT3_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT3_ISET", "Interrupt set")
        self.DMA2 = BitField(self, 0x00000008, "DMA2", "DMA2 event")

class SA_AES_INT_EVENT3_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT3_ICLR", "Interrupt clear")
        self.DMA2 = BitField(self, 0x00000008, "DMA2", "DMA2 event")

class SA_AES_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.EVT3_CFG = BitField(self, 0x000000C0, "EVT3_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_AES_ACTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ACTL0", "AES accelerator control register 0")
        self.AESACTL0_OPX = BitField(self, 0x00000003, "AESACTL0_OPX", "AES operation.. The AESOPx bits are not reset by AESSWRST = 1. Writes are ignored when AESCMEN = 1 and AESBLKCNTx &gt; 0. 00b = Encryption. 01b = Decryption. The provided key is the same key used for encryption. 10b = Generate first round key required for decryption. 11b = Decryption. The provided key is the first round key required for decryption.")
        self.AESACTL0_KLX = BitField(self, 0x0000000C, "AESACTL0_KLX", "AES key length. . These bits define which of the 1 AES standards is performed. The AESKLx bits are not reset by AESSWRST = 1. Writes are ignored when AESCMEN = 1 and AESBLKCNTx &gt; 0.")
        self.AESACTL0_CMX = BitField(self, 0x00000060, "AESACTL0_CMX", "AES cipher mode select. These bits are ignored for AESCMEN = 0. Writes are ignored when AESCMEN = 1 and AESBLKCNTx &gt; 0.. 00b = ECB 01b = CBC 10b = OFB 11b = CFB")
        self.AESACTL0_SWRST = BitField(self, 0x00000080, "AESACTL0_SWRST", "AES software reset. . Immediately resets the complete AES accelerator module even when busy except for the AESRDYIE, the AESKLx and the AESOPx bits. It also clears the (internal) state memory. The AESSWRST bit is automatically reset and is always read as zero. 0b = No reset 1b = Reset AES accelerator module")
        self.AESACTL0_ERRFG = BitField(self, 0x00000800, "AESACTL0_ERRFG", "AES error flag. . AESAKEY or AESADIN were written while an AES operation was in progress. The bit must be cleared by software. 0b = No error 1b = Error occurred")
        self.AESACTL0_CMEN = BitField(self, 0x00008000, "AESACTL0_CMEN", "AESCMEN enables the support of the cipher modes ECB, CBC, OFB and CFB together with the DMA. Writes are ignored when AESCMEN = 1 and AESBLKCNTx &gt; 0.. 0 = No DMA triggers are generated. 1 = DMA cipher mode support operation is enabled and the corresponding DMA triggers are generated.")

class SA_AES_ACTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ACTL1", "AES accelerator control register 1")
        self.AESACTL1_BLKCNTX = BitField(self, 0x000000FF, "AESACTL1_BLKCNTX", "Cipher Block Counter. Number of blocks to be encrypted or decrypted with block cipher modes enabled (AESCMEN = 1). Ignored if AESCMEN = 0. The block counter decrements with each performed encryption or decryption. Writes are ignored when AESCMEN = 1 and AESBLKCNTx &gt; 0.")

class SA_AES_ASTAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ASTAT", "aes accelerator status register")
        self.AESASTAT_BUSY = BitField(self, 0x00000001, "AESASTAT_BUSY", "AES accelerator module busy; encryption, decryption, or key generation in progress. . 0 = Not busy 1 = Busy")
        self.AESASTAT_KEYWR = BitField(self, 0x00000002, "AESASTAT_KEYWR", "All bytes written to AESAKEY. This bit can be modified by software but it must not be reset by software (10) if AESCMEN=1. Changing its state by software also resets the AESKEYCNTx bits. AESKEYWR is reset by PUC, AESSWRST, an error condition, changing AESOPx, changing AESKLx, and the start to (over)write a new key. Because it is reset when AESOPx is changed it can be set by software again to indicate that the loaded key is still valid.")
        self.AESASTAT_DINWR = BitField(self, 0x00000004, "AESASTAT_DINWR", "All 16 bytes written to AESADIN, AESAXDIN or AESAXIN. Changing its state by software also resets the AESDINCNTx bits. AESDINWR is reset by PUC, AESSWRST, an error condition, changing AESOPx, changing AESKLx, the start to (over)write the data, and when the AES accelerator is busy. Because it is reset when AESOPx or AESKLx is changed it can be set by software again to indicate that the current data is still valid. . 0 = Not all bytes written 1 = All bytes written")
        self.AESASTAT_DOUTRD = BitField(self, 0x00000008, "AESASTAT_DOUTRD", "All 16 bytes read from AESADOUT. AESDOUTRD is reset by PUC, AESSWRST, an error condition, changing AESOPx, changing AESKLx, when the AES accelerator is busy, and when the output data is read again. . 0 = Not all bytes read 1 = All bytes read")
        self.AESASTAT_KEYCNTX = BitField(self, 0x000000F0, "AESASTAT_KEYCNTX", "Bytes written to AESAKEY when AESKLx = 00, half-words written to AESAKEY if AESKLx = b10. Reset when AESKEYWR is reset. If AESKEYCNTx = 0 and AESKEYWR = 0, no bytes were written. If AESKEYCNTx = 0 and AESKEYWR = 1, all bytes were written.")
        self.AESASTAT_DINCNTX = BitField(self, 0x00000F00, "AESASTAT_DINCNTX", "Bytes written to AESADIN, AESAXDIN or AESAXIN. Reset when AESDINWR is reset. If AESDINCNTx = 0 and AESDINWR = 0, no bytes were written. If AESDINCNTx = 0 and AESDINWR = 1, all bytes were written.")
        self.AESASTAT_DOUTCNTX = BitField(self, 0x0000F000, "AESASTAT_DOUTCNTX", "Bytes read from AESADOUT. Reset when AESDOUTRD is reset. If AESDOUTCNTx = 0 and AESDOUTRD = 0, no bytes were read. If AESDOUTCNTx = 0 and AESDOUTRD = 1, all bytes were read.")

class SA_AES_AKEY(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "AKEY", "aes accelerator key register")
        self.AESAKEY_KEY0X = BitField(self, 0x000000FF, "AESAKEY_KEY0X", "AES key byte n when AESAKEY is written as word. AES next key byte when AESAKEY is written as byte. Do not mix word and byte access. Always reads as zero. The key is reset by PUC or by AESSWRST = 1.")
        self.AESAKEY_KEY1X = BitField(self, 0x0000FF00, "AESAKEY_KEY1X", "AES key byte n+1 when AESAKEY is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero. The key is reset by PUC or by AESSWRST = 1.")
        self.AESAKEY_KEY2X = BitField(self, 0x00FF0000, "AESAKEY_KEY2X", "AES key byte n+2 when AESAKEY is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero. The key is reset by PUC or by AESSWRST = 1.")
        self.AESAKEY_KEY3X = BitField(self, 0xFF000000, "AESAKEY_KEY3X", "AES key byte n+3 when AESAKEY is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero. The key is reset by PUC or by AESSWRST = 1.")
        self.AESAKEY_KEYX = Subscriptor(self, "AESAKEY_KEY{}X")

class SA_AES_ADIN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ADIN", "aes accelerator data in register")
        self.AESADIN_DIN0X = BitField(self, 0x000000FF, "AESADIN_DIN0X", "AES data in byte n when AESADIN is written as word. AES next data in byte when AESADIN is written as byte. Do not mix word and byte access. Always reads as zero.")
        self.AESADIN_DIN1X = BitField(self, 0x0000FF00, "AESADIN_DIN1X", "AES data in byte n+1 when AESADIN is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero.")
        self.AESADIN_DIN2X = BitField(self, 0x00FF0000, "AESADIN_DIN2X", "AES data in byte n+2 when AESADIN is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero.")
        self.AESADIN_DIN3X = BitField(self, 0xFF000000, "AESADIN_DIN3X", "AES data in byte n+3 when AESADIN is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero.")
        self.AESADIN_DINX = Subscriptor(self, "AESADIN_DIN{}X")

class SA_AES_ADOUT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ADOUT", "aes accelerator data out register")
        self.AESADOUT_DOUT0X = BitField(self, 0x000000FF, "AESADOUT_DOUT0X", "AES data out byte n when AESADOUT is read as word. AES next data out byte when AESADOUT is read as byte. Do not mix word and byte access.")
        self.AESADOUT_DOUT1X = BitField(self, 0x0000FF00, "AESADOUT_DOUT1X", "AES data out byte n+1 when AESADOUT is read as word. Do not use these bits for byte access. Do not mix word and byte access.")
        self.AESADOUT_DOUT2X = BitField(self, 0x00FF0000, "AESADOUT_DOUT2X", "AES data out byte n+2 when AESADOUT is read as word. Do not use these bits for byte access. Do not mix word and byte access.")
        self.AESADOUT_DOUT3X = BitField(self, 0xFF000000, "AESADOUT_DOUT3X", "AES data out byte n+3 when AESADOUT is read as word. Do not use these bits for byte access. Do not mix word and byte access.")
        self.AESADOUT_DOUTX = Subscriptor(self, "AESADOUT_DOUT{}X")

class SA_AES_AXDIN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "AXDIN", "aes accelerator xored data in register")
        self.AESAXDIN_XDIN0X = BitField(self, 0x000000FF, "AESAXDIN_XDIN0X", "AES data in byte n when AESAXDIN is written as word. AES next data in byte when AESAXDIN is written as byte. Do not mix word and byte access. Always reads as zero.")
        self.AESAXDIN_XDIN1X = BitField(self, 0x0000FF00, "AESAXDIN_XDIN1X", "AES data in byte n+1 when AESAXDIN is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero.")
        self.AESAXDIN_XDIN2X = BitField(self, 0x00FF0000, "AESAXDIN_XDIN2X", "AES data in byte n+2 when AESAXDIN is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero.")
        self.AESAXDIN_XDIN3X = BitField(self, 0xFF000000, "AESAXDIN_XDIN3X", "AES data in byte n+3 when AESAXDIN is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero.")
        self.AESAXDIN_XDINX = Subscriptor(self, "AESAXDIN_XDIN{}X")

class SA_AES_AXIN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "AXIN", "aes accelerator xored data in register (no trigger)")
        self.AESAXIN_XIN0X = BitField(self, 0x000000FF, "AESAXIN_XIN0X", "AES data in byte n when AESAXIN is written as word. AES next data in byte when AESAXIN is written as byte. Do not mix word and byte access. Always reads as zero.")
        self.AESAXIN_XIN1X = BitField(self, 0x0000FF00, "AESAXIN_XIN1X", "AES data in byte n+1 when AESAXIN is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero.")
        self.AESAXIN_XIN2X = BitField(self, 0x00FF0000, "AESAXIN_XIN2X", "AES data in byte n+2 when AESAXIN is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero.")
        self.AESAXIN_XIN3X = BitField(self, 0xFF000000, "AESAXIN_XIN3X", "AES data in byte n+3 when AESAXIN is written as word. Do not use these bits for byte access. Do not mix word and byte access. Always reads as zero.")
        self.AESAXIN_XINX = Subscriptor(self, "AESAXIN_XIN{}X")

class SA_AES(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_AES_PWREN(self, 0x800)
        self.RSTCTL = SA_AES_RSTCTL(self, 0x804)
        self.STAT = SA_AES_STAT(self, 0x814)
        self.PDBGCTL = SA_AES_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_AES_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_AES_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_AES_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_AES_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_AES_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_AES_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_AES_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_AES_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_AES_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_AES_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_AES_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_AES_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_AES_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_AES_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_AES_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_AES_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_AES_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_AES_INT_EVENT2_ICLR(self, 0x10A8)
        self.INT_EVENT3_IIDX = SA_AES_INT_EVENT3_IIDX(self, 0x10B0)
        self.INT_EVENT3_IMASK = SA_AES_INT_EVENT3_IMASK(self, 0x10B8)
        self.INT_EVENT3_RIS = SA_AES_INT_EVENT3_RIS(self, 0x10C0)
        self.INT_EVENT3_MIS = SA_AES_INT_EVENT3_MIS(self, 0x10C8)
        self.INT_EVENT3_ISET = SA_AES_INT_EVENT3_ISET(self, 0x10D0)
        self.INT_EVENT3_ICLR = SA_AES_INT_EVENT3_ICLR(self, 0x10D8)
        self.EVT_MODE = SA_AES_EVT_MODE(self, 0x10E0)
        self.ACTL0 = SA_AES_ACTL0(self, 0x1100)
        self.ACTL1 = SA_AES_ACTL1(self, 0x1104)
        self.ASTAT = SA_AES_ASTAT(self, 0x1108)
        self.AKEY = SA_AES_AKEY(self, 0x110C)
        self.ADIN = SA_AES_ADIN(self, 0x1110)
        self.ADOUT = SA_AES_ADOUT(self, 0x1114)
        self.AXDIN = SA_AES_AXDIN(self, 0x1118)
        self.AXIN = SA_AES_AXIN(self, 0x111C)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.ACTL = Subscriptor(self, "ACTL{}")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

AES = SA_AES(0x40442000, "AES")

class SA_DMA_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subscriber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-255 = connected to channelID = CHANID.")

class SA_DMA_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-255 = connected to channelID = CHANID.")

class SA_DMA_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-255 = connected to channelID = CHANID.")

class SA_DMA_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_DMA_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_DMA_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.DMACH0 = BitField(self, 0x00000001, "DMACH0", "DMA Channel 0 interrupt signal. Size counter reached zero (DMASZ=0).")
        self.DMACH1 = BitField(self, 0x00000002, "DMACH1", "DMA Channel 1 interrupt signal. Size counter reached zero (DMASZ=0).")
        self.DMACH2 = BitField(self, 0x00000004, "DMACH2", "DMA Channel 2 interrupt signal. Size counter reached zero (DMASZ=0).")
        self.DMACH3 = BitField(self, 0x00000008, "DMACH3", "DMA Channel 3 interrupt signal. Size counter reached zero (DMASZ=0).")
        self.DMACH4 = BitField(self, 0x00000010, "DMACH4", "DMA Channel 4 interrupt signal. Size counter reached zero (DMASZ=0).")
        self.DMACH5 = BitField(self, 0x00000020, "DMACH5", "DMA Channel 5 interrupt signal. Size counter reached zero (DMASZ=0).")
        self.DMACH6 = BitField(self, 0x00000040, "DMACH6", "DMA Channel 6 interrupt signal. Size counter reached zero (DMASZ=0).")
        self.PREIRQCH0 = BitField(self, 0x00010000, "PREIRQCH0", "Pre-IRQ for Channel 0. Size counter reached Pre-IRQ threshold.")
        self.PREIRQCH1 = BitField(self, 0x00020000, "PREIRQCH1", "Pre-IRQ for Channel 1. Size counter reached Pre-IRQ threshold.")
        self.PREIRQCH2 = BitField(self, 0x00040000, "PREIRQCH2", "Pre-IRQ for Channel 2. Size counter reached Pre-IRQ threshold.")
        self.ADDRERR = BitField(self, 0x01000000, "ADDRERR", "DMA address error, SRC address not reachable.")
        self.DATAERR = BitField(self, 0x02000000, "DATAERR", "DMA data error, SRC data might be corrupted (PAR or ECC error).")
        self.DMACH = Subscriptor(self, "DMACH{}")
        self.PREIRQCH = Subscriptor(self, "PREIRQCH{}")

class SA_DMA_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.DMACH0 = BitField(self, 0x00000001, "DMACH0", "DMA Channel 0 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH1 = BitField(self, 0x00000002, "DMACH1", "DMA Channel 1 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH2 = BitField(self, 0x00000004, "DMACH2", "DMA Channel 2 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH3 = BitField(self, 0x00000008, "DMACH3", "DMA Channel 3 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH4 = BitField(self, 0x00000010, "DMACH4", "DMA Channel 4 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH5 = BitField(self, 0x00000020, "DMACH5", "DMA Channel 5 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH6 = BitField(self, 0x00000040, "DMACH6", "DMA Channel 6 interrupt signals that size counter reached zero (DMASZ=0).")
        self.PREIRQCH0 = BitField(self, 0x00010000, "PREIRQCH0", "Pre-IRQ for Channel 0. Size counter reached Pre-IRQ threshold.")
        self.PREIRQCH1 = BitField(self, 0x00020000, "PREIRQCH1", "Pre-IRQ for Channel 1. Size counter reached Pre-IRQ threshold.")
        self.PREIRQCH2 = BitField(self, 0x00040000, "PREIRQCH2", "Pre-IRQ for Channel 2. Size counter reached Pre-IRQ threshold.")
        self.ADDRERR = BitField(self, 0x01000000, "ADDRERR", "DMA address error, SRC address not reachable.")
        self.DATAERR = BitField(self, 0x02000000, "DATAERR", "DMA data error, SRC data might be corrupted (PAR or ECC error).")
        self.DMACH = Subscriptor(self, "DMACH{}")
        self.PREIRQCH = Subscriptor(self, "PREIRQCH{}")

class SA_DMA_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.DMACH0 = BitField(self, 0x00000001, "DMACH0", "DMA Channel 0 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH1 = BitField(self, 0x00000002, "DMACH1", "DMA Channel 1 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH2 = BitField(self, 0x00000004, "DMACH2", "DMA Channel 2 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH3 = BitField(self, 0x00000008, "DMACH3", "DMA Channel 3 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH4 = BitField(self, 0x00000010, "DMACH4", "DMA Channel 4 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH5 = BitField(self, 0x00000020, "DMACH5", "DMA Channel 5 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH6 = BitField(self, 0x00000040, "DMACH6", "DMA Channel 6 interrupt signals that size counter reached zero (DMASZ=0).")
        self.PREIRQCH0 = BitField(self, 0x00010000, "PREIRQCH0", "Pre-IRQ for Channel 0. Size counter reached Pre-IRQ threshold.")
        self.PREIRQCH1 = BitField(self, 0x00020000, "PREIRQCH1", "Pre-IRQ for Channel 1. Size counter reached Pre-IRQ threshold.")
        self.PREIRQCH2 = BitField(self, 0x00040000, "PREIRQCH2", "Pre-IRQ for Channel 2. Size counter reached Pre-IRQ threshold.")
        self.ADDRERR = BitField(self, 0x01000000, "ADDRERR", "DMA address error, SRC address not reachable.")
        self.DATAERR = BitField(self, 0x02000000, "DATAERR", "DMA data error, SRC data might be corrupted (PAR or ECC error).")
        self.DMACH = Subscriptor(self, "DMACH{}")
        self.PREIRQCH = Subscriptor(self, "PREIRQCH{}")

class SA_DMA_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.DMACH0 = BitField(self, 0x00000001, "DMACH0", "DMA Channel 0 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH1 = BitField(self, 0x00000002, "DMACH1", "DMA Channel 1 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH2 = BitField(self, 0x00000004, "DMACH2", "DMA Channel 2 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH3 = BitField(self, 0x00000008, "DMACH3", "DMA Channel 3 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH4 = BitField(self, 0x00000010, "DMACH4", "DMA Channel 4 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH5 = BitField(self, 0x00000020, "DMACH5", "DMA Channel 5 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH6 = BitField(self, 0x00000040, "DMACH6", "DMA Channel 6 interrupt signals that size counter reached zero (DMASZ=0).")
        self.PREIRQCH0 = BitField(self, 0x00010000, "PREIRQCH0", "Pre-IRQ for Channel 0. Size counter reached Pre-IRQ threshold.")
        self.PREIRQCH1 = BitField(self, 0x00020000, "PREIRQCH1", "Pre-IRQ for Channel 1. Size counter reached Pre-IRQ threshold.")
        self.PREIRQCH2 = BitField(self, 0x00040000, "PREIRQCH2", "Pre-IRQ for Channel 2. Size counter reached Pre-IRQ threshold.")
        self.ADDRERR = BitField(self, 0x01000000, "ADDRERR", "DMA address error, SRC address not reachable.")
        self.DATAERR = BitField(self, 0x02000000, "DATAERR", "DMA data error, SRC data might be corrupted (PAR or ECC error).")
        self.DMACH = Subscriptor(self, "DMACH{}")
        self.PREIRQCH = Subscriptor(self, "PREIRQCH{}")

class SA_DMA_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.DMACH0 = BitField(self, 0x00000001, "DMACH0", "DMA Channel 0 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH1 = BitField(self, 0x00000002, "DMACH1", "DMA Channel 1 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH2 = BitField(self, 0x00000004, "DMACH2", "DMA Channel 2 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH3 = BitField(self, 0x00000008, "DMACH3", "DMA Channel 3 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH4 = BitField(self, 0x00000010, "DMACH4", "DMA Channel 4 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH5 = BitField(self, 0x00000020, "DMACH5", "DMA Channel 5 interrupt signals that size counter reached zero (DMASZ=0).")
        self.DMACH6 = BitField(self, 0x00000040, "DMACH6", "DMA Channel 6 interrupt signals that size counter reached zero (DMASZ=0).")
        self.PREIRQCH0 = BitField(self, 0x00010000, "PREIRQCH0", "Pre-IRQ for Channel 0. Size counter reached Pre-IRQ threshold.")
        self.PREIRQCH1 = BitField(self, 0x00020000, "PREIRQCH1", "Pre-IRQ for Channel 1. Size counter reached Pre-IRQ threshold.")
        self.PREIRQCH2 = BitField(self, 0x00040000, "PREIRQCH2", "Pre-IRQ for Channel 2. Size counter reached Pre-IRQ threshold.")
        self.ADDRERR = BitField(self, 0x01000000, "ADDRERR", "DMA address error, SRC address not reachable.")
        self.DATAERR = BitField(self, 0x02000000, "DATAERR", "DMA data error, SRC data might be corrupted (PAR or ECC error).")
        self.DMACH = Subscriptor(self, "DMACH{}")
        self.PREIRQCH = Subscriptor(self, "PREIRQCH{}")

class SA_DMA_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to interrupt event INT_EVENT[0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to generic event INT_EVENT[1]")

class SA_DMA_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the DMA: number of DMA channel minus one (e.g. 0-&gt;1ch, 2-&gt;3ch, 15-&gt;16ch).")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_DMA_PRIO(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PRIO", "DMA Channel Priority Control")
        self.DMAPRIO_ROUNDROBIN = BitField(self, 0x00000001, "DMAPRIO_ROUNDROBIN", "Round robin. This bit enables the round-robin DMA channel priorities.")
        self.DMAPRIO_BURSTSZ = BitField(self, 0x00030000, "DMAPRIO_BURSTSZ", "Define the burst size of a block transfer, before the priority is re-evaluated")

class SA_DMA_TCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TCTL", "DMA Trigger Select")
        self.DMATCTL_DMATSEL = BitField(self, 0x0000003F, "DMATCTL_DMATSEL", "DMA Trigger Select . Note: Reference the datasheet of the device to see the specific trigger mapping.")
        self.DMATCTL_DMATINT = BitField(self, 0x00000080, "DMATCTL_DMATINT", "DMA Trigger by Internal Channel")

class SA_DMA_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL", "DMA Channel Control")
        self.DMACTL_DMAREQ = BitField(self, 0x00000001, "DMACTL_DMAREQ", "DMA request. Software-controlled DMA start. DMAREQ is reset automatically.")
        self.DMACTL_DMAEN = BitField(self, 0x00000002, "DMACTL_DMAEN", "DMA enable")
        self.DMACTL_DMASRCWDTH = BitField(self, 0x00000300, "DMACTL_DMASRCWDTH", "DMA source width. This bit selects the source data width as a byte, half word, word or long word.")
        self.DMACTL_DMADSTWDTH = BitField(self, 0x00003000, "DMACTL_DMADSTWDTH", "DMA destination width. This bit selects the destination as a byte, half word, word or long word.")
        self.DMACTL_DMASRCINCR = BitField(self, 0x000F0000, "DMACTL_DMASRCINCR", "DMA source increment. This bit selects automatic incrementing or decrementing of the source address DMASA for each transfer. The amount of change to the DMASA is based on the definitin in the DMASRCWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMASA by 4.")
        self.DMACTL_DMADSTINCR = BitField(self, 0x00F00000, "DMACTL_DMADSTINCR", "DMA destination increment. This bit selects automatic incrementing or decrementing of the destination address DMADA for each transfer. The amount of change to the DMADA is based on the definitin in the DMADSTWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMADA by 4.")
        self.DMACTL_DMATM = BitField(self, 0x30000000, "DMACTL_DMATM", "DMA transfer mode register. Note: The repeat-single (2h) and repeat-block (3h) transfer are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration only the values for single (0h) and block (1h) transfer can be set.")
        self.DMACTL_DMAEM = BitField(self, 0x03000000, "DMACTL_DMAEM", "DMA extended mode. Note: The extended transfer modes are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration this register is a read-only register and reads 0x0.")
        self.DMACTL_DMAPREIRQ = BitField(self, 0x00000070, "DMACTL_DMAPREIRQ", "Enable an early IRQ event. This can help software to react quicker to and DMA done event or allows some additional configuration before the channel is complete. . Note: This register is only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC configuration this register is a read only value and always reads as 0x0.")

class SA_DMA_SA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SA", "DMA Channel Source Address")
        self.DMASA_ADDR = BitField(self, 0xFFFFFFFF, "DMASA_ADDR", "DMA Channel Source Address")

class SA_DMA_DA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DA", "DMA Channel Destination Address")
        self.DMADA_ADDR = BitField(self, 0xFFFFFFFF, "DMADA_ADDR", "DMA Channel Destination Address")

class SA_DMA_SZ(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SZ", "DMA Channel Size")
        self.DMASZ_SIZE = BitField(self, 0x0000FFFF, "DMASZ_SIZE", "DMA Channel Size in number of transfers")

class SA_DMA(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_DMA_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_DMA_FSUB_1(self, 0x404)
        self.FPUB_1 = SA_DMA_FPUB_1(self, 0x444)
        self.PDBGCTL = SA_DMA_PDBGCTL(self, 0x1018)
        self.IIDX = SA_DMA_IIDX(self, 0x1020)
        self.IMASK = SA_DMA_IMASK(self, 0x1028)
        self.RIS = SA_DMA_RIS(self, 0x1030)
        self.MIS = SA_DMA_MIS(self, 0x1038)
        self.ISET = SA_DMA_ISET(self, 0x1040)
        self.ICLR = SA_DMA_ICLR(self, 0x1048)
        self.EVT_MODE = SA_DMA_EVT_MODE(self, 0x10E0)
        self.DESC = SA_DMA_DESC(self, 0x10FC)
        self.PRIO = SA_DMA_PRIO(self, 0x1100)
        self.TCTL = SA_DMA_TCTL(self, 0x1110)
        self.CTL = SA_DMA_CTL(self, 0x1200)
        self.SA = SA_DMA_SA(self, 0x1204)
        self.DA = SA_DMA_DA(self, 0x1208)
        self.SZ = SA_DMA_SZ(self, 0x120C)
        self.FSUB = Subscriptor(self, "FSUB_{}")

DMA = SA_DMA(0x4042A000, "DMA")

class SA_OPA0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_OPA0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_OPA0_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_OPA0_CLKOVR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKOVR", "Clock Override")
        self.OVERRIDE = BitField(self, 0x00000001, "OVERRIDE", "Unlocks the functionality of [RUN_STOP] to override the automatic peripheral clock request")
        self.RUN_STOP = BitField(self, 0x00000002, "RUN_STOP", "If [OVERRIDE] is enabled, this register is used to manually control the peripheral's clock request to the system")

class SA_OPA0_PWRCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWRCTL", "Power Control")
        self.AUTO_OFF = BitField(self, 0x00000001, "AUTO_OFF", "When set the peripheral will remove its local IP request for enable so that it can be disabled if no other entities in the system are requesting it to be enabled.")

class SA_OPA0_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL", "Control Register")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "OAxn Enable.")

class SA_OPA0_CFGBASE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CFGBASE", "Configuration Base Register")
        self.GBW = BitField(self, 0x00000001, "GBW", "Select gain bandwidth which affects current as well the gain bandwidth. The lower gain bandwidth has lower current. See device specific datasheet for values. Can only be modified when STAT.BUSY=0.")
        self.RRI = BitField(self, 0x00000004, "RRI", "Rail-to-rail input enable. Can only be modified when STAT.BUSY=0")

class SA_OPA0_CFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CFG", "Configuration Register")
        self.CHOP = BitField(self, 0x00000003, "CHOP", "Chopping enable.")
        self.OUTPIN = BitField(self, 0x00000004, "OUTPIN", "Enable output pin")
        self.PSEL = BitField(self, 0x00000078, "PSEL", "Positive OA input selection. . Please refer to the device specific datasheet for exact channels available.")
        self.NSEL = BitField(self, 0x00000380, "NSEL", "Negative OA input selection.. Please refer to the device specific datasheet for exact channels available.")
        self.MSEL = BitField(self, 0x00001C00, "MSEL", "MSEL Mux selection. . Please refer to the device specific datasheet for exact channels available.")
        self.GAIN = BitField(self, 0x0000E000, "GAIN", "Gain setting. Refer to TRM for enumeration information.")

class SA_OPA0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RDY = BitField(self, 0x00000001, "RDY", "OA ready status.")

class SA_OPA0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_OPA0_PWREN(self, 0x800)
        self.RSTCTL = SA_OPA0_RSTCTL(self, 0x804)
        self.GPRCM_STAT = SA_OPA0_GPRCM_STAT(self, 0x814)
        self.CLKOVR = SA_OPA0_CLKOVR(self, 0x1010)
        self.PWRCTL = SA_OPA0_PWRCTL(self, 0x101C)
        self.CTL = SA_OPA0_CTL(self, 0x1100)
        self.CFGBASE = SA_OPA0_CFGBASE(self, 0x1104)
        self.CFG = SA_OPA0_CFG(self, 0x1108)
        self.STAT = SA_OPA0_STAT(self, 0x1118)

OPA0 = SA_OPA0(0x40020000, "OPA0")

class SA_OPA1_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_OPA1_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_OPA1_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_OPA1_CLKOVR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKOVR", "Clock Override")
        self.OVERRIDE = BitField(self, 0x00000001, "OVERRIDE", "Unlocks the functionality of [RUN_STOP] to override the automatic peripheral clock request")
        self.RUN_STOP = BitField(self, 0x00000002, "RUN_STOP", "If [OVERRIDE] is enabled, this register is used to manually control the peripheral's clock request to the system")

class SA_OPA1_PWRCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWRCTL", "Power Control")
        self.AUTO_OFF = BitField(self, 0x00000001, "AUTO_OFF", "When set the peripheral will remove its local IP request for enable so that it can be disabled if no other entities in the system are requesting it to be enabled.")

class SA_OPA1_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL", "Control Register")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "OAxn Enable.")

class SA_OPA1_CFGBASE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CFGBASE", "Configuration Base Register")
        self.GBW = BitField(self, 0x00000001, "GBW", "Select gain bandwidth which affects current as well the gain bandwidth. The lower gain bandwidth has lower current. See device specific datasheet for values. Can only be modified when STAT.BUSY=0.")
        self.RRI = BitField(self, 0x00000004, "RRI", "Rail-to-rail input enable. Can only be modified when STAT.BUSY=0")

class SA_OPA1_CFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CFG", "Configuration Register")
        self.CHOP = BitField(self, 0x00000003, "CHOP", "Chopping enable.")
        self.OUTPIN = BitField(self, 0x00000004, "OUTPIN", "Enable output pin")
        self.PSEL = BitField(self, 0x00000078, "PSEL", "Positive OA input selection. . Please refer to the device specific datasheet for exact channels available.")
        self.NSEL = BitField(self, 0x00000380, "NSEL", "Negative OA input selection.. Please refer to the device specific datasheet for exact channels available.")
        self.MSEL = BitField(self, 0x00001C00, "MSEL", "MSEL Mux selection. . Please refer to the device specific datasheet for exact channels available.")
        self.GAIN = BitField(self, 0x0000E000, "GAIN", "Gain setting. Refer to TRM for enumeration information.")

class SA_OPA1_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RDY = BitField(self, 0x00000001, "RDY", "OA ready status.")

class SA_OPA1(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_OPA1_PWREN(self, 0x800)
        self.RSTCTL = SA_OPA1_RSTCTL(self, 0x804)
        self.GPRCM_STAT = SA_OPA1_GPRCM_STAT(self, 0x814)
        self.CLKOVR = SA_OPA1_CLKOVR(self, 0x1010)
        self.PWRCTL = SA_OPA1_PWRCTL(self, 0x101C)
        self.CTL = SA_OPA1_CTL(self, 0x1100)
        self.CFGBASE = SA_OPA1_CFGBASE(self, 0x1104)
        self.CFG = SA_OPA1_CFG(self, 0x1108)
        self.STAT = SA_OPA1_STAT(self, 0x1118)

OPA1 = SA_OPA1(0x40022000, "OPA1")

class SA_TIMA0_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subsciber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMA0_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMA0_FPUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_0", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMA0_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMA0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_TIMA0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_TIMA0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_TIMA0_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_TIMA0_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUSCLK as clock source if enabled")

class SA_TIMA0_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_TIMA0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_TIMA0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.Z = BitField(self, 0x00000001, "Z", "Zero Event mask")
        self.L = BitField(self, 0x00000002, "L", "Load Event mask")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or Compare DN event mask CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or Compare DN event mask CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or Compare UP event mask CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or Compare UP event mask CCP1")
        self.F = BitField(self, 0x01000000, "F", "Fault Event mask")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow Event mask")
        self.CCD2 = BitField(self, 0x00000040, "CCD2", "Capture or Compare DN event mask CCP2")
        self.CCD3 = BitField(self, 0x00000080, "CCD3", "Capture or Compare DN event mask CCP3")
        self.CCU2 = BitField(self, 0x00000400, "CCU2", "Capture or Compare UP event mask CCP2")
        self.CCU3 = BitField(self, 0x00000800, "CCU3", "Capture or Compare UP event mask CCP3")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare DN event mask CCP4")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare DN event mask CCP5")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare UP event mask CCP4")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare UP event mask CCP5")
        self.REPC = BitField(self, 0x04000000, "REPC", "Repeat Counter Zero Event mask")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMA0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.F = BitField(self, 0x01000000, "F", "Fault")
        self.CCD2 = BitField(self, 0x00000040, "CCD2", "Capture or compare down event generated an interrupt CCP2")
        self.CCD3 = BitField(self, 0x00000080, "CCD3", "Capture or compare down event generated an interrupt CCP3")
        self.CCU2 = BitField(self, 0x00000400, "CCU2", "Capture or compare up event generated an interrupt CCP2")
        self.CCU3 = BitField(self, 0x00000800, "CCU3", "Capture or compare up event generated an interrupt CCP3")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event generated an interrupt CCD4")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event generated an interrupt CCD5")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event generated an interrupt CCU4")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event generated an interrupt CCP5")
        self.REPC = BitField(self, 0x04000000, "REPC", "Repeat Counter Zero")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMA0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.F = BitField(self, 0x01000000, "F", "Fault")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.CCD2 = BitField(self, 0x00000040, "CCD2", "Capture or compare down event generated an interrupt CCP2")
        self.CCD3 = BitField(self, 0x00000080, "CCD3", "Capture or compare down event generated an interrupt CCP3")
        self.CCU2 = BitField(self, 0x00000400, "CCU2", "Capture or compare up event generated an interrupt CCP2")
        self.CCU3 = BitField(self, 0x00000800, "CCU3", "Capture or compare up event generated an interrupt CCP3")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event generated an interrupt CCP4")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event generated an interrupt CCP5")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event generated an interrupt CCP4")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event generated an interrupt CCP5")
        self.REPC = BitField(self, 0x04000000, "REPC", "Repeat Counter Zero")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMA0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event SET")
        self.L = BitField(self, 0x00000002, "L", "Load event SET")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event SET")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event SET")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event SET")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event SET")
        self.F = BitField(self, 0x01000000, "F", "Fault event SET")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event SET")
        self.CCD2 = BitField(self, 0x00000040, "CCD2", "Capture or compare down event SET")
        self.CCD3 = BitField(self, 0x00000080, "CCD3", "Capture or compare down event SET")
        self.CCU2 = BitField(self, 0x00000400, "CCU2", "Capture or compare up event SET")
        self.CCU3 = BitField(self, 0x00000800, "CCU3", "Capture or compare up event SET")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event 4 SET")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event 5 SET")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event 4 SET")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event 5 SET")
        self.REPC = BitField(self, 0x04000000, "REPC", "Repeat Counter Zero event SET")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMA0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event CLEAR")
        self.L = BitField(self, 0x00000002, "L", "Load event CLEAR")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event CLEAR")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event CLEAR")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event CLEAR")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event CLEAR")
        self.F = BitField(self, 0x01000000, "F", "Fault event CLEAR")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event CLEAR")
        self.CCD2 = BitField(self, 0x00000040, "CCD2", "Capture or compare down event CLEAR")
        self.CCD3 = BitField(self, 0x00000080, "CCD3", "Capture or compare down event CLEAR")
        self.CCU2 = BitField(self, 0x00000400, "CCU2", "Capture or compare up event CLEAR")
        self.CCU3 = BitField(self, 0x00000800, "CCU3", "Capture or compare up event CLEAR")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event 4 CLEAR")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event 5 CLEAR")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event 4 CLEAR")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event 5 CLEAR")
        self.REPC = BitField(self, 0x04000000, "REPC", "Repeat Counter Zero event CLEAR")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMA0_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x29, "EVT_MODE", "Event Mode")
        self.EVT0_CFG = BitField(self, 0x00000003, "EVT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_TIMA0_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_TIMA0_CCPD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCPD", "CCP Direction")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1")
        self.C0CCP2 = BitField(self, 0x00000004, "C0CCP2", "Counter CCP2")
        self.C0CCP3 = BitField(self, 0x00000008, "C0CCP3", "Counter CCP3")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMA0_ODIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ODIS", "Output Disable")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP2 = BitField(self, 0x00000004, "C0CCP2", "Counter CCP2 Disable Mask. Defines whether CCP2 of Counter n is forced low or not")
        self.C0CCP3 = BitField(self, 0x00000008, "C0CCP3", "Counter CCP3 Disable Mask. Defines whether CCP3 of Counter n is forced low or not")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMA0_CCLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCLKCTL", "Counter Clock Control Register")
        self.CLKEN = BitField(self, 0x00000001, "CLKEN", "Clock Enable. Disables the clock gating to the module. SW has to explicitly program the value to 0 to gate the clock.")

class SA_TIMA0_CPS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPS", "Clock Prescale Register")
        self.PCNT = BitField(self, 0x000000FF, "PCNT", "Pre-Scale Count. This field specifies the pre-scale count value. The selected TIMCLK source is divided by a value of (PCNT+1). A PCNT value of 0 divides TIMCLK by 1, effectively bypassing the divider. A PCNT value of greater than 0 divides the TIMCLK source generating a slower clock")

class SA_TIMA0_CPSV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPSV", "Clock prescale count status register")
        self.CPSVAL = BitField(self, 0x000000FF, "CPSVAL", "Current Prescale Count Value")

class SA_TIMA0_CTTRIGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIGCTL", "Timer Cross Trigger Control Register")
        self.CTEN = BitField(self, 0x00000001, "CTEN", "Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system.. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register.")
        self.EVTCTEN = BitField(self, 0x00000002, "EVTCTEN", "Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path")
        self.EVTCTTRIGSEL = BitField(self, 0x000F0000, "EVTCTTRIGSEL", "Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path")

class SA_TIMA0_CTTRIG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIG", "Timer Cross Trigger Register")
        self.TRIG = BitField(self, 0x00000001, "TRIG", "Generate Cross Trigger. This bit when programmed will generate a synchronized trigger condition all the cross trigger enabled Timer instances including current timer instance.")

class SA_TIMA0_FSCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSCTL", "Fault Source Control")
        self.FCEN = BitField(self, 0x00000001, "FCEN", "This field controls whether the fault caused by the system clock fault is enable.. 0: DISABLE 1: ENABLE")
        self.FAC0EN = BitField(self, 0x00000002, "FAC0EN", "This field controls whether the fault signal detected by the analog comparator0 is enable. 0: DISABLE 1: ENABLE")
        self.FAC1EN = BitField(self, 0x00000004, "FAC1EN", "This field controls whether the fault signal detected by the analog comparator1 is enable. 0: DISABLE 1: ENABLE")
        self.FAC2EN = BitField(self, 0x00000008, "FAC2EN", "This field controls whether the fault signal detected by the analog comparator2 is enable. 0: DISABLE 1: ENABLE")
        self.FEX0EN = BitField(self, 0x00000010, "FEX0EN", "This field controls whether the fault caused by external fault pin0 is enable.. 0: DISABLE 1: ENABLE")
        self.FEX1EN = BitField(self, 0x00000020, "FEX1EN", "This field controls whether the fault caused by external fault pin1 is enable.. 0: DISABLE 1: ENABLE")
        self.FEX2EN = BitField(self, 0x00000040, "FEX2EN", "This field controls whether the fault caused by external fault pin2 is enable.. 0: DISABLE 1: ENABLE")
        self.FEXEN = Subscriptor(self, "FEX{}EN")
        self.FACEN = Subscriptor(self, "FAC{}EN")

class SA_TIMA0_GCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GCTL", "Shadow to active load mask")
        self.SHDWLDEN = BitField(self, 0x00000001, "SHDWLDEN", "Enables shadow to active load of bufferred registers and register fields.")

class SA_TIMA0_CTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTR", "Counter Register")
        self.CCTR = BitField(self, 0x0000FFFF, "CCTR", "Current Counter value")

class SA_TIMA0_CTRCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF80, "CTRCTL", "Counter Control Register")
        self.EN = BitField(self, 0x00000001, "EN", "Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively.")
        self.REPEAT = BitField(self, 0x0000000E, "REPEAT", "Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended.")
        self.CM = BitField(self, 0x00000030, "CM", "Count Mode")
        self.CVAE = BitField(self, 0x30000000, "CVAE", "Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active.")
        self.DRB = BitField(self, 0x00020000, "DRB", "Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode.")
        self.FB = BitField(self, 0x00040000, "FB", "Fault Behavior This bit specifies whether the counter continues running or suspends during a fault mode. There is a separate control under REPEAT to indicate whether counting is to suspend at next Counter==0")
        self.FRB = BitField(self, 0x00080000, "FRB", "Fault Resume Behavior This bit specifies what the device does following the release/exit of fault condition.")
        self.PLEN = BitField(self, 0x01000000, "PLEN", "Phase Load Enable. This bit allows the timer to have phase load feature.")
        self.SLZERCNEZ = BitField(self, 0x00800000, "SLZERCNEZ", "Suppress Load and Zero Events if Repeat Counter is Not Equal to Zero.. This bit suppresses the generation of the Z (zero) and L (load) events from the counter when the repeat counter (RC) value is not 0.")
        self.CLC = BitField(self, 0x00000380, "CLC", "Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CAC = BitField(self, 0x00001C00, "CAC", "Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CZC = BitField(self, 0x0000E000, "CZC", "Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")

class SA_TIMA0_LOAD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LOAD", "Load Register")
        self.LD = BitField(self, 0x0000FFFF, "LD", "Load Value")

class SA_TIMA0_CC0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CC0", "Capture or Compare Register 0 to Capture or Compare Register 1")
        self.CCVAL = BitField(self, 0x0000FFFF, "CCVAL", "Capture or compare value")

class SA_TIMA0_CC2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CC2", "Capture or Compare Register 0 to Capture or Compare Register 1")
        self.CCVAL = BitField(self, 0x0000FFFF, "CCVAL", "Capture or compare value")

class SA_TIMA0_CC4(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CC4", "Compare Register 4 to Compare Register 5")
        self.CCVAL = BitField(self, 0x0000FFFF, "CCVAL", "Capture or compare value")

class SA_TIMA0_CCCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCCTL0", "Capture or Compare Control Registers")
        self.CCOND = BitField(self, 0x00000007, "CCOND", "Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved")
        self.ACOND = BitField(self, 0x00000070, "ACOND", "Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved")
        self.LCOND = BitField(self, 0x00000700, "LCOND", "Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved")
        self.ZCOND = BitField(self, 0x00007000, "ZCOND", "Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved")
        self.COC = BitField(self, 0x00020000, "COC", "Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both).")
        self.SCERCNEZ = BitField(self, 0x02000000, "SCERCNEZ", "Suppress Compare Event if Repeat Counter is Not Equal to Zero. This bit suppresses the generation of the compare (CCD, CCU and RC) events from the counter when the repeat counter (RC) value is not 0.")
        self.CCUPD = BitField(self, 0x001C0000, "CCUPD", "Capture and Compare Update Method. This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0).")
        self.CCACTUPD = BitField(self, 0x1C000000, "CCACTUPD", "CCACT shadow register Update Method. This field controls how updates to the CCCACT shadow register are performed")
        self.CC2SELU = BitField(self, 0x01C00000, "CC2SELU", "Selects the source second CCU event.")
        self.CC2SELD = BitField(self, 0xE0000000, "CC2SELD", "Selects the source second CCD event.")

class SA_TIMA0_CCCTL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCCTL2", "Capture or Compare Control Registers")
        self.CCOND = BitField(self, 0x00000007, "CCOND", "Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved")
        self.ACOND = BitField(self, 0x00000070, "ACOND", "Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved")
        self.LCOND = BitField(self, 0x00000700, "LCOND", "Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved")
        self.ZCOND = BitField(self, 0x00007000, "ZCOND", "Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved")
        self.COC = BitField(self, 0x00020000, "COC", "Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both).")
        self.SCERCNEZ = BitField(self, 0x02000000, "SCERCNEZ", "Suppress Compare Event if Repeat Counter is Not Equal to Zero. This bit suppresses the generation of the compare (CCD, CCU and RC) events from the counter when the repeat counter (RCn) value is not 0.")
        self.CCUPD = BitField(self, 0x001C0000, "CCUPD", "Capture and Compare Update Method. This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0).")
        self.CCACTUPD = BitField(self, 0x1C000000, "CCACTUPD", "CCACT shadow register Update Method. This field controls how updates to the CCCACT shadow register are performed")
        self.CC2SELU = BitField(self, 0x01C00000, "CC2SELU", "Selects the source second CCU event.")
        self.CC2SELD = BitField(self, 0xE0000000, "CC2SELD", "Selects the source second CCD event.")

class SA_TIMA0_CCCTL4(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCCTL4", "Capture or Compare Control Registers")
        self.SCERCNEZ = BitField(self, 0x02000000, "SCERCNEZ", "Suppress Compare Event if Repeat Counter is Not Equal to Zero. This bit suppresses the generation of the compare (CCD, CCU and RC) events from the counter when the repeat counter (RC) value is not 0.")
        self.CCUPD = BitField(self, 0x001C0000, "CCUPD", "Capture and Compare Update Method. This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0).")

class SA_TIMA0_OCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OCTL0", "CCP Output Control Registers")
        self.CCPOINV = BitField(self, 0x00000010, "CCPOINV", "CCP Output Invert The output as selected by CCPO is conditionally inverted.")
        self.CCPIV = BitField(self, 0x00000020, "CCPIV", "CCP Initial Value This bit specifies the logical value put on the signal generator state while the counter is disabled (CTRCTL.EN == 0).")
        self.CCPO = BitField(self, 0x0000000F, "CCPO", "CCP Output Source")

class SA_TIMA0_OCTL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OCTL2", "CCP Output Control Registers")
        self.CCPOINV = BitField(self, 0x00000010, "CCPOINV", "CCP Output Invert The output as selected by CCPO is conditionally inverted.")
        self.CCPIV = BitField(self, 0x00000020, "CCPIV", "CCP Initial Value This bit specifies the logical value put on the signal generator state while the counter is disabled (CTRCTL.EN == 0).")
        self.CCPO = BitField(self, 0x0000000F, "CCPO", "CCP Output Source")

class SA_TIMA0_CCACT0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCACT0", "Capture or Compare Action Registers")
        self.ZACT = BitField(self, 0x00000003, "ZACT", "CCP Output Action on Zero Specifies what changes occur to CCP output as the result of a zero event.")
        self.LACT = BitField(self, 0x00000018, "LACT", "CCP Output Action on Load Specifies what changes occur to CCP output as the result of a load event.")
        self.CDACT = BitField(self, 0x000000C0, "CDACT", "CCP Output Action on Compare (Down) This field describes the resulting action of the signal generator upon detecting a compare event while counting down.")
        self.CUACT = BitField(self, 0x00000600, "CUACT", "CCP Output Action on Compare (Up) This field describes the resulting action of the signal generator upon detecting a compare event while counting up.")
        self.CC2DACT = BitField(self, 0x00003000, "CC2DACT", "CCP Output Action on CC2D event.")
        self.CC2UACT = BitField(self, 0x00018000, "CC2UACT", "CCP Output Action on CC2U event.")
        self.FENACT = BitField(self, 0x01C00000, "FENACT", "CCP Output Action on Fault Entry. This field describes the resulting action of the signal generator upon detecting a fault.")
        self.FEXACT = BitField(self, 0x0E000000, "FEXACT", "CCP Output Action on Fault Exit. This field describes the resulting action of the signal generator upon exiting the fault condition.")
        self.SWFRCACT = BitField(self, 0x30000000, "SWFRCACT", "CCP Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")
        self.SWFRCACT_CMPL = BitField(self, 0xC0000000, "SWFRCACT_CMPL", "CCP_CMPL Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")

class SA_TIMA0_CCACT2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCACT2", "Capture or Compare Action Registers")
        self.ZACT = BitField(self, 0x00000003, "ZACT", "CCP Output Action on Zero Specifies what changes occur to CCP output as the result of a zero event.")
        self.LACT = BitField(self, 0x00000018, "LACT", "CCP Output Action on Load Specifies what changes occur to CCP output as the result of a load event.")
        self.CDACT = BitField(self, 0x000000C0, "CDACT", "CCP Output Action on Compare (Down) This field describes the resulting action of the signal generator upon detecting a compare event while counting down.")
        self.CUACT = BitField(self, 0x00000600, "CUACT", "CCP Output Action on Compare (Up) This field describes the resulting action of the signal generator upon detecting a compare event while counting up.")
        self.CC2DACT = BitField(self, 0x00003000, "CC2DACT", "CCP Output Action on CC2D event.")
        self.CC2UACT = BitField(self, 0x00018000, "CC2UACT", "CCP Output Action on CC2U event.")
        self.FENACT = BitField(self, 0x01C00000, "FENACT", "CCP Output Action on Fault Entry. This field describes the resulting action of the signal generator upon detecting a fault.")
        self.FEXACT = BitField(self, 0x0E000000, "FEXACT", "CCP Output Action on Fault Exit. This field describes the resulting action of the signal generator upon exiting the fault condition.")
        self.SWFRCACT = BitField(self, 0x30000000, "SWFRCACT", "CCP Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")
        self.SWFRCACT_CMPL = BitField(self, 0xC0000000, "SWFRCACT_CMPL", "CCP_CMPL Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")

class SA_TIMA0_IFCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IFCTL0", "Input Filter Control Register")
        self.ISEL = BitField(self, 0x0000000F, "ISEL", "Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved")
        self.INV = BitField(self, 0x00000080, "INV", "Input Inversion This bit controls whether the selected input is inverted.")
        self.FP = BitField(self, 0x00000300, "FP", "Filter Period. This field specifies the sample period for the. input filter. I.e. The input is sampled for FP timer clocks during filtering.")
        self.CPV = BitField(self, 0x00000800, "CPV", "Consecutive Period/Voting Select. This bit controls whether the input filter uses a stricter consecutive period count or majority voting.")
        self.FE = BitField(self, 0x00001000, "FE", "Filter Enable. This bit controls whether the input is filtered by the input filter or bypasses to the edge detect.")

class SA_TIMA0_IFCTL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IFCTL2", "Input Filter Control Register")
        self.ISEL = BitField(self, 0x0000000F, "ISEL", "Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved")
        self.INV = BitField(self, 0x00000080, "INV", "Input Inversion This bit controls whether the selected input is inverted.")
        self.FP = BitField(self, 0x00000300, "FP", "Filter Period. This field specifies the sample period for the. input filter. I.e. The input is sampled for FP timer clocks during filtering.")
        self.CPV = BitField(self, 0x00000800, "CPV", "Consecutive Period/Voting Select. This bit controls whether the input filter uses a stricter consecutive period count or majority voting.")
        self.FE = BitField(self, 0x00001000, "FE", "Filter Enable. This bit controls whether the input is filtered by the input filter or bypasses to the edge detect.")

class SA_TIMA0_PL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PL", "Counter Register")
        self.PHASE = BitField(self, 0x0000FFFF, "PHASE", "Phase Load value")

class SA_TIMA0_DBCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DBCTL", "Dead Band insertion control register")
        self.RISEDELAY = BitField(self, 0x00000FFF, "RISEDELAY", "Rise Delay. The number of TIMCLK periods inserted between the fall of CCPi and the rise of CCPAo.")
        self.FALLDELAY = BitField(self, 0x0FFF0000, "FALLDELAY", "Fall Delay. The number of TIMCLK periods inserted between the fall of CCPi and the rise of CCPBo")
        self.M1_ENABLE = BitField(self, 0x00001000, "M1_ENABLE", "Dead Band Mode 1 Enable.")

class SA_TIMA0_TSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TSEL", "Trigger Select")
        self.ETSEL = BitField(self, 0x0000001F, "ETSEL", "External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. . Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use.")
        self.TE = BitField(self, 0x00000200, "TE", "Trigger Enable.. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field")

class SA_TIMA0_RC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RC", "Repeat counter")
        self.RC = BitField(self, 0x000000FF, "RC", "Repeat Counter Value")

class SA_TIMA0_RCLD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RCLD", "Repeat counter")
        self.RCLD = BitField(self, 0x000000FF, "RCLD", "Repeat Counter Load Value. This field provides the value loaded into the repeat counter at a load event following the repeat counter value equaling 0.")

class SA_TIMA0_FCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FCTL", "Fault Control Register")
        self.FIEN = BitField(self, 0x00000001, "FIEN", "Fault Input Enable. This bit enables the input for fault detection.")
        self.FI = BitField(self, 0x00000004, "FI", "Fault Input. Specifies whether the overall fault condition is dependent on the sensed fault pin.")
        self.TFIM = BitField(self, 0x00000080, "TFIM", "Trigger Fault Input Mask. Specifies whether the selected trigger participates as a fault input. If enabled and the trigger asserts, the trigger is treated as a fault.")
        self.FL = BitField(self, 0x00000018, "FL", "Fault Latch mode. Specifies whether the fault condition is latched and configures the latch clear conditions.")
        self.FSENAC0 = BitField(self, 0x00000100, "FSENAC0", "Specifies whether the analog comparator0 fault sense is high or low active")
        self.FSENAC1 = BitField(self, 0x00000200, "FSENAC1", "Specifies whether the analog comparator1 fault sense is high or low active")
        self.FSENAC2 = BitField(self, 0x00000400, "FSENAC2", "Specifies whether the analog comparator2 fault sense is high or low active")
        self.FSENEXT0 = BitField(self, 0x00000800, "FSENEXT0", "Specifies whether the external fault pin0 sense is high or low active")
        self.FSENEXT1 = BitField(self, 0x00001000, "FSENEXT1", "Specifies whether the external fault pin1 fault sense is high or low active")
        self.FSENEXT2 = BitField(self, 0x00002000, "FSENEXT2", "Specifies whether the external fault pin3 fault sense is high or low active")
        self.FSENAC = Subscriptor(self, "FSENAC{}")
        self.FSENEXT = Subscriptor(self, "FSENEXT{}")

class SA_TIMA0_FIFCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FIFCTL", "Fault input Filter control register")
        self.FP = BitField(self, 0x00000003, "FP", "Filter Period. This field specifies the sample period for the input filter. I.e. The input is sampled for FP timer clocks during filtering.")
        self.CPV = BitField(self, 0x00000008, "CPV", "Consecutive Period/Voting Select. This bit controls whether the input filter uses a stricter consecutive period count or majority voting.")
        self.FILTEN = BitField(self, 0x00000010, "FILTEN", "Filter Enable. This bit controls whether the input is filtered by the input filter or bypasses to go directly to the optional pre-scale filter and then to the edge detect.")

class SA_TIMA0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_TIMA0_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_TIMA0_FSUB_1(self, 0x404)
        self.FPUB_0 = SA_TIMA0_FPUB_0(self, 0x444)
        self.FPUB_1 = SA_TIMA0_FPUB_1(self, 0x448)
        self.PWREN = SA_TIMA0_PWREN(self, 0x800)
        self.RSTCTL = SA_TIMA0_RSTCTL(self, 0x804)
        self.STAT = SA_TIMA0_STAT(self, 0x814)
        self.CLKDIV = SA_TIMA0_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_TIMA0_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_TIMA0_PDBGCTL(self, 0x1018)
        self.IIDX = SA_TIMA0_IIDX(self, 0x1020)
        self.IMASK = SA_TIMA0_IMASK(self, 0x1028)
        self.RIS = SA_TIMA0_RIS(self, 0x1030)
        self.MIS = SA_TIMA0_MIS(self, 0x1038)
        self.ISET = SA_TIMA0_ISET(self, 0x1040)
        self.ICLR = SA_TIMA0_ICLR(self, 0x1048)
        self.EVT_MODE = SA_TIMA0_EVT_MODE(self, 0x10E0)
        self.DESC = SA_TIMA0_DESC(self, 0x10FC)
        self.CCPD = SA_TIMA0_CCPD(self, 0x1100)
        self.ODIS = SA_TIMA0_ODIS(self, 0x1104)
        self.CCLKCTL = SA_TIMA0_CCLKCTL(self, 0x1108)
        self.CPS = SA_TIMA0_CPS(self, 0x110C)
        self.CPSV = SA_TIMA0_CPSV(self, 0x1110)
        self.CTTRIGCTL = SA_TIMA0_CTTRIGCTL(self, 0x1114)
        self.CTTRIG = SA_TIMA0_CTTRIG(self, 0x111C)
        self.FSCTL = SA_TIMA0_FSCTL(self, 0x1120)
        self.GCTL = SA_TIMA0_GCTL(self, 0x1124)
        self.CTR = SA_TIMA0_CTR(self, 0x1800)
        self.CTRCTL = SA_TIMA0_CTRCTL(self, 0x1804)
        self.LOAD = SA_TIMA0_LOAD(self, 0x1808)
        self.CC0 = SA_TIMA0_CC0(self, 0x1810)
        self.CC1 = SA_TIMA0_CC0(self, 0x1814)
        self.CC2 = SA_TIMA0_CC2(self, 0x1818)
        self.CC3 = SA_TIMA0_CC2(self, 0x181C)
        self.CC4 = SA_TIMA0_CC4(self, 0x1820)
        self.CC5 = SA_TIMA0_CC4(self, 0x1824)
        self.CCCTL0 = SA_TIMA0_CCCTL0(self, 0x1830)
        self.CCCTL1 = SA_TIMA0_CCCTL0(self, 0x1834)
        self.CCCTL2 = SA_TIMA0_CCCTL2(self, 0x1838)
        self.CCCTL3 = SA_TIMA0_CCCTL2(self, 0x183C)
        self.CCCTL4 = SA_TIMA0_CCCTL4(self, 0x1840)
        self.CCCTL5 = SA_TIMA0_CCCTL4(self, 0x1844)
        self.OCTL0 = SA_TIMA0_OCTL0(self, 0x1850)
        self.OCTL1 = SA_TIMA0_OCTL0(self, 0x1854)
        self.OCTL2 = SA_TIMA0_OCTL2(self, 0x1858)
        self.OCTL3 = SA_TIMA0_OCTL2(self, 0x185C)
        self.CCACT0 = SA_TIMA0_CCACT0(self, 0x1870)
        self.CCACT1 = SA_TIMA0_CCACT0(self, 0x1874)
        self.CCACT2 = SA_TIMA0_CCACT2(self, 0x1878)
        self.CCACT3 = SA_TIMA0_CCACT2(self, 0x187C)
        self.IFCTL0 = SA_TIMA0_IFCTL0(self, 0x1880)
        self.IFCTL1 = SA_TIMA0_IFCTL0(self, 0x1884)
        self.IFCTL2 = SA_TIMA0_IFCTL2(self, 0x1888)
        self.IFCTL3 = SA_TIMA0_IFCTL2(self, 0x188C)
        self.PL = SA_TIMA0_PL(self, 0x18A0)
        self.DBCTL = SA_TIMA0_DBCTL(self, 0x18A4)
        self.TSEL = SA_TIMA0_TSEL(self, 0x18B0)
        self.RC = SA_TIMA0_RC(self, 0x18B4)
        self.RCLD = SA_TIMA0_RCLD(self, 0x18B8)
        self.FCTL = SA_TIMA0_FCTL(self, 0x18D0)
        self.FIFCTL = SA_TIMA0_FIFCTL(self, 0x18D4)
        self.IFCTL = Subscriptor(self, "IFCTL{}")
        self.CCACT = Subscriptor(self, "CCACT{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")
        self.OCTL = Subscriptor(self, "OCTL{}")
        self.CC = Subscriptor(self, "CC{}")
        self.FPUB = Subscriptor(self, "FPUB_{}")
        self.CCCTL = Subscriptor(self, "CCCTL{}")

TIMA0 = SA_TIMA0(0x40860000, "TIMA0")

class SA_TIMA1_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subsciber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMA1_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMA1_FPUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_0", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMA1_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMA1_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_TIMA1_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_TIMA1_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_TIMA1_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_TIMA1_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUSCLK as clock source if enabled")

class SA_TIMA1_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_TIMA1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_TIMA1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.Z = BitField(self, 0x00000001, "Z", "Zero Event mask")
        self.L = BitField(self, 0x00000002, "L", "Load Event mask")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or Compare DN event mask CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or Compare DN event mask CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or Compare UP event mask CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or Compare UP event mask CCP1")
        self.F = BitField(self, 0x01000000, "F", "Fault Event mask")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow Event mask")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare DN event mask CCP4")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare DN event mask CCP5")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare UP event mask CCP4")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare UP event mask CCP5")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMA1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.F = BitField(self, 0x01000000, "F", "Fault")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event generated an interrupt CCD4")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event generated an interrupt CCD5")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event generated an interrupt CCU4")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event generated an interrupt CCP5")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMA1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.F = BitField(self, 0x01000000, "F", "Fault")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event generated an interrupt CCP4")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event generated an interrupt CCP5")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event generated an interrupt CCP4")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event generated an interrupt CCP5")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMA1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event SET")
        self.L = BitField(self, 0x00000002, "L", "Load event SET")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event SET")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event SET")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event SET")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event SET")
        self.F = BitField(self, 0x01000000, "F", "Fault event SET")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event SET")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event 4 SET")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event 5 SET")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event 4 SET")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event 5 SET")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMA1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event CLEAR")
        self.L = BitField(self, 0x00000002, "L", "Load event CLEAR")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event CLEAR")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event CLEAR")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event CLEAR")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event CLEAR")
        self.F = BitField(self, 0x01000000, "F", "Fault event CLEAR")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event CLEAR")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event 4 CLEAR")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event 5 CLEAR")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event 4 CLEAR")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event 5 CLEAR")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMA1_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x29, "EVT_MODE", "Event Mode")
        self.EVT0_CFG = BitField(self, 0x00000003, "EVT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_TIMA1_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_TIMA1_CCPD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCPD", "CCP Direction")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMA1_ODIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ODIS", "Output Disable")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMA1_CCLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCLKCTL", "Counter Clock Control Register")
        self.CLKEN = BitField(self, 0x00000001, "CLKEN", "Clock Enable. Disables the clock gating to the module. SW has to explicitly program the value to 0 to gate the clock.")

class SA_TIMA1_CPS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPS", "Clock Prescale Register")
        self.PCNT = BitField(self, 0x000000FF, "PCNT", "Pre-Scale Count. This field specifies the pre-scale count value. The selected TIMCLK source is divided by a value of (PCNT+1). A PCNT value of 0 divides TIMCLK by 1, effectively bypassing the divider. A PCNT value of greater than 0 divides the TIMCLK source generating a slower clock")

class SA_TIMA1_CPSV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPSV", "Clock prescale count status register")
        self.CPSVAL = BitField(self, 0x000000FF, "CPSVAL", "Current Prescale Count Value")

class SA_TIMA1_CTTRIGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIGCTL", "Timer Cross Trigger Control Register")
        self.CTEN = BitField(self, 0x00000001, "CTEN", "Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system.. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register.")
        self.EVTCTEN = BitField(self, 0x00000002, "EVTCTEN", "Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path")
        self.EVTCTTRIGSEL = BitField(self, 0x000F0000, "EVTCTTRIGSEL", "Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path")

class SA_TIMA1_CTTRIG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIG", "Timer Cross Trigger Register")
        self.TRIG = BitField(self, 0x00000001, "TRIG", "Generate Cross Trigger. This bit when programmed will generate a synchronized trigger condition all the cross trigger enabled Timer instances including current timer instance.")

class SA_TIMA1_FSCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSCTL", "Fault Source Control")
        self.FCEN = BitField(self, 0x00000001, "FCEN", "This field controls whether the fault caused by the system clock fault is enable.. 0: DISABLE 1: ENABLE")
        self.FAC0EN = BitField(self, 0x00000002, "FAC0EN", "This field controls whether the fault signal detected by the analog comparator0 is enable. 0: DISABLE 1: ENABLE")
        self.FAC1EN = BitField(self, 0x00000004, "FAC1EN", "This field controls whether the fault signal detected by the analog comparator1 is enable. 0: DISABLE 1: ENABLE")
        self.FAC2EN = BitField(self, 0x00000008, "FAC2EN", "This field controls whether the fault signal detected by the analog comparator2 is enable. 0: DISABLE 1: ENABLE")
        self.FEX0EN = BitField(self, 0x00000010, "FEX0EN", "This field controls whether the fault caused by external fault pin0 is enable.. 0: DISABLE 1: ENABLE")
        self.FEX1EN = BitField(self, 0x00000020, "FEX1EN", "This field controls whether the fault caused by external fault pin1 is enable.. 0: DISABLE 1: ENABLE")
        self.FEX2EN = BitField(self, 0x00000040, "FEX2EN", "This field controls whether the fault caused by external fault pin2 is enable.. 0: DISABLE 1: ENABLE")
        self.FEXEN = Subscriptor(self, "FEX{}EN")
        self.FACEN = Subscriptor(self, "FAC{}EN")

class SA_TIMA1_GCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GCTL", "Shadow to active load mask")
        self.SHDWLDEN = BitField(self, 0x00000001, "SHDWLDEN", "Enables shadow to active load of bufferred registers and register fields.")

class SA_TIMA1_CTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTR", "Counter Register")
        self.CCTR = BitField(self, 0x0000FFFF, "CCTR", "Current Counter value")

class SA_TIMA1_CTRCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF80, "CTRCTL", "Counter Control Register")
        self.EN = BitField(self, 0x00000001, "EN", "Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively.")
        self.REPEAT = BitField(self, 0x0000000E, "REPEAT", "Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended.")
        self.CM = BitField(self, 0x00000030, "CM", "Count Mode")
        self.CVAE = BitField(self, 0x30000000, "CVAE", "Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active.")
        self.DRB = BitField(self, 0x00020000, "DRB", "Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode.")
        self.FB = BitField(self, 0x00040000, "FB", "Fault Behavior This bit specifies whether the counter continues running or suspends during a fault mode. There is a separate control under REPEAT to indicate whether counting is to suspend at next Counter==0")
        self.FRB = BitField(self, 0x00080000, "FRB", "Fault Resume Behavior This bit specifies what the device does following the release/exit of fault condition.")
        self.PLEN = BitField(self, 0x01000000, "PLEN", "Phase Load Enable. This bit allows the timer to have phase load feature.")
        self.CLC = BitField(self, 0x00000380, "CLC", "Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CAC = BitField(self, 0x00001C00, "CAC", "Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CZC = BitField(self, 0x0000E000, "CZC", "Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")

class SA_TIMA1_LOAD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LOAD", "Load Register")
        self.LD = BitField(self, 0x0000FFFF, "LD", "Load Value")

class SA_TIMA1_CC0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CC0", "Capture or Compare Register 0 to Capture or Compare Register 1")
        self.CCVAL = BitField(self, 0x0000FFFF, "CCVAL", "Capture or compare value")

class SA_TIMA1_CC4(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CC4", "Compare Register 4 to Compare Register 5")
        self.CCVAL = BitField(self, 0x0000FFFF, "CCVAL", "Capture or compare value")

class SA_TIMA1_CCCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCCTL0", "Capture or Compare Control Registers")
        self.CCOND = BitField(self, 0x00000007, "CCOND", "Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved")
        self.ACOND = BitField(self, 0x00000070, "ACOND", "Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved")
        self.LCOND = BitField(self, 0x00000700, "LCOND", "Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved")
        self.ZCOND = BitField(self, 0x00007000, "ZCOND", "Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved")
        self.COC = BitField(self, 0x00020000, "COC", "Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both).")
        self.CCUPD = BitField(self, 0x001C0000, "CCUPD", "Capture and Compare Update Method. This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0).")
        self.CCACTUPD = BitField(self, 0x1C000000, "CCACTUPD", "CCACT shadow register Update Method. This field controls how updates to the CCCACT shadow register are performed")
        self.CC2SELU = BitField(self, 0x01C00000, "CC2SELU", "Selects the source second CCU event.")
        self.CC2SELD = BitField(self, 0xE0000000, "CC2SELD", "Selects the source second CCD event.")

class SA_TIMA1_OCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OCTL0", "CCP Output Control Registers")
        self.CCPOINV = BitField(self, 0x00000010, "CCPOINV", "CCP Output Invert The output as selected by CCPO is conditionally inverted.")
        self.CCPIV = BitField(self, 0x00000020, "CCPIV", "CCP Initial Value This bit specifies the logical value put on the signal generator state while the counter is disabled (CTRCTL.EN == 0).")
        self.CCPO = BitField(self, 0x0000000F, "CCPO", "CCP Output Source")

class SA_TIMA1_CCACT0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCACT0", "Capture or Compare Action Registers")
        self.ZACT = BitField(self, 0x00000003, "ZACT", "CCP Output Action on Zero Specifies what changes occur to CCP output as the result of a zero event.")
        self.LACT = BitField(self, 0x00000018, "LACT", "CCP Output Action on Load Specifies what changes occur to CCP output as the result of a load event.")
        self.CDACT = BitField(self, 0x000000C0, "CDACT", "CCP Output Action on Compare (Down) This field describes the resulting action of the signal generator upon detecting a compare event while counting down.")
        self.CUACT = BitField(self, 0x00000600, "CUACT", "CCP Output Action on Compare (Up) This field describes the resulting action of the signal generator upon detecting a compare event while counting up.")
        self.CC2DACT = BitField(self, 0x00003000, "CC2DACT", "CCP Output Action on CC2D event.")
        self.CC2UACT = BitField(self, 0x00018000, "CC2UACT", "CCP Output Action on CC2U event.")
        self.FENACT = BitField(self, 0x01C00000, "FENACT", "CCP Output Action on Fault Entry. This field describes the resulting action of the signal generator upon detecting a fault.")
        self.FEXACT = BitField(self, 0x0E000000, "FEXACT", "CCP Output Action on Fault Exit. This field describes the resulting action of the signal generator upon exiting the fault condition.")
        self.SWFRCACT = BitField(self, 0x30000000, "SWFRCACT", "CCP Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")
        self.SWFRCACT_CMPL = BitField(self, 0xC0000000, "SWFRCACT_CMPL", "CCP_CMPL Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")

class SA_TIMA1_IFCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IFCTL0", "Input Filter Control Register")
        self.ISEL = BitField(self, 0x0000000F, "ISEL", "Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved")
        self.INV = BitField(self, 0x00000080, "INV", "Input Inversion This bit controls whether the selected input is inverted.")
        self.FP = BitField(self, 0x00000300, "FP", "Filter Period. This field specifies the sample period for the. input filter. I.e. The input is sampled for FP timer clocks during filtering.")
        self.CPV = BitField(self, 0x00000800, "CPV", "Consecutive Period/Voting Select. This bit controls whether the input filter uses a stricter consecutive period count or majority voting.")
        self.FE = BitField(self, 0x00001000, "FE", "Filter Enable. This bit controls whether the input is filtered by the input filter or bypasses to the edge detect.")

class SA_TIMA1_PL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PL", "Counter Register")
        self.PHASE = BitField(self, 0x0000FFFF, "PHASE", "Phase Load value")

class SA_TIMA1_DBCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DBCTL", "Dead Band insertion control register")
        self.RISEDELAY = BitField(self, 0x00000FFF, "RISEDELAY", "Rise Delay. The number of TIMCLK periods inserted between the fall of CCPi and the rise of CCPAo.")
        self.FALLDELAY = BitField(self, 0x0FFF0000, "FALLDELAY", "Fall Delay. The number of TIMCLK periods inserted between the fall of CCPi and the rise of CCPBo")
        self.M1_ENABLE = BitField(self, 0x00001000, "M1_ENABLE", "Dead Band Mode 1 Enable.")

class SA_TIMA1_TSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TSEL", "Trigger Select")
        self.ETSEL = BitField(self, 0x0000001F, "ETSEL", "External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. . Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use.")
        self.TE = BitField(self, 0x00000200, "TE", "Trigger Enable.. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field")

class SA_TIMA1_FCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FCTL", "Fault Control Register")
        self.FIEN = BitField(self, 0x00000001, "FIEN", "Fault Input Enable. This bit enables the input for fault detection.")
        self.FI = BitField(self, 0x00000004, "FI", "Fault Input. Specifies whether the overall fault condition is dependent on the sensed fault pin.")
        self.TFIM = BitField(self, 0x00000080, "TFIM", "Trigger Fault Input Mask. Specifies whether the selected trigger participates as a fault input. If enabled and the trigger asserts, the trigger is treated as a fault.")
        self.FL = BitField(self, 0x00000018, "FL", "Fault Latch mode. Specifies whether the fault condition is latched and configures the latch clear conditions.")
        self.FSENAC0 = BitField(self, 0x00000100, "FSENAC0", "Specifies whether the analog comparator0 fault sense is high or low active")
        self.FSENAC1 = BitField(self, 0x00000200, "FSENAC1", "Specifies whether the analog comparator1 fault sense is high or low active")
        self.FSENAC2 = BitField(self, 0x00000400, "FSENAC2", "Specifies whether the analog comparator2 fault sense is high or low active")
        self.FSENEXT0 = BitField(self, 0x00000800, "FSENEXT0", "Specifies whether the external fault pin0 sense is high or low active")
        self.FSENEXT1 = BitField(self, 0x00001000, "FSENEXT1", "Specifies whether the external fault pin1 fault sense is high or low active")
        self.FSENEXT2 = BitField(self, 0x00002000, "FSENEXT2", "Specifies whether the external fault pin3 fault sense is high or low active")
        self.FSENAC = Subscriptor(self, "FSENAC{}")
        self.FSENEXT = Subscriptor(self, "FSENEXT{}")

class SA_TIMA1_FIFCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FIFCTL", "Fault input Filter control register")
        self.FP = BitField(self, 0x00000003, "FP", "Filter Period. This field specifies the sample period for the input filter. I.e. The input is sampled for FP timer clocks during filtering.")
        self.CPV = BitField(self, 0x00000008, "CPV", "Consecutive Period/Voting Select. This bit controls whether the input filter uses a stricter consecutive period count or majority voting.")
        self.FILTEN = BitField(self, 0x00000010, "FILTEN", "Filter Enable. This bit controls whether the input is filtered by the input filter or bypasses to go directly to the optional pre-scale filter and then to the edge detect.")

class SA_TIMA1(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_TIMA1_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_TIMA1_FSUB_1(self, 0x404)
        self.FPUB_0 = SA_TIMA1_FPUB_0(self, 0x444)
        self.FPUB_1 = SA_TIMA1_FPUB_1(self, 0x448)
        self.PWREN = SA_TIMA1_PWREN(self, 0x800)
        self.RSTCTL = SA_TIMA1_RSTCTL(self, 0x804)
        self.STAT = SA_TIMA1_STAT(self, 0x814)
        self.CLKDIV = SA_TIMA1_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_TIMA1_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_TIMA1_PDBGCTL(self, 0x1018)
        self.IIDX = SA_TIMA1_IIDX(self, 0x1020)
        self.IMASK = SA_TIMA1_IMASK(self, 0x1028)
        self.RIS = SA_TIMA1_RIS(self, 0x1030)
        self.MIS = SA_TIMA1_MIS(self, 0x1038)
        self.ISET = SA_TIMA1_ISET(self, 0x1040)
        self.ICLR = SA_TIMA1_ICLR(self, 0x1048)
        self.EVT_MODE = SA_TIMA1_EVT_MODE(self, 0x10E0)
        self.DESC = SA_TIMA1_DESC(self, 0x10FC)
        self.CCPD = SA_TIMA1_CCPD(self, 0x1100)
        self.ODIS = SA_TIMA1_ODIS(self, 0x1104)
        self.CCLKCTL = SA_TIMA1_CCLKCTL(self, 0x1108)
        self.CPS = SA_TIMA1_CPS(self, 0x110C)
        self.CPSV = SA_TIMA1_CPSV(self, 0x1110)
        self.CTTRIGCTL = SA_TIMA1_CTTRIGCTL(self, 0x1114)
        self.CTTRIG = SA_TIMA1_CTTRIG(self, 0x111C)
        self.FSCTL = SA_TIMA1_FSCTL(self, 0x1120)
        self.GCTL = SA_TIMA1_GCTL(self, 0x1124)
        self.CTR = SA_TIMA1_CTR(self, 0x1800)
        self.CTRCTL = SA_TIMA1_CTRCTL(self, 0x1804)
        self.LOAD = SA_TIMA1_LOAD(self, 0x1808)
        self.CC0 = SA_TIMA1_CC0(self, 0x1810)
        self.CC1 = SA_TIMA1_CC0(self, 0x1814)
        self.CC4 = SA_TIMA1_CC4(self, 0x1820)
        self.CC5 = SA_TIMA1_CC4(self, 0x1824)
        self.CCCTL0 = SA_TIMA1_CCCTL0(self, 0x1830)
        self.CCCTL1 = SA_TIMA1_CCCTL0(self, 0x1834)
        self.OCTL0 = SA_TIMA1_OCTL0(self, 0x1850)
        self.OCTL1 = SA_TIMA1_OCTL0(self, 0x1854)
        self.CCACT0 = SA_TIMA1_CCACT0(self, 0x1870)
        self.CCACT1 = SA_TIMA1_CCACT0(self, 0x1874)
        self.IFCTL0 = SA_TIMA1_IFCTL0(self, 0x1880)
        self.IFCTL1 = SA_TIMA1_IFCTL0(self, 0x1884)
        self.PL = SA_TIMA1_PL(self, 0x18A0)
        self.DBCTL = SA_TIMA1_DBCTL(self, 0x18A4)
        self.TSEL = SA_TIMA1_TSEL(self, 0x18B0)
        self.FCTL = SA_TIMA1_FCTL(self, 0x18D0)
        self.FIFCTL = SA_TIMA1_FIFCTL(self, 0x18D4)
        self.IFCTL = Subscriptor(self, "IFCTL{}")
        self.CCACT = Subscriptor(self, "CCACT{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")
        self.OCTL = Subscriptor(self, "OCTL{}")
        self.CC = Subscriptor(self, "CC{}")
        self.FPUB = Subscriptor(self, "FPUB_{}")
        self.CCCTL = Subscriptor(self, "CCCTL{}")

TIMA1 = SA_TIMA1(0x40862000, "TIMA1")

class SA_UART3_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_UART3_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_UART3_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_UART3_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_UART3_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_UART3_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUS CLK as clock source if enabled")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")

class SA_UART3_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_UART3_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MIS registers. 15h-1Fh = Reserved")

class SA_UART3_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Enable UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Enable UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Enable UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Enable UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Enable Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Enable Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Enable UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Enable UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Enable UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Enable Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Enable UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Enable DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Enable DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Enable UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART3_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "UARTOUT Receive Time-Out Interrupt.")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "DMA Done on TX Event Channel Interrupt")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART3_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Masked UARTOUT Receive Time-Out Interrupt.")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Masked UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Masked UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Masked UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Masked UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Masked Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Masked Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Masked UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Masked UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Masked Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Masked UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Masked DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Masked DMA Done on TX Event Channel Interrupt")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART3_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Set UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Set UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Set UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Set UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Set Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Set Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Set UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Set UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Set UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Set Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Set UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Set DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Set DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Set UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART3_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Clear UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Clear UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Clear UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Clear UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Clear Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Clear Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Clear UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Clear UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Clear UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Clear Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Clear UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Clear DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Clear DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Clear UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART3_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved")

class SA_UART3_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Enable UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Enable UART Receive Interrupt.")

class SA_UART3_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "UART Receive Interrupt.")

class SA_UART3_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Masked UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Masked UART Receive Interrupt.")

class SA_UART3_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Set UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Set UART Receive Interrupt.")

class SA_UART3_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Clear UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Clear UART Receive Interrupt.")

class SA_UART3_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved")

class SA_UART3_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Enable UART Transmit Interrupt.")

class SA_UART3_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "UART Transmit Interrupt.")

class SA_UART3_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Masked UART Transmit Interrupt.")

class SA_UART3_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Set UART Transmit Interrupt.")

class SA_UART3_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Clear UART Transmit Interrupt.")

class SA_UART3_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.INT1_CFG = BitField(self, 0x0000000C, "INT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.INT2_CFG = BitField(self, 0x00000030, "INT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.INT_CFG = Subscriptor(self, "INT{}_CFG")

class SA_UART3_INTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INTCTL", "Interrupt control register")
        self.INTEVAL = BitField(self, 0x00000001, "INTEVAL", "Writing a 1 to this field re-evaluates the interrupt sources.")

class SA_UART3_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x38, "CTL0", "UART Control Register 0")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. . If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state.")
        self.HSE = BitField(self, 0x00018000, "HSE", "High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration. The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set).")
        self.LBE = BitField(self, 0x00000004, "LBE", "UART Loop Back Enable")
        self.RXE = BitField(self, 0x00000008, "RXE", "UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set.")
        self.TXE = BitField(self, 0x00000010, "TXE", "UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set.")
        self.RTS = BitField(self, 0x00001000, "RTS", "Request to Send . If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output.")
        self.RTSEN = BitField(self, 0x00002000, "RTSEN", "Enable hardware controlled Request to Send")
        self.CTSEN = BitField(self, 0x00004000, "CTSEN", "Enable Clear To Send")
        self.MODE = BitField(self, 0x00000700, "MODE", "Set the communication mode and protocol used.. (Not defined settings uses the default setting: 0)")
        self.FEN = BitField(self, 0x00020000, "FEN", "UART Enable FIFOs")
        self.TXD_OUT = BitField(self, 0x00000040, "TXD_OUT", "TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0.")
        self.TXD_OUT_EN = BitField(self, 0x00000020, "TXD_OUT_EN", "TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit.")
        self.MAJVOTE = BitField(self, 0x00040000, "MAJVOTE", "When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR. When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken.")
        self.MSBFIRST = BitField(self, 0x00080000, "MSBFIRST", "Most Significant Bit First. This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit.")

class SA_UART3_LCRH(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LCRH", "UART Line Control Register")
        self.BRK = BitField(self, 0x00000001, "BRK", "UART Send Break (for LIN Protocol)")
        self.PEN = BitField(self, 0x00000002, "PEN", "UART Parity Enable")
        self.EPS = BitField(self, 0x00000004, "EPS", "UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte")
        self.STP2 = BitField(self, 0x00000008, "STP2", "UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2.")
        self.WLEN = BitField(self, 0x00000030, "WLEN", "UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:")
        self.SPS = BitField(self, 0x00000040, "SPS", "UART Stick Parity Select. The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1.")
        self.SENDIDLE = BitField(self, 0x00000080, "SENDIDLE", "UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards.")
        self.EXTDIR_SETUP = BitField(self, 0x001F0000, "EXTDIR_SETUP", "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be set before the START bit is send")
        self.EXTDIR_HOLD = BitField(self, 0x03E00000, "EXTDIR_HOLD", "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be reset after the beginning of the stop bit. (If 2 STOP bits are enabled the beginning of the 2nd STOP bit.)")

class SA_UART3_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "UART Status Register")
        self.BUSY = BitField(self, 0x00000001, "BUSY", "UART Busy. This bit is set as soon as the transmit FIFO or TXDATA register becomes non-empty (regardless of whether UART is enabled) or if a receive data is currently ongoing (after the start edge have been detected until a complete byte, including all stop bits, has been received by the shift register). In IDLE_Line mode the Busy signal also stays set during the idle time generation.")
        self.TXFF = BitField(self, 0x00000080, "TXFF", "UART Transmit FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.RXFF = BitField(self, 0x00000008, "RXFF", "UART Receive FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.TXFE = BitField(self, 0x00000040, "TXFE", "UART Transmit FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.CTS = BitField(self, 0x00000100, "CTS", "Clear To Send")
        self.IDLE = BitField(self, 0x00000200, "IDLE", "IDLE mode has been detected in Idleline-Mulitprocessor-Mode.. The IDLE bit is used as an address tag for each block of characters. In idle-line multiprocessor format, this bit is set when a received character is an address.")
        self.RXFE = BitField(self, 0x00000004, "RXFE", "UART Receive FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")

class SA_UART3_IFLS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x22, "IFLS", "UART Interrupt FIFO Level Select Register")
        self.TXIFLSEL = BitField(self, 0x00000007, "TXIFLSEL", "UART Transmit Interrupt FIFO Level Select The trigger points for the transmit interrupt are as follows: . Note: for undefined settings the default configuration is used.")
        self.RXIFLSEL = BitField(self, 0x00000070, "RXIFLSEL", "UART Receive Interrupt FIFO Level Select The trigger points for the receive interrupt are as follows: . Note: In ULP domain the trigger levels are used for: 0: LVL_1_4 4: LVL_FULL For undefined settings the default configuration is used.")
        self.RXTOSEL = BitField(self, 0x00000F00, "RXTOSEL", "UART Receive Interrupt Timeout Select. When receiving no start edge for an additional character within the set bittimes a RX interrupt is set even if the FIFO level is not reached. A value of 0 disables this function.")

class SA_UART3_IBRD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IBRD", "UART Integer Baud-Rate Divisor Register")
        self.DIVINT = BitField(self, 0x0000FFFF, "DIVINT", "Integer Baud-Rate Divisor")

class SA_UART3_FBRD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FBRD", "UART Fractional Baud-Rate Divisor Register")
        self.DIVFRAC = BitField(self, 0x0000003F, "DIVFRAC", "Fractional Baud-Rate Divisor")

class SA_UART3_GFCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GFCTL", "Glitch Filter Control")
        self.AGFSEL = BitField(self, 0x00000600, "AGFSEL", "Analog Glitch Suppression Pulse Width. This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values.")
        self.AGFEN = BitField(self, 0x00000100, "AGFEN", "Analog Glitch Suppression Enable")

class SA_UART3_TXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TXDATA", "UART Transmit Data Register")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Data Transmitted or Received Data that is to be transmitted via the UART is written to this field. When read, this field contains the data that was received by the UART.")

class SA_UART3_RXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RXDATA", "UART Receive Data Register")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Received Data. When read, this field contains the data that was received by the UART.")
        self.FRMERR = BitField(self, 0x00000100, "FRMERR", "UART Framing Error Writing to this bit has no effect. The flag is cleared by writing 1 to the FRMERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO.")
        self.PARERR = BitField(self, 0x00000200, "PARERR", "UART Parity Error Writing to this bit has no effect. The flag is cleared by writing 1 to the PARERR bit in the UART EVENT ICLR register.")
        self.BRKERR = BitField(self, 0x00000400, "BRKERR", "UART Break Error Writing to this bit has no effect. The flag is cleared by writing 1 to the BRKERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.")
        self.OVRERR = BitField(self, 0x00000800, "OVRERR", "UART Receive Overrun Error Writing to this bit has no effect. The flag is cleared by writing 1 to the OVRERR bit in the UART EVENT ICLR register. In case of a receive FIFO overflow, the FIFO contents remain valid because no further data is written when the FIFO is full. Only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO.")
        self.NERR = BitField(self, 0x00001000, "NERR", "Noise Error.. Writing to this bit has no effect. The flag is cleared by writing 1 to the NERR bit in the UART EVENT ICLR register.")

class SA_UART3_AMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF, "AMASK", "Self Address Mask Register")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Self Address Mask for 9-Bit Mode This field contains the address mask that creates a set of addresses that should be matched. A 0 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register is don't care. A 1 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register must match.")

class SA_UART3_ADDR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ADDR", "Self Address Register")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Self Address for 9-Bit Mode This field contains the address that should be matched when UARTxAMASK is FFh.")

class SA_UART3(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_UART3_PWREN(self, 0x800)
        self.RSTCTL = SA_UART3_RSTCTL(self, 0x804)
        self.CLKCFG = SA_UART3_CLKCFG(self, 0x808)
        self.GPRCM_STAT = SA_UART3_GPRCM_STAT(self, 0x814)
        self.CLKDIV = SA_UART3_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_UART3_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_UART3_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_UART3_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_UART3_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_UART3_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_UART3_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_UART3_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_UART3_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_UART3_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_UART3_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_UART3_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_UART3_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_UART3_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_UART3_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_UART3_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_UART3_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_UART3_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_UART3_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_UART3_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_UART3_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_UART3_EVT_MODE(self, 0x10E0)
        self.INTCTL = SA_UART3_INTCTL(self, 0x10E4)
        self.CTL0 = SA_UART3_CTL0(self, 0x1100)
        self.LCRH = SA_UART3_LCRH(self, 0x1104)
        self.STAT = SA_UART3_STAT(self, 0x1108)
        self.IFLS = SA_UART3_IFLS(self, 0x110C)
        self.IBRD = SA_UART3_IBRD(self, 0x1110)
        self.FBRD = SA_UART3_FBRD(self, 0x1114)
        self.GFCTL = SA_UART3_GFCTL(self, 0x1118)
        self.TXDATA = SA_UART3_TXDATA(self, 0x1120)
        self.RXDATA = SA_UART3_RXDATA(self, 0x1124)
        self.AMASK = SA_UART3_AMASK(self, 0x1148)
        self.ADDR = SA_UART3_ADDR(self, 0x114C)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

UART3 = SA_UART3(0x40500000, "UART3")

class SA_UART0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_UART0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_UART0_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_UART0_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_UART0_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_UART0_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUS CLK as clock source if enabled")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")

class SA_UART0_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_UART0_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MIS registers. 15h-1Fh = Reserved")

class SA_UART0_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Enable UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Enable UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Enable UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Enable UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Enable Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Enable Positive Edge on UARTxRXD Interrupt.")
        self.LINOVF = BitField(self, 0x00000200, "LINOVF", "Enable LIN Hardware Counter Overflow Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Enable UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Enable UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Enable UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Enable Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Enable UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Enable DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Enable DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Enable UARTOUT Receive Time-Out Interrupt.")
        self.LINC0 = BitField(self, 0x00000080, "LINC0", "Enable LIN Capture 0 / Match Interrupt .")
        self.LINC1 = BitField(self, 0x00000100, "LINC1", "Enable LIN Capture 1 Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")
        self.LINC = Subscriptor(self, "LINC{}")

class SA_UART0_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "UARTOUT Receive Time-Out Interrupt.")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Positive Edge on UARTxRXD Interrupt.")
        self.LINC0 = BitField(self, 0x00000080, "LINC0", "LIN Capture 0 / Match Interrupt .")
        self.LINC1 = BitField(self, 0x00000100, "LINC1", "LIN Capture 1 Interrupt.")
        self.LINOVF = BitField(self, 0x00000200, "LINOVF", "LIN Hardware Counter Overflow Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "DMA Done on TX Event Channel Interrupt")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")
        self.LINC = Subscriptor(self, "LINC{}")

class SA_UART0_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Masked UARTOUT Receive Time-Out Interrupt.")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Masked UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Masked UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Masked UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Masked UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Masked Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Masked Positive Edge on UARTxRXD Interrupt.")
        self.LINC0 = BitField(self, 0x00000080, "LINC0", "Masked LIN Capture 0 / Match Interrupt .")
        self.LINC1 = BitField(self, 0x00000100, "LINC1", "Masked LIN Capture 1 Interrupt.")
        self.LINOVF = BitField(self, 0x00000200, "LINOVF", "Masked LIN Hardware Counter Overflow Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Masked UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Masked UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Masked Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Masked UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Masked DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Masked DMA Done on TX Event Channel Interrupt")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")
        self.LINC = Subscriptor(self, "LINC{}")

class SA_UART0_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Set UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Set UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Set UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Set UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Set Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Set Positive Edge on UARTxRXD Interrupt.")
        self.LINC0 = BitField(self, 0x00000080, "LINC0", "Set LIN Capture 0 / Match Interrupt .")
        self.LINC1 = BitField(self, 0x00000100, "LINC1", "Set LIN Capture 1 Interrupt.")
        self.LINOVF = BitField(self, 0x00000200, "LINOVF", "Set LIN Hardware Counter Overflow Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Set UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Set UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Set UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Set Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Set UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Set DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Set DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Set UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")
        self.LINC = Subscriptor(self, "LINC{}")

class SA_UART0_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Clear UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Clear UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Clear UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Clear UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Clear Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Clear Positive Edge on UARTxRXD Interrupt.")
        self.LINC0 = BitField(self, 0x00000080, "LINC0", "Clear LIN Capture 0 / Match Interrupt .")
        self.LINC1 = BitField(self, 0x00000100, "LINC1", "Clear LIN Capture 1 Interrupt.")
        self.LINOVF = BitField(self, 0x00000200, "LINOVF", "Clear LIN Hardware Counter Overflow Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Clear UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Clear UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Clear UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Clear Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Clear UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Clear DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Clear DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Clear UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")
        self.LINC = Subscriptor(self, "LINC{}")

class SA_UART0_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved")

class SA_UART0_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Enable UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Enable UART Receive Interrupt.")

class SA_UART0_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "UART Receive Interrupt.")

class SA_UART0_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Masked UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Masked UART Receive Interrupt.")

class SA_UART0_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Set UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Set UART Receive Interrupt.")

class SA_UART0_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Clear UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Clear UART Receive Interrupt.")

class SA_UART0_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved")

class SA_UART0_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Enable UART Transmit Interrupt.")

class SA_UART0_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "UART Transmit Interrupt.")

class SA_UART0_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Masked UART Transmit Interrupt.")

class SA_UART0_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Set UART Transmit Interrupt.")

class SA_UART0_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Clear UART Transmit Interrupt.")

class SA_UART0_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.INT1_CFG = BitField(self, 0x0000000C, "INT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.INT2_CFG = BitField(self, 0x00000030, "INT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.INT_CFG = Subscriptor(self, "INT{}_CFG")

class SA_UART0_INTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INTCTL", "Interrupt control register")
        self.INTEVAL = BitField(self, 0x00000001, "INTEVAL", "Writing a 1 to this field re-evaluates the interrupt sources.")

class SA_UART0_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x38, "CTL0", "UART Control Register 0")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. . If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state.")
        self.HSE = BitField(self, 0x00018000, "HSE", "High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration. The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set).")
        self.LBE = BitField(self, 0x00000004, "LBE", "UART Loop Back Enable")
        self.RXE = BitField(self, 0x00000008, "RXE", "UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set.")
        self.TXE = BitField(self, 0x00000010, "TXE", "UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set.")
        self.RTS = BitField(self, 0x00001000, "RTS", "Request to Send . If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output.")
        self.RTSEN = BitField(self, 0x00002000, "RTSEN", "Enable hardware controlled Request to Send")
        self.CTSEN = BitField(self, 0x00004000, "CTSEN", "Enable Clear To Send")
        self.MENC = BitField(self, 0x00000080, "MENC", "Manchester Encode enable")
        self.MODE = BitField(self, 0x00000700, "MODE", "Set the communication mode and protocol used.. (Not defined settings uses the default setting: 0)")
        self.FEN = BitField(self, 0x00020000, "FEN", "UART Enable FIFOs")
        self.TXD_OUT = BitField(self, 0x00000040, "TXD_OUT", "TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0.")
        self.TXD_OUT_EN = BitField(self, 0x00000020, "TXD_OUT_EN", "TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit.")
        self.MAJVOTE = BitField(self, 0x00040000, "MAJVOTE", "When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR. When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken.")
        self.MSBFIRST = BitField(self, 0x00080000, "MSBFIRST", "Most Significant Bit First. This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit.")

class SA_UART0_LCRH(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LCRH", "UART Line Control Register")
        self.BRK = BitField(self, 0x00000001, "BRK", "UART Send Break (for LIN Protocol)")
        self.PEN = BitField(self, 0x00000002, "PEN", "UART Parity Enable")
        self.EPS = BitField(self, 0x00000004, "EPS", "UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte")
        self.STP2 = BitField(self, 0x00000008, "STP2", "UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2.")
        self.WLEN = BitField(self, 0x00000030, "WLEN", "UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:")
        self.SPS = BitField(self, 0x00000040, "SPS", "UART Stick Parity Select. The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1.")
        self.SENDIDLE = BitField(self, 0x00000080, "SENDIDLE", "UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards.")
        self.EXTDIR_SETUP = BitField(self, 0x001F0000, "EXTDIR_SETUP", "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be set before the START bit is send")
        self.EXTDIR_HOLD = BitField(self, 0x03E00000, "EXTDIR_HOLD", "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be reset after the beginning of the stop bit. (If 2 STOP bits are enabled the beginning of the 2nd STOP bit.)")

class SA_UART0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "UART Status Register")
        self.BUSY = BitField(self, 0x00000001, "BUSY", "UART Busy. This bit is set as soon as the transmit FIFO or TXDATA register becomes non-empty (regardless of whether UART is enabled) or if a receive data is currently ongoing (after the start edge have been detected until a complete byte, including all stop bits, has been received by the shift register). In IDLE_Line mode the Busy signal also stays set during the idle time generation.")
        self.TXFF = BitField(self, 0x00000080, "TXFF", "UART Transmit FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.RXFF = BitField(self, 0x00000008, "RXFF", "UART Receive FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.TXFE = BitField(self, 0x00000040, "TXFE", "UART Transmit FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.CTS = BitField(self, 0x00000100, "CTS", "Clear To Send")
        self.IDLE = BitField(self, 0x00000200, "IDLE", "IDLE mode has been detected in Idleline-Mulitprocessor-Mode.. The IDLE bit is used as an address tag for each block of characters. In idle-line multiprocessor format, this bit is set when a received character is an address.")
        self.RXFE = BitField(self, 0x00000004, "RXFE", "UART Receive FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")

class SA_UART0_IFLS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x22, "IFLS", "UART Interrupt FIFO Level Select Register")
        self.TXIFLSEL = BitField(self, 0x00000007, "TXIFLSEL", "UART Transmit Interrupt FIFO Level Select The trigger points for the transmit interrupt are as follows: . Note: for undefined settings the default configuration is used.")
        self.RXIFLSEL = BitField(self, 0x00000070, "RXIFLSEL", "UART Receive Interrupt FIFO Level Select The trigger points for the receive interrupt are as follows: . Note: In ULP domain the trigger levels are used for: 0: LVL_1_4 4: LVL_FULL For undefined settings the default configuration is used.")
        self.RXTOSEL = BitField(self, 0x00000F00, "RXTOSEL", "UART Receive Interrupt Timeout Select. When receiving no start edge for an additional character within the set bittimes a RX interrupt is set even if the FIFO level is not reached. A value of 0 disables this function.")

class SA_UART0_IBRD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IBRD", "UART Integer Baud-Rate Divisor Register")
        self.DIVINT = BitField(self, 0x0000FFFF, "DIVINT", "Integer Baud-Rate Divisor")

class SA_UART0_FBRD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FBRD", "UART Fractional Baud-Rate Divisor Register")
        self.DIVFRAC = BitField(self, 0x0000003F, "DIVFRAC", "Fractional Baud-Rate Divisor")

class SA_UART0_GFCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GFCTL", "Glitch Filter Control")
        self.AGFSEL = BitField(self, 0x00000600, "AGFSEL", "Analog Glitch Suppression Pulse Width. This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values.")
        self.AGFEN = BitField(self, 0x00000100, "AGFEN", "Analog Glitch Suppression Enable")
        self.DGFSEL = BitField(self, 0x0000003F, "DGFSEL", "Glitch Suppression Pulse Width. This field controls the pulse width select for glitch suppression on the RX line. The value programmed in this field gives the number of cycles of fuctional clock up to which the glitch has to be suppressed on the RX line. In IRDA mode: The minimum pulse length for receive is given by: t(MIN) = (DGFSEL) / f(IRTXCLK)")
        self.CHAIN = BitField(self, 0x00000800, "CHAIN", "Analog and digital noise filters chaining enable.. 0 DISABLE: When 0, chaining is disabled and only digital filter output is available to IP logic for sampling 1 ENABLE: When 1, analog and digital glitch filters are chained and the output of the combination is made available to IP logic for sampling")

class SA_UART0_TXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TXDATA", "UART Transmit Data Register")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Data Transmitted or Received Data that is to be transmitted via the UART is written to this field. When read, this field contains the data that was received by the UART.")

class SA_UART0_RXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RXDATA", "UART Receive Data Register")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Received Data. When read, this field contains the data that was received by the UART.")
        self.FRMERR = BitField(self, 0x00000100, "FRMERR", "UART Framing Error Writing to this bit has no effect. The flag is cleared by writing 1 to the FRMERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO.")
        self.PARERR = BitField(self, 0x00000200, "PARERR", "UART Parity Error Writing to this bit has no effect. The flag is cleared by writing 1 to the PARERR bit in the UART EVENT ICLR register.")
        self.BRKERR = BitField(self, 0x00000400, "BRKERR", "UART Break Error Writing to this bit has no effect. The flag is cleared by writing 1 to the BRKERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.")
        self.OVRERR = BitField(self, 0x00000800, "OVRERR", "UART Receive Overrun Error Writing to this bit has no effect. The flag is cleared by writing 1 to the OVRERR bit in the UART EVENT ICLR register. In case of a receive FIFO overflow, the FIFO contents remain valid because no further data is written when the FIFO is full. Only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO.")
        self.NERR = BitField(self, 0x00001000, "NERR", "Noise Error.. Writing to this bit has no effect. The flag is cleared by writing 1 to the NERR bit in the UART EVENT ICLR register.")

class SA_UART0_LINCNT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LINCNT", "UART LIN Mode Counter Register")
        self.VALUE = BitField(self, 0x0000FFFF, "VALUE", "16 bit up counter clocked by the functional clock of the UART.")

class SA_UART0_LINCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LINCTL", "UART LIN Mode Control Register")
        self.CTRENA = BitField(self, 0x00000001, "CTRENA", "LIN Counter Enable. LIN counter will only count when enabled.")
        self.ZERONE = BitField(self, 0x00000002, "ZERONE", "Zero on negative Edge of RXD. When enabled the counter is set to 0 and starts counting on a negative edge of RXD")
        self.CNTRXLOW = BitField(self, 0x00000004, "CNTRXLOW", "Count while low Signal on RXD When counter is enabled and the signal on RXD is low, the counter increments.")
        self.LINC0CAP = BitField(self, 0x00000010, "LINC0CAP", "Capture Counter on negative RXD Edge. When enabled the counter value is captured to LINC0 register on each negative RXD edge. A LINC0 interrupt is triggered when enabled.")
        self.LINC1CAP = BitField(self, 0x00000020, "LINC1CAP", "Capture Counter on positive RXD Edge. When enabled the counter value is captured to LINC1 register on each positive RXD edge. A LINC1 interrupt is triggered when enabled.")
        self.LINC0_MATCH = BitField(self, 0x00000040, "LINC0_MATCH", "Counter Compare Match Mode When this bit is set to 1 a counter compare match with LINC0 register triggers an LINC0 interrupt when enabled.")
        self.LINCCAP = Subscriptor(self, "LINC{}CAP")

class SA_UART0_LINC0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LINC0", "UART LIN Mode Capture 0 Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "16 Bit Capture / Compare Register . Captures current LINCTR value on RXD falling edge and can generate a LINC0 interrupt when capture is enabled (LINC0CAP = 1). If compare mode is enabled (LINC0_MATCH = 1), a counter match can generate a LINC0 interrupt.")

class SA_UART0_LINC1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LINC1", "UART LIN Mode Capture 1 Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "16 Bit Capture / Compare Register . Captures current LINCTR value on RXD rising edge and can generate a LINC1 interrupt when capture is enabled (LINC1CAP = 1)")

class SA_UART0_IRCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IRCTL", "eUSCI_Ax IrDA Control Word Register")
        self.IRTXPL = BitField(self, 0x000000FC, "IRTXPL", "Transmit pulse length.. Pulse length t(PULSE) = (IRTXPLx + 1) / [2 * f(IRTXCLK)] (IRTXCLK = functional clock of the UART)")
        self.IRRXPL = BitField(self, 0x00000200, "IRRXPL", "IrDA receive input UCAxRXD polarity")
        self.IREN = BitField(self, 0x00000001, "IREN", "IrDA encoder/decoder enable")
        self.IRTXCLK = BitField(self, 0x00000002, "IRTXCLK", "IrDA transmit pulse clock select")

class SA_UART0_AMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF, "AMASK", "Self Address Mask Register")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Self Address Mask for 9-Bit Mode This field contains the address mask that creates a set of addresses that should be matched. A 0 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register is don't care. A 1 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register must match.")

class SA_UART0_ADDR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ADDR", "Self Address Register")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Self Address for 9-Bit Mode This field contains the address that should be matched when UARTxAMASK is FFh.")

class SA_UART0_CLKDIV2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV2", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_UART0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_UART0_PWREN(self, 0x800)
        self.RSTCTL = SA_UART0_RSTCTL(self, 0x804)
        self.CLKCFG = SA_UART0_CLKCFG(self, 0x808)
        self.GPRCM_STAT = SA_UART0_GPRCM_STAT(self, 0x814)
        self.CLKDIV = SA_UART0_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_UART0_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_UART0_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_UART0_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_UART0_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_UART0_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_UART0_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_UART0_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_UART0_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_UART0_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_UART0_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_UART0_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_UART0_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_UART0_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_UART0_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_UART0_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_UART0_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_UART0_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_UART0_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_UART0_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_UART0_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_UART0_EVT_MODE(self, 0x10E0)
        self.INTCTL = SA_UART0_INTCTL(self, 0x10E4)
        self.CTL0 = SA_UART0_CTL0(self, 0x1100)
        self.LCRH = SA_UART0_LCRH(self, 0x1104)
        self.STAT = SA_UART0_STAT(self, 0x1108)
        self.IFLS = SA_UART0_IFLS(self, 0x110C)
        self.IBRD = SA_UART0_IBRD(self, 0x1110)
        self.FBRD = SA_UART0_FBRD(self, 0x1114)
        self.GFCTL = SA_UART0_GFCTL(self, 0x1118)
        self.TXDATA = SA_UART0_TXDATA(self, 0x1120)
        self.RXDATA = SA_UART0_RXDATA(self, 0x1124)
        self.LINCNT = SA_UART0_LINCNT(self, 0x1130)
        self.LINCTL = SA_UART0_LINCTL(self, 0x1134)
        self.LINC0 = SA_UART0_LINC0(self, 0x1138)
        self.LINC1 = SA_UART0_LINC1(self, 0x113C)
        self.IRCTL = SA_UART0_IRCTL(self, 0x1140)
        self.AMASK = SA_UART0_AMASK(self, 0x1148)
        self.ADDR = SA_UART0_ADDR(self, 0x114C)
        self.CLKDIV2 = SA_UART0_CLKDIV2(self, 0x1160)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.LINC = Subscriptor(self, "LINC{}")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

UART0 = SA_UART0(0x40108000, "UART0")

class SA_UART1_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_UART1_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_UART1_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_UART1_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_UART1_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_UART1_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUS CLK as clock source if enabled")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")

class SA_UART1_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_UART1_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MIS registers. 15h-1Fh = Reserved")

class SA_UART1_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Enable UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Enable UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Enable UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Enable UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Enable Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Enable Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Enable UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Enable UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Enable UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Enable Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Enable UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Enable DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Enable DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Enable UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART1_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "UARTOUT Receive Time-Out Interrupt.")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "DMA Done on TX Event Channel Interrupt")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART1_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Masked UARTOUT Receive Time-Out Interrupt.")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Masked UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Masked UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Masked UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Masked UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Masked Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Masked Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Masked UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Masked UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Masked Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Masked UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Masked DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Masked DMA Done on TX Event Channel Interrupt")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART1_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Set UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Set UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Set UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Set UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Set Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Set Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Set UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Set UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Set UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Set Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Set UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Set DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Set DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Set UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART1_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Clear UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Clear UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Clear UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Clear UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Clear Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Clear Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Clear UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Clear UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Clear UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Clear Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Clear UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Clear DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Clear DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Clear UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART1_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved")

class SA_UART1_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Enable UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Enable UART Receive Interrupt.")

class SA_UART1_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "UART Receive Interrupt.")

class SA_UART1_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Masked UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Masked UART Receive Interrupt.")

class SA_UART1_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Set UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Set UART Receive Interrupt.")

class SA_UART1_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Clear UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Clear UART Receive Interrupt.")

class SA_UART1_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved")

class SA_UART1_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Enable UART Transmit Interrupt.")

class SA_UART1_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "UART Transmit Interrupt.")

class SA_UART1_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Masked UART Transmit Interrupt.")

class SA_UART1_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Set UART Transmit Interrupt.")

class SA_UART1_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Clear UART Transmit Interrupt.")

class SA_UART1_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.INT1_CFG = BitField(self, 0x0000000C, "INT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.INT2_CFG = BitField(self, 0x00000030, "INT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.INT_CFG = Subscriptor(self, "INT{}_CFG")

class SA_UART1_INTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INTCTL", "Interrupt control register")
        self.INTEVAL = BitField(self, 0x00000001, "INTEVAL", "Writing a 1 to this field re-evaluates the interrupt sources.")

class SA_UART1_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x38, "CTL0", "UART Control Register 0")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. . If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state.")
        self.HSE = BitField(self, 0x00018000, "HSE", "High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration. The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set).")
        self.LBE = BitField(self, 0x00000004, "LBE", "UART Loop Back Enable")
        self.RXE = BitField(self, 0x00000008, "RXE", "UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set.")
        self.TXE = BitField(self, 0x00000010, "TXE", "UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set.")
        self.RTS = BitField(self, 0x00001000, "RTS", "Request to Send . If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output.")
        self.RTSEN = BitField(self, 0x00002000, "RTSEN", "Enable hardware controlled Request to Send")
        self.CTSEN = BitField(self, 0x00004000, "CTSEN", "Enable Clear To Send")
        self.MODE = BitField(self, 0x00000700, "MODE", "Set the communication mode and protocol used.. (Not defined settings uses the default setting: 0)")
        self.FEN = BitField(self, 0x00020000, "FEN", "UART Enable FIFOs")
        self.TXD_OUT = BitField(self, 0x00000040, "TXD_OUT", "TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0.")
        self.TXD_OUT_EN = BitField(self, 0x00000020, "TXD_OUT_EN", "TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit.")
        self.MAJVOTE = BitField(self, 0x00040000, "MAJVOTE", "When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR. When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken.")
        self.MSBFIRST = BitField(self, 0x00080000, "MSBFIRST", "Most Significant Bit First. This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit.")

class SA_UART1_LCRH(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LCRH", "UART Line Control Register")
        self.BRK = BitField(self, 0x00000001, "BRK", "UART Send Break (for LIN Protocol)")
        self.PEN = BitField(self, 0x00000002, "PEN", "UART Parity Enable")
        self.EPS = BitField(self, 0x00000004, "EPS", "UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte")
        self.STP2 = BitField(self, 0x00000008, "STP2", "UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2.")
        self.WLEN = BitField(self, 0x00000030, "WLEN", "UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:")
        self.SPS = BitField(self, 0x00000040, "SPS", "UART Stick Parity Select. The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1.")
        self.SENDIDLE = BitField(self, 0x00000080, "SENDIDLE", "UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards.")
        self.EXTDIR_SETUP = BitField(self, 0x001F0000, "EXTDIR_SETUP", "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be set before the START bit is send")
        self.EXTDIR_HOLD = BitField(self, 0x03E00000, "EXTDIR_HOLD", "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be reset after the beginning of the stop bit. (If 2 STOP bits are enabled the beginning of the 2nd STOP bit.)")

class SA_UART1_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "UART Status Register")
        self.BUSY = BitField(self, 0x00000001, "BUSY", "UART Busy. This bit is set as soon as the transmit FIFO or TXDATA register becomes non-empty (regardless of whether UART is enabled) or if a receive data is currently ongoing (after the start edge have been detected until a complete byte, including all stop bits, has been received by the shift register). In IDLE_Line mode the Busy signal also stays set during the idle time generation.")
        self.TXFF = BitField(self, 0x00000080, "TXFF", "UART Transmit FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.RXFF = BitField(self, 0x00000008, "RXFF", "UART Receive FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.TXFE = BitField(self, 0x00000040, "TXFE", "UART Transmit FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.CTS = BitField(self, 0x00000100, "CTS", "Clear To Send")
        self.IDLE = BitField(self, 0x00000200, "IDLE", "IDLE mode has been detected in Idleline-Mulitprocessor-Mode.. The IDLE bit is used as an address tag for each block of characters. In idle-line multiprocessor format, this bit is set when a received character is an address.")
        self.RXFE = BitField(self, 0x00000004, "RXFE", "UART Receive FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")

class SA_UART1_IFLS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x22, "IFLS", "UART Interrupt FIFO Level Select Register")
        self.TXIFLSEL = BitField(self, 0x00000007, "TXIFLSEL", "UART Transmit Interrupt FIFO Level Select The trigger points for the transmit interrupt are as follows: . Note: for undefined settings the default configuration is used.")
        self.RXIFLSEL = BitField(self, 0x00000070, "RXIFLSEL", "UART Receive Interrupt FIFO Level Select The trigger points for the receive interrupt are as follows: . Note: In ULP domain the trigger levels are used for: 0: LVL_1_4 4: LVL_FULL For undefined settings the default configuration is used.")
        self.RXTOSEL = BitField(self, 0x00000F00, "RXTOSEL", "UART Receive Interrupt Timeout Select. When receiving no start edge for an additional character within the set bittimes a RX interrupt is set even if the FIFO level is not reached. A value of 0 disables this function.")

class SA_UART1_IBRD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IBRD", "UART Integer Baud-Rate Divisor Register")
        self.DIVINT = BitField(self, 0x0000FFFF, "DIVINT", "Integer Baud-Rate Divisor")

class SA_UART1_FBRD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FBRD", "UART Fractional Baud-Rate Divisor Register")
        self.DIVFRAC = BitField(self, 0x0000003F, "DIVFRAC", "Fractional Baud-Rate Divisor")

class SA_UART1_GFCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GFCTL", "Glitch Filter Control")
        self.AGFSEL = BitField(self, 0x00000600, "AGFSEL", "Analog Glitch Suppression Pulse Width. This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values.")
        self.AGFEN = BitField(self, 0x00000100, "AGFEN", "Analog Glitch Suppression Enable")

class SA_UART1_TXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TXDATA", "UART Transmit Data Register")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Data Transmitted or Received Data that is to be transmitted via the UART is written to this field. When read, this field contains the data that was received by the UART.")

class SA_UART1_RXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RXDATA", "UART Receive Data Register")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Received Data. When read, this field contains the data that was received by the UART.")
        self.FRMERR = BitField(self, 0x00000100, "FRMERR", "UART Framing Error Writing to this bit has no effect. The flag is cleared by writing 1 to the FRMERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO.")
        self.PARERR = BitField(self, 0x00000200, "PARERR", "UART Parity Error Writing to this bit has no effect. The flag is cleared by writing 1 to the PARERR bit in the UART EVENT ICLR register.")
        self.BRKERR = BitField(self, 0x00000400, "BRKERR", "UART Break Error Writing to this bit has no effect. The flag is cleared by writing 1 to the BRKERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.")
        self.OVRERR = BitField(self, 0x00000800, "OVRERR", "UART Receive Overrun Error Writing to this bit has no effect. The flag is cleared by writing 1 to the OVRERR bit in the UART EVENT ICLR register. In case of a receive FIFO overflow, the FIFO contents remain valid because no further data is written when the FIFO is full. Only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO.")
        self.NERR = BitField(self, 0x00001000, "NERR", "Noise Error.. Writing to this bit has no effect. The flag is cleared by writing 1 to the NERR bit in the UART EVENT ICLR register.")

class SA_UART1_AMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF, "AMASK", "Self Address Mask Register")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Self Address Mask for 9-Bit Mode This field contains the address mask that creates a set of addresses that should be matched. A 0 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register is don't care. A 1 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register must match.")

class SA_UART1_ADDR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ADDR", "Self Address Register")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Self Address for 9-Bit Mode This field contains the address that should be matched when UARTxAMASK is FFh.")

class SA_UART1(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_UART1_PWREN(self, 0x800)
        self.RSTCTL = SA_UART1_RSTCTL(self, 0x804)
        self.CLKCFG = SA_UART1_CLKCFG(self, 0x808)
        self.GPRCM_STAT = SA_UART1_GPRCM_STAT(self, 0x814)
        self.CLKDIV = SA_UART1_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_UART1_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_UART1_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_UART1_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_UART1_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_UART1_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_UART1_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_UART1_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_UART1_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_UART1_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_UART1_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_UART1_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_UART1_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_UART1_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_UART1_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_UART1_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_UART1_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_UART1_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_UART1_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_UART1_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_UART1_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_UART1_EVT_MODE(self, 0x10E0)
        self.INTCTL = SA_UART1_INTCTL(self, 0x10E4)
        self.CTL0 = SA_UART1_CTL0(self, 0x1100)
        self.LCRH = SA_UART1_LCRH(self, 0x1104)
        self.STAT = SA_UART1_STAT(self, 0x1108)
        self.IFLS = SA_UART1_IFLS(self, 0x110C)
        self.IBRD = SA_UART1_IBRD(self, 0x1110)
        self.FBRD = SA_UART1_FBRD(self, 0x1114)
        self.GFCTL = SA_UART1_GFCTL(self, 0x1118)
        self.TXDATA = SA_UART1_TXDATA(self, 0x1120)
        self.RXDATA = SA_UART1_RXDATA(self, 0x1124)
        self.AMASK = SA_UART1_AMASK(self, 0x1148)
        self.ADDR = SA_UART1_ADDR(self, 0x114C)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

UART1 = SA_UART1(0x40100000, "UART1")

class SA_UART2_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_UART2_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_UART2_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_UART2_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_UART2_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_UART2_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUS CLK as clock source if enabled")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")

class SA_UART2_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_UART2_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MIS registers. 15h-1Fh = Reserved")

class SA_UART2_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Enable UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Enable UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Enable UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Enable UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Enable Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Enable Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Enable UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Enable UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Enable UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Enable Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Enable UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Enable DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Enable DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Enable UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART2_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "UARTOUT Receive Time-Out Interrupt.")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "DMA Done on TX Event Channel Interrupt")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART2_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Masked UARTOUT Receive Time-Out Interrupt.")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Masked UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Masked UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Masked UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Masked UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Masked Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Masked Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Masked UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Masked UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Masked Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Masked UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Masked DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Masked DMA Done on TX Event Channel Interrupt")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART2_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Set UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Set UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Set UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Set UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Set Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Set Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Set UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Set UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Set UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Set Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Set UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Set DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Set DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Set UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART2_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.FRMERR = BitField(self, 0x00000002, "FRMERR", "Clear UART Framing Error Interrupt.")
        self.PARERR = BitField(self, 0x00000004, "PARERR", "Clear UART Parity Error Interrupt.")
        self.BRKERR = BitField(self, 0x00000008, "BRKERR", "Clear UART Break Error Interrupt.")
        self.OVRERR = BitField(self, 0x00000010, "OVRERR", "Clear UART Receive Overrun Error Interrupt.")
        self.RXNE = BitField(self, 0x00000020, "RXNE", "Clear Negative Edge on UARTxRXD Interrupt.")
        self.RXPE = BitField(self, 0x00000040, "RXPE", "Clear Positive Edge on UARTxRXD Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Clear UART Receive Interrupt.")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Clear UART Transmit Interrupt.")
        self.EOT = BitField(self, 0x00001000, "EOT", "Clear UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.")
        self.ADDR_MATCH = BitField(self, 0x00002000, "ADDR_MATCH", "Clear Address Match Interrupt.")
        self.CTS = BitField(self, 0x00004000, "CTS", "Clear UART Clear to Send Modem Interrupt.")
        self.DMA_DONE_RX = BitField(self, 0x00008000, "DMA_DONE_RX", "Clear DMA Done on RX Event Channel Interrupt")
        self.DMA_DONE_TX = BitField(self, 0x00010000, "DMA_DONE_TX", "Clear DMA Done on TX Event Channel Interrupt")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Clear UARTOUT Receive Time-Out Interrupt.")
        self.NERR = BitField(self, 0x00020000, "NERR", "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal")

class SA_UART2_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved")

class SA_UART2_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Enable UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Enable UART Receive Interrupt.")

class SA_UART2_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "UART Receive Interrupt.")

class SA_UART2_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Masked UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Masked UART Receive Interrupt.")

class SA_UART2_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Set UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Set UART Receive Interrupt.")

class SA_UART2_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.RTOUT = BitField(self, 0x00000001, "RTOUT", "Clear UARTOUT Receive Time-Out Interrupt.")
        self.RXINT = BitField(self, 0x00000400, "RXINT", "Clear UART Receive Interrupt.")

class SA_UART2_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved")

class SA_UART2_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Enable UART Transmit Interrupt.")

class SA_UART2_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "UART Transmit Interrupt.")

class SA_UART2_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Masked UART Transmit Interrupt.")

class SA_UART2_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Set UART Transmit Interrupt.")

class SA_UART2_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear")
        self.TXINT = BitField(self, 0x00000800, "TXINT", "Clear UART Transmit Interrupt.")

class SA_UART2_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT0]")
        self.INT1_CFG = BitField(self, 0x0000000C, "INT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT1]")
        self.INT2_CFG = BitField(self, 0x00000030, "INT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT2]")
        self.INT_CFG = Subscriptor(self, "INT{}_CFG")

class SA_UART2_INTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INTCTL", "Interrupt control register")
        self.INTEVAL = BitField(self, 0x00000001, "INTEVAL", "Writing a 1 to this field re-evaluates the interrupt sources.")

class SA_UART2_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x38, "CTL0", "UART Control Register 0")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. . If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state.")
        self.HSE = BitField(self, 0x00018000, "HSE", "High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration. The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set).")
        self.LBE = BitField(self, 0x00000004, "LBE", "UART Loop Back Enable")
        self.RXE = BitField(self, 0x00000008, "RXE", "UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set.")
        self.TXE = BitField(self, 0x00000010, "TXE", "UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set.")
        self.RTS = BitField(self, 0x00001000, "RTS", "Request to Send . If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output.")
        self.RTSEN = BitField(self, 0x00002000, "RTSEN", "Enable hardware controlled Request to Send")
        self.CTSEN = BitField(self, 0x00004000, "CTSEN", "Enable Clear To Send")
        self.MODE = BitField(self, 0x00000700, "MODE", "Set the communication mode and protocol used.. (Not defined settings uses the default setting: 0)")
        self.FEN = BitField(self, 0x00020000, "FEN", "UART Enable FIFOs")
        self.TXD_OUT = BitField(self, 0x00000040, "TXD_OUT", "TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0.")
        self.TXD_OUT_EN = BitField(self, 0x00000020, "TXD_OUT_EN", "TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit.")
        self.MAJVOTE = BitField(self, 0x00040000, "MAJVOTE", "When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR. When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken.")
        self.MSBFIRST = BitField(self, 0x00080000, "MSBFIRST", "Most Significant Bit First. This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit.")

class SA_UART2_LCRH(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LCRH", "UART Line Control Register")
        self.BRK = BitField(self, 0x00000001, "BRK", "UART Send Break (for LIN Protocol)")
        self.PEN = BitField(self, 0x00000002, "PEN", "UART Parity Enable")
        self.EPS = BitField(self, 0x00000004, "EPS", "UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte")
        self.STP2 = BitField(self, 0x00000008, "STP2", "UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2.")
        self.WLEN = BitField(self, 0x00000030, "WLEN", "UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:")
        self.SPS = BitField(self, 0x00000040, "SPS", "UART Stick Parity Select. The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1.")
        self.SENDIDLE = BitField(self, 0x00000080, "SENDIDLE", "UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards.")
        self.EXTDIR_SETUP = BitField(self, 0x001F0000, "EXTDIR_SETUP", "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be set before the START bit is send")
        self.EXTDIR_HOLD = BitField(self, 0x03E00000, "EXTDIR_HOLD", "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be reset after the beginning of the stop bit. (If 2 STOP bits are enabled the beginning of the 2nd STOP bit.)")

class SA_UART2_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "UART Status Register")
        self.BUSY = BitField(self, 0x00000001, "BUSY", "UART Busy. This bit is set as soon as the transmit FIFO or TXDATA register becomes non-empty (regardless of whether UART is enabled) or if a receive data is currently ongoing (after the start edge have been detected until a complete byte, including all stop bits, has been received by the shift register). In IDLE_Line mode the Busy signal also stays set during the idle time generation.")
        self.TXFF = BitField(self, 0x00000080, "TXFF", "UART Transmit FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.RXFF = BitField(self, 0x00000008, "RXFF", "UART Receive FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.TXFE = BitField(self, 0x00000040, "TXFE", "UART Transmit FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")
        self.CTS = BitField(self, 0x00000100, "CTS", "Clear To Send")
        self.IDLE = BitField(self, 0x00000200, "IDLE", "IDLE mode has been detected in Idleline-Mulitprocessor-Mode.. The IDLE bit is used as an address tag for each block of characters. In idle-line multiprocessor format, this bit is set when a received character is an address.")
        self.RXFE = BitField(self, 0x00000004, "RXFE", "UART Receive FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register.")

class SA_UART2_IFLS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x22, "IFLS", "UART Interrupt FIFO Level Select Register")
        self.TXIFLSEL = BitField(self, 0x00000007, "TXIFLSEL", "UART Transmit Interrupt FIFO Level Select The trigger points for the transmit interrupt are as follows: . Note: for undefined settings the default configuration is used.")
        self.RXIFLSEL = BitField(self, 0x00000070, "RXIFLSEL", "UART Receive Interrupt FIFO Level Select The trigger points for the receive interrupt are as follows: . Note: In ULP domain the trigger levels are used for: 0: LVL_1_4 4: LVL_FULL For undefined settings the default configuration is used.")
        self.RXTOSEL = BitField(self, 0x00000F00, "RXTOSEL", "UART Receive Interrupt Timeout Select. When receiving no start edge for an additional character within the set bittimes a RX interrupt is set even if the FIFO level is not reached. A value of 0 disables this function.")

class SA_UART2_IBRD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IBRD", "UART Integer Baud-Rate Divisor Register")
        self.DIVINT = BitField(self, 0x0000FFFF, "DIVINT", "Integer Baud-Rate Divisor")

class SA_UART2_FBRD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FBRD", "UART Fractional Baud-Rate Divisor Register")
        self.DIVFRAC = BitField(self, 0x0000003F, "DIVFRAC", "Fractional Baud-Rate Divisor")

class SA_UART2_GFCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GFCTL", "Glitch Filter Control")
        self.AGFSEL = BitField(self, 0x00000600, "AGFSEL", "Analog Glitch Suppression Pulse Width. This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values.")
        self.AGFEN = BitField(self, 0x00000100, "AGFEN", "Analog Glitch Suppression Enable")

class SA_UART2_TXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TXDATA", "UART Transmit Data Register")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Data Transmitted or Received Data that is to be transmitted via the UART is written to this field. When read, this field contains the data that was received by the UART.")

class SA_UART2_RXDATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RXDATA", "UART Receive Data Register")
        self.DATA = BitField(self, 0x000000FF, "DATA", "Received Data. When read, this field contains the data that was received by the UART.")
        self.FRMERR = BitField(self, 0x00000100, "FRMERR", "UART Framing Error Writing to this bit has no effect. The flag is cleared by writing 1 to the FRMERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO.")
        self.PARERR = BitField(self, 0x00000200, "PARERR", "UART Parity Error Writing to this bit has no effect. The flag is cleared by writing 1 to the PARERR bit in the UART EVENT ICLR register.")
        self.BRKERR = BitField(self, 0x00000400, "BRKERR", "UART Break Error Writing to this bit has no effect. The flag is cleared by writing 1 to the BRKERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.")
        self.OVRERR = BitField(self, 0x00000800, "OVRERR", "UART Receive Overrun Error Writing to this bit has no effect. The flag is cleared by writing 1 to the OVRERR bit in the UART EVENT ICLR register. In case of a receive FIFO overflow, the FIFO contents remain valid because no further data is written when the FIFO is full. Only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO.")
        self.NERR = BitField(self, 0x00001000, "NERR", "Noise Error.. Writing to this bit has no effect. The flag is cleared by writing 1 to the NERR bit in the UART EVENT ICLR register.")

class SA_UART2_AMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF, "AMASK", "Self Address Mask Register")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Self Address Mask for 9-Bit Mode This field contains the address mask that creates a set of addresses that should be matched. A 0 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register is don't care. A 1 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register must match.")

class SA_UART2_ADDR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ADDR", "Self Address Register")
        self.VALUE = BitField(self, 0x000000FF, "VALUE", "Self Address for 9-Bit Mode This field contains the address that should be matched when UARTxAMASK is FFh.")

class SA_UART2(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_UART2_PWREN(self, 0x800)
        self.RSTCTL = SA_UART2_RSTCTL(self, 0x804)
        self.CLKCFG = SA_UART2_CLKCFG(self, 0x808)
        self.GPRCM_STAT = SA_UART2_GPRCM_STAT(self, 0x814)
        self.CLKDIV = SA_UART2_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_UART2_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_UART2_PDBGCTL(self, 0x1018)
        self.INT_EVENT0_IIDX = SA_UART2_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_UART2_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_UART2_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_UART2_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_UART2_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_UART2_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_UART2_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_UART2_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_UART2_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_UART2_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_UART2_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_UART2_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_UART2_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_UART2_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_UART2_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_UART2_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_UART2_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_UART2_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_UART2_EVT_MODE(self, 0x10E0)
        self.INTCTL = SA_UART2_INTCTL(self, 0x10E4)
        self.CTL0 = SA_UART2_CTL0(self, 0x1100)
        self.LCRH = SA_UART2_LCRH(self, 0x1104)
        self.STAT = SA_UART2_STAT(self, 0x1108)
        self.IFLS = SA_UART2_IFLS(self, 0x110C)
        self.IBRD = SA_UART2_IBRD(self, 0x1110)
        self.FBRD = SA_UART2_FBRD(self, 0x1114)
        self.GFCTL = SA_UART2_GFCTL(self, 0x1118)
        self.TXDATA = SA_UART2_TXDATA(self, 0x1120)
        self.RXDATA = SA_UART2_RXDATA(self, 0x1124)
        self.AMASK = SA_UART2_AMASK(self, 0x1148)
        self.ADDR = SA_UART2_ADDR(self, 0x114C)
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

UART2 = SA_UART2(0x40102000, "UART2")

class SA_COMP0_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subscriber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_COMP0_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_COMP0_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_COMP0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_COMP0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_COMP0_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_COMP0_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_COMP0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x00000003, "STAT", "Interrupt index status")

class SA_COMP0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Masks COMPIFG")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Masks COMPINVIFG")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Masks OUTRDYIFG")

class SA_COMP0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Raw interrupt status for comparator output interrupt flag. The IES bit defines the transition of the comparator output setting this bit.")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Raw interrupt status for comparator output inverted interrupt flag. The IES bit defines the transition of the comparator output setting this bit.")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Raw interrupt status for comparator output ready interrupt flag. This bit is set when the comparator output is valid.")

class SA_COMP0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Masked interrupt status for COMPIFG")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Masked interrupt status for COMPINVIFG")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Masked interrupt status for OUTRDYIFG")

class SA_COMP0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Sets COMPIFG in RIS register")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Sets COMPINVIFG in RIS register")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Sets OUTRDYIFG in RIS register")

class SA_COMP0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Clears COMPIFG in RIS register")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Clears COMPINVIFG in RIS register")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Clears OUTRDYIFG in RIS register")

class SA_COMP0_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x9, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")

class SA_COMP0_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_COMP0_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL0", "Control 0")
        self.IPSEL = BitField(self, 0x00000007, "IPSEL", "Channel input selected for the positive terminal of the comparator if IPEN is set to 1.")
        self.IPEN = BitField(self, 0x00008000, "IPEN", "Channel input enable for the positive terminal of the comparator.")
        self.IMEN = BitField(self, 0x80000000, "IMEN", "Channel input enable for the negative terminal of the comparator.")
        self.IMSEL = BitField(self, 0x00070000, "IMSEL", "Channel input selected for the negative terminal of the comparator if IMEN is set to 1.")

class SA_COMP0_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL1", "Control 1")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "This bit turns on the comparator. When the comparator is turned off it consumes no power.")
        self.MODE = BitField(self, 0x00000002, "MODE", "This bit selects the comparator operating mode.")
        self.EXCH = BitField(self, 0x00000004, "EXCH", "This bit exchanges the comparator inputs and inverts the comparator output.")
        self.SHORT = BitField(self, 0x00000008, "SHORT", "This bit shorts the positive and negative input terminals of the comparator.")
        self.IES = BitField(self, 0x00000010, "IES", "This bit selected the interrupt edge for COMPIFG and COMPINVIFG.")
        self.HYST = BitField(self, 0x00000060, "HYST", "These bits select the hysteresis setting of the comparator.")
        self.OUTPOL = BitField(self, 0x00000080, "OUTPOL", "This bit selects the comparator output polarity.")
        self.FLTEN = BitField(self, 0x00000100, "FLTEN", "This bit enables the analog filter at comparator output.")
        self.FLTDLY = BitField(self, 0x00000600, "FLTDLY", "These bits select the comparator output filter delay. See the device-specific data sheet for specific values on comparator propagation delay for different filter delay settings.")
        self.WINCOMPEN = BitField(self, 0x00001000, "WINCOMPEN", "This bit enables window comparator operation of comparator.")

class SA_COMP0_CTL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL2", "Control 2")
        self.REFMODE = BitField(self, 0x00000001, "REFMODE", "This bit requests ULP_REF bandgap operation in static mode or sampled mode. The local reference buffer and 8-bit DAC inside comparator module are also configured accordingly. . Static mode operation offers higher accuracy but consumes higher current. Sampled mode operation consumes lower current but with relaxed reference voltage accuracy. Comparator requests for reference voltage from ULP_REF only when REFLVL &gt; 0.")
        self.REFSRC = BitField(self, 0x00000018, "REFSRC", "These bits select the reference source for the comparator.")
        self.REFSEL = BitField(self, 0x00000080, "REFSEL", "This bit selects if the selected reference voltage is applied to positive or negative terminal of the comparator.")
        self.DACCTL = BitField(self, 0x00010000, "DACCTL", "This bit determines if the comparator output or DACSW bit controls the selection between DACCODE0 and DACCODE1.")
        self.DACSW = BitField(self, 0x00020000, "DACSW", "This bit selects between DACCODE0 and DACCODE1 to 8-bit DAC when DACCTL bit is 1.")
        self.BLANKSRC = BitField(self, 0x00000700, "BLANKSRC", "These bits select the blanking source for the comparator.")
        self.SAMPMODE = BitField(self, 0x01000000, "SAMPMODE", "Enable sampled mode of comparator.")

class SA_COMP0_CTL3(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL3", "Control 3")
        self.DACCODE0 = BitField(self, 0x000000FF, "DACCODE0", "This is the first 8-bit DAC code. When the DAC code is 0x0 the DAC output will be 0 V. When the DAC code is 0xFF the DAC output will be selected reference voltage x 255/256.")
        self.DACCODE1 = BitField(self, 0x00FF0000, "DACCODE1", "This is the second 8-bit DAC code. When the DAC code is 0x0 the DAC output will be 0 V. When the DAC code is 0xFF the DAC output will be selected reference voltage x 255/256.")
        self.DACCODE = Subscriptor(self, "DACCODE{}")

class SA_COMP0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status")
        self.OUT = BitField(self, 0x00000001, "OUT", "This bit reflects the value of the comparator output. Writing to this bit has no effect on the comparator output.")

class SA_COMP0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_COMP0_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_COMP0_FSUB_1(self, 0x404)
        self.FPUB_1 = SA_COMP0_FPUB_1(self, 0x444)
        self.PWREN = SA_COMP0_PWREN(self, 0x800)
        self.RSTCTL = SA_COMP0_RSTCTL(self, 0x804)
        self.CLKCFG = SA_COMP0_CLKCFG(self, 0x808)
        self.GPRCM_STAT = SA_COMP0_GPRCM_STAT(self, 0x814)
        self.IIDX = SA_COMP0_IIDX(self, 0x1020)
        self.IMASK = SA_COMP0_IMASK(self, 0x1028)
        self.RIS = SA_COMP0_RIS(self, 0x1030)
        self.MIS = SA_COMP0_MIS(self, 0x1038)
        self.ISET = SA_COMP0_ISET(self, 0x1040)
        self.ICLR = SA_COMP0_ICLR(self, 0x1048)
        self.EVT_MODE = SA_COMP0_EVT_MODE(self, 0x10E0)
        self.DESC = SA_COMP0_DESC(self, 0x10FC)
        self.CTL0 = SA_COMP0_CTL0(self, 0x1100)
        self.CTL1 = SA_COMP0_CTL1(self, 0x1104)
        self.CTL2 = SA_COMP0_CTL2(self, 0x1108)
        self.CTL3 = SA_COMP0_CTL3(self, 0x110C)
        self.STAT = SA_COMP0_STAT(self, 0x1120)
        self.CTL = Subscriptor(self, "CTL{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")

COMP0 = SA_COMP0(0x40008000, "COMP0")

class SA_COMP1_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subscriber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_COMP1_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_COMP1_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_COMP1_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_COMP1_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_COMP1_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_COMP1_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_COMP1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x00000003, "STAT", "Interrupt index status")

class SA_COMP1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Masks COMPIFG")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Masks COMPINVIFG")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Masks OUTRDYIFG")

class SA_COMP1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Raw interrupt status for comparator output interrupt flag. The IES bit defines the transition of the comparator output setting this bit.")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Raw interrupt status for comparator output inverted interrupt flag. The IES bit defines the transition of the comparator output setting this bit.")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Raw interrupt status for comparator output ready interrupt flag. This bit is set when the comparator output is valid.")

class SA_COMP1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Masked interrupt status for COMPIFG")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Masked interrupt status for COMPINVIFG")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Masked interrupt status for OUTRDYIFG")

class SA_COMP1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Sets COMPIFG in RIS register")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Sets COMPINVIFG in RIS register")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Sets OUTRDYIFG in RIS register")

class SA_COMP1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Clears COMPIFG in RIS register")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Clears COMPINVIFG in RIS register")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Clears OUTRDYIFG in RIS register")

class SA_COMP1_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x9, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")

class SA_COMP1_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_COMP1_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL0", "Control 0")
        self.IPSEL = BitField(self, 0x00000007, "IPSEL", "Channel input selected for the positive terminal of the comparator if IPEN is set to 1.")
        self.IPEN = BitField(self, 0x00008000, "IPEN", "Channel input enable for the positive terminal of the comparator.")
        self.IMEN = BitField(self, 0x80000000, "IMEN", "Channel input enable for the negative terminal of the comparator.")
        self.IMSEL = BitField(self, 0x00070000, "IMSEL", "Channel input selected for the negative terminal of the comparator if IMEN is set to 1.")

class SA_COMP1_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL1", "Control 1")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "This bit turns on the comparator. When the comparator is turned off it consumes no power.")
        self.MODE = BitField(self, 0x00000002, "MODE", "This bit selects the comparator operating mode.")
        self.EXCH = BitField(self, 0x00000004, "EXCH", "This bit exchanges the comparator inputs and inverts the comparator output.")
        self.SHORT = BitField(self, 0x00000008, "SHORT", "This bit shorts the positive and negative input terminals of the comparator.")
        self.IES = BitField(self, 0x00000010, "IES", "This bit selected the interrupt edge for COMPIFG and COMPINVIFG.")
        self.HYST = BitField(self, 0x00000060, "HYST", "These bits select the hysteresis setting of the comparator.")
        self.OUTPOL = BitField(self, 0x00000080, "OUTPOL", "This bit selects the comparator output polarity.")
        self.FLTEN = BitField(self, 0x00000100, "FLTEN", "This bit enables the analog filter at comparator output.")
        self.FLTDLY = BitField(self, 0x00000600, "FLTDLY", "These bits select the comparator output filter delay. See the device-specific data sheet for specific values on comparator propagation delay for different filter delay settings.")
        self.WINCOMPEN = BitField(self, 0x00001000, "WINCOMPEN", "This bit enables window comparator operation of comparator.")

class SA_COMP1_CTL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL2", "Control 2")
        self.REFMODE = BitField(self, 0x00000001, "REFMODE", "This bit requests ULP_REF bandgap operation in static mode or sampled mode. The local reference buffer and 8-bit DAC inside comparator module are also configured accordingly. . Static mode operation offers higher accuracy but consumes higher current. Sampled mode operation consumes lower current but with relaxed reference voltage accuracy. Comparator requests for reference voltage from ULP_REF only when REFLVL &gt; 0.")
        self.REFSRC = BitField(self, 0x00000018, "REFSRC", "These bits select the reference source for the comparator.")
        self.REFSEL = BitField(self, 0x00000080, "REFSEL", "This bit selects if the selected reference voltage is applied to positive or negative terminal of the comparator.")
        self.DACCTL = BitField(self, 0x00010000, "DACCTL", "This bit determines if the comparator output or DACSW bit controls the selection between DACCODE0 and DACCODE1.")
        self.DACSW = BitField(self, 0x00020000, "DACSW", "This bit selects between DACCODE0 and DACCODE1 to 8-bit DAC when DACCTL bit is 1.")
        self.BLANKSRC = BitField(self, 0x00000700, "BLANKSRC", "These bits select the blanking source for the comparator.")
        self.SAMPMODE = BitField(self, 0x01000000, "SAMPMODE", "Enable sampled mode of comparator.")

class SA_COMP1_CTL3(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL3", "Control 3")
        self.DACCODE0 = BitField(self, 0x000000FF, "DACCODE0", "This is the first 8-bit DAC code. When the DAC code is 0x0 the DAC output will be 0 V. When the DAC code is 0xFF the DAC output will be selected reference voltage x 255/256.")
        self.DACCODE1 = BitField(self, 0x00FF0000, "DACCODE1", "This is the second 8-bit DAC code. When the DAC code is 0x0 the DAC output will be 0 V. When the DAC code is 0xFF the DAC output will be selected reference voltage x 255/256.")
        self.DACCODE = Subscriptor(self, "DACCODE{}")

class SA_COMP1_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status")
        self.OUT = BitField(self, 0x00000001, "OUT", "This bit reflects the value of the comparator output. Writing to this bit has no effect on the comparator output.")

class SA_COMP1(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_COMP1_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_COMP1_FSUB_1(self, 0x404)
        self.FPUB_1 = SA_COMP1_FPUB_1(self, 0x444)
        self.PWREN = SA_COMP1_PWREN(self, 0x800)
        self.RSTCTL = SA_COMP1_RSTCTL(self, 0x804)
        self.CLKCFG = SA_COMP1_CLKCFG(self, 0x808)
        self.GPRCM_STAT = SA_COMP1_GPRCM_STAT(self, 0x814)
        self.IIDX = SA_COMP1_IIDX(self, 0x1020)
        self.IMASK = SA_COMP1_IMASK(self, 0x1028)
        self.RIS = SA_COMP1_RIS(self, 0x1030)
        self.MIS = SA_COMP1_MIS(self, 0x1038)
        self.ISET = SA_COMP1_ISET(self, 0x1040)
        self.ICLR = SA_COMP1_ICLR(self, 0x1048)
        self.EVT_MODE = SA_COMP1_EVT_MODE(self, 0x10E0)
        self.DESC = SA_COMP1_DESC(self, 0x10FC)
        self.CTL0 = SA_COMP1_CTL0(self, 0x1100)
        self.CTL1 = SA_COMP1_CTL1(self, 0x1104)
        self.CTL2 = SA_COMP1_CTL2(self, 0x1108)
        self.CTL3 = SA_COMP1_CTL3(self, 0x110C)
        self.STAT = SA_COMP1_STAT(self, 0x1120)
        self.CTL = Subscriptor(self, "CTL{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")

COMP1 = SA_COMP1(0x4000A000, "COMP1")

class SA_COMP2_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subscriber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_COMP2_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_COMP2_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_COMP2_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_COMP2_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_COMP2_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "Peripheral Clock Configuration Register")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to Allow State Change -- 0xA9")
        self.BLOCKASYNC = BitField(self, 0x00000100, "BLOCKASYNC", "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz")

class SA_COMP2_GPRCM_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GPRCM_STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_COMP2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x00000003, "STAT", "Interrupt index status")

class SA_COMP2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Masks COMPIFG")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Masks COMPINVIFG")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Masks OUTRDYIFG")

class SA_COMP2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Raw interrupt status for comparator output interrupt flag. The IES bit defines the transition of the comparator output setting this bit.")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Raw interrupt status for comparator output inverted interrupt flag. The IES bit defines the transition of the comparator output setting this bit.")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Raw interrupt status for comparator output ready interrupt flag. This bit is set when the comparator output is valid.")

class SA_COMP2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Masked interrupt status for COMPIFG")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Masked interrupt status for COMPINVIFG")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Masked interrupt status for OUTRDYIFG")

class SA_COMP2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Sets COMPIFG in RIS register")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Sets COMPINVIFG in RIS register")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Sets OUTRDYIFG in RIS register")

class SA_COMP2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.COMPIFG = BitField(self, 0x00000002, "COMPIFG", "Clears COMPIFG in RIS register")
        self.COMPINVIFG = BitField(self, 0x00000004, "COMPINVIFG", "Clears COMPINVIFG in RIS register")
        self.OUTRDYIFG = BitField(self, 0x00000008, "OUTRDYIFG", "Clears OUTRDYIFG in RIS register")

class SA_COMP2_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x9, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")

class SA_COMP2_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_COMP2_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL0", "Control 0")
        self.IPSEL = BitField(self, 0x00000007, "IPSEL", "Channel input selected for the positive terminal of the comparator if IPEN is set to 1.")
        self.IPEN = BitField(self, 0x00008000, "IPEN", "Channel input enable for the positive terminal of the comparator.")
        self.IMEN = BitField(self, 0x80000000, "IMEN", "Channel input enable for the negative terminal of the comparator.")
        self.IMSEL = BitField(self, 0x00070000, "IMSEL", "Channel input selected for the negative terminal of the comparator if IMEN is set to 1.")

class SA_COMP2_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL1", "Control 1")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "This bit turns on the comparator. When the comparator is turned off it consumes no power.")
        self.MODE = BitField(self, 0x00000002, "MODE", "This bit selects the comparator operating mode.")
        self.EXCH = BitField(self, 0x00000004, "EXCH", "This bit exchanges the comparator inputs and inverts the comparator output.")
        self.SHORT = BitField(self, 0x00000008, "SHORT", "This bit shorts the positive and negative input terminals of the comparator.")
        self.IES = BitField(self, 0x00000010, "IES", "This bit selected the interrupt edge for COMPIFG and COMPINVIFG.")
        self.HYST = BitField(self, 0x00000060, "HYST", "These bits select the hysteresis setting of the comparator.")
        self.OUTPOL = BitField(self, 0x00000080, "OUTPOL", "This bit selects the comparator output polarity.")
        self.FLTEN = BitField(self, 0x00000100, "FLTEN", "This bit enables the analog filter at comparator output.")
        self.FLTDLY = BitField(self, 0x00000600, "FLTDLY", "These bits select the comparator output filter delay. See the device-specific data sheet for specific values on comparator propagation delay for different filter delay settings.")
        self.WINCOMPEN = BitField(self, 0x00001000, "WINCOMPEN", "This bit enables window comparator operation of comparator.")

class SA_COMP2_CTL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL2", "Control 2")
        self.REFMODE = BitField(self, 0x00000001, "REFMODE", "This bit requests ULP_REF bandgap operation in static mode or sampled mode. The local reference buffer and 8-bit DAC inside comparator module are also configured accordingly. . Static mode operation offers higher accuracy but consumes higher current. Sampled mode operation consumes lower current but with relaxed reference voltage accuracy. Comparator requests for reference voltage from ULP_REF only when REFLVL &gt; 0.")
        self.REFSRC = BitField(self, 0x00000018, "REFSRC", "These bits select the reference source for the comparator.")
        self.REFSEL = BitField(self, 0x00000080, "REFSEL", "This bit selects if the selected reference voltage is applied to positive or negative terminal of the comparator.")
        self.DACCTL = BitField(self, 0x00010000, "DACCTL", "This bit determines if the comparator output or DACSW bit controls the selection between DACCODE0 and DACCODE1.")
        self.DACSW = BitField(self, 0x00020000, "DACSW", "This bit selects between DACCODE0 and DACCODE1 to 8-bit DAC when DACCTL bit is 1.")
        self.BLANKSRC = BitField(self, 0x00000700, "BLANKSRC", "These bits select the blanking source for the comparator.")
        self.SAMPMODE = BitField(self, 0x01000000, "SAMPMODE", "Enable sampled mode of comparator.")

class SA_COMP2_CTL3(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL3", "Control 3")
        self.DACCODE0 = BitField(self, 0x000000FF, "DACCODE0", "This is the first 8-bit DAC code. When the DAC code is 0x0 the DAC output will be 0 V. When the DAC code is 0xFF the DAC output will be selected reference voltage x 255/256.")
        self.DACCODE1 = BitField(self, 0x00FF0000, "DACCODE1", "This is the second 8-bit DAC code. When the DAC code is 0x0 the DAC output will be 0 V. When the DAC code is 0xFF the DAC output will be selected reference voltage x 255/256.")
        self.DACCODE = Subscriptor(self, "DACCODE{}")

class SA_COMP2_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status")
        self.OUT = BitField(self, 0x00000001, "OUT", "This bit reflects the value of the comparator output. Writing to this bit has no effect on the comparator output.")

class SA_COMP2(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_COMP2_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_COMP2_FSUB_1(self, 0x404)
        self.FPUB_1 = SA_COMP2_FPUB_1(self, 0x444)
        self.PWREN = SA_COMP2_PWREN(self, 0x800)
        self.RSTCTL = SA_COMP2_RSTCTL(self, 0x804)
        self.CLKCFG = SA_COMP2_CLKCFG(self, 0x808)
        self.GPRCM_STAT = SA_COMP2_GPRCM_STAT(self, 0x814)
        self.IIDX = SA_COMP2_IIDX(self, 0x1020)
        self.IMASK = SA_COMP2_IMASK(self, 0x1028)
        self.RIS = SA_COMP2_RIS(self, 0x1030)
        self.MIS = SA_COMP2_MIS(self, 0x1038)
        self.ISET = SA_COMP2_ISET(self, 0x1040)
        self.ICLR = SA_COMP2_ICLR(self, 0x1048)
        self.EVT_MODE = SA_COMP2_EVT_MODE(self, 0x10E0)
        self.DESC = SA_COMP2_DESC(self, 0x10FC)
        self.CTL0 = SA_COMP2_CTL0(self, 0x1100)
        self.CTL1 = SA_COMP2_CTL1(self, 0x1104)
        self.CTL2 = SA_COMP2_CTL2(self, 0x1108)
        self.CTL3 = SA_COMP2_CTL3(self, 0x110C)
        self.STAT = SA_COMP2_STAT(self, 0x1120)
        self.CTL = Subscriptor(self, "CTL{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")

COMP2 = SA_COMP2(0x4000C000, "COMP2")

class SA_WUC_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subscriber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_WUC_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_WUC(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_WUC_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_WUC_FSUB_1(self, 0x404)
        self.FSUB = Subscriptor(self, "FSUB_{}")

WUC = SA_WUC(0x40424000, "WUC")

class SA_ADC0_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subscriber Configuration Register.")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_ADC0_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Configuration Register.")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_ADC0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_ADC0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_ADC0_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "ADC clock configuration Register")
        self.SAMPCLK = BitField(self, 0x00000003, "SAMPCLK", "ADC sample clock source selection.")
        self.CCONRUN = BitField(self, 0x00000010, "CCONRUN", "CCONRUN: Forces SYSOSC to run at base frequency when device is in RUN mode which can be used as ADC sample or conversion clock source.")
        self.CCONSTOP = BitField(self, 0x00000020, "CCONSTOP", "CCONSTOP: Forces SYSOSC to run at base frequency when device is in STOP mode which can be used as ADC sample or conversion clock source.")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_ADC0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_ADC0_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000003FF, "STAT", "Interrupt index status")

class SA_ADC0_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.OVIFG = BitField(self, 0x00000001, "OVIFG", "Raw interrupt flag for MEMRESx overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.UVIFG = BitField(self, 0x00000040, "UVIFG", "Raw interrupt flag for MEMRESx underflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR is set to 1.")
        self.TOVIFG = BitField(self, 0x00000002, "TOVIFG", "Raw interrupt flag for sequence conversion timeout overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.DMADONE = BitField(self, 0x00000020, "DMADONE", "Raw interrupt flag for DMADONE. . This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC0_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.OVIFG = BitField(self, 0x00000001, "OVIFG", "Raw interrupt flag for MEMRESx overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.UVIFG = BitField(self, 0x00000040, "UVIFG", "Raw interrupt flag for MEMRESx underflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR is set to 1.")
        self.TOVIFG = BitField(self, 0x00000002, "TOVIFG", "Raw interrupt flag for sequence conversion trigger overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.DMADONE = BitField(self, 0x00000020, "DMADONE", "Raw interrupt flag for DMADONE. . This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC0_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.OVIFG = BitField(self, 0x00000001, "OVIFG", "Raw interrupt flag for MEMRESx overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.UVIFG = BitField(self, 0x00000040, "UVIFG", "Raw interrupt flag for MEMRESx underflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR is set to 1.")
        self.TOVIFG = BitField(self, 0x00000002, "TOVIFG", "Raw interrupt flag for sequence conversion timeout overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.DMADONE = BitField(self, 0x00000020, "DMADONE", "Raw interrupt flag for DMADONE. . This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC0_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.OVIFG = BitField(self, 0x00000001, "OVIFG", "Raw interrupt flag for MEMRESx overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.UVIFG = BitField(self, 0x00000040, "UVIFG", "Raw interrupt flag for MEMRESx underflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.TOVIFG = BitField(self, 0x00000002, "TOVIFG", "Raw interrupt flag for sequence conversion timeout overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.DMADONE = BitField(self, 0x00000020, "DMADONE", "Raw interrupt flag for DMADONE. . This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC0_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.OVIFG = BitField(self, 0x00000001, "OVIFG", "Raw interrupt flag for MEMRESx overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.UVIFG = BitField(self, 0x00000040, "UVIFG", "Raw interrupt flag for MEMRESx underflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.TOVIFG = BitField(self, 0x00000002, "TOVIFG", "Raw interrupt flag for sequence conversion timeout overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.DMADONE = BitField(self, 0x00000020, "DMADONE", "Raw interrupt flag for DMADONE. . This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC0_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000003FF, "STAT", "Interrupt index status")

class SA_ADC0_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")

class SA_ADC0_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")

class SA_ADC0_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")

class SA_ADC0_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")

class SA_ADC0_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")

class SA_ADC0_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000003FF, "STAT", "Interrupt index status")

class SA_ADC0_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask extension")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC0_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status extension")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC0_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status extension")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC0_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set extension")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC0_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear extension")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC0_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to IPSTANDARD.INT_EVENT0")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to IPSTANDARD.INT_EVENT1")

class SA_ADC0_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_ADC0_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL0", "Control Register 0")
        self.ENC = BitField(self, 0x00000001, "ENC", "Enable conversion")
        self.PWRDN = BitField(self, 0x00010000, "PWRDN", "Power down policy")
        self.SCLKDIV = BitField(self, 0x07000000, "SCLKDIV", "Sample clock divider")

class SA_ADC0_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL1", "Control Register 1")
        self.TRIGSRC = BitField(self, 0x00000001, "TRIGSRC", "Sample trigger source")
        self.SC = BitField(self, 0x00000100, "SC", "Start of conversion")
        self.CONSEQ = BitField(self, 0x00030000, "CONSEQ", "Conversion sequence mode")
        self.SAMPMODE = BitField(self, 0x00100000, "SAMPMODE", "Sample mode. This bit selects the source of the sampling signal. . MANUAL option is not valid when TRIGSRC is selected as hardware event trigger.")
        self.AVGN = BitField(self, 0x07000000, "AVGN", "Hardware averager numerator. Selects number of conversions to accumulate for current MEMCTLx and then it is divided by AVGD. Result will be stored in MEMRESx.")
        self.AVGD = BitField(self, 0x70000000, "AVGD", "Hardware averager denominator. The number to divide the accumulated value by (this is a shift). Note result register is maximum of 16-bits long so if not shifted appropirately result will be truncated.")

class SA_ADC0_CTL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL2", "Control Register 2")
        self.DF = BitField(self, 0x00000001, "DF", "Data read-back format. Data is always stored in binary unsigned format.")
        self.RES = BitField(self, 0x00000006, "RES", "Resolution. These bits define the resolutoin of ADC conversion result.. Note : A value of 3 defaults to 12-bits resolution.")
        self.STARTADD = BitField(self, 0x001F0000, "STARTADD", "Sequencer start address. These bits select which MEMCTLx is used for single conversion or as first MEMCTL for sequence mode. . The value of STARTADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23.")
        self.ENDADD = BitField(self, 0x1F000000, "ENDADD", "Sequence end address. These bits select which MEMCTLx is the last one for the sequence mode.. The value of ENDADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23.")
        self.DMAEN = BitField(self, 0x00000100, "DMAEN", "Enable DMA trigger for data transfer. . Note: DMAEN bit is cleared by hardware based on DMA done signal at the end of data transfer. Software has to re-enable DMAEN bit for ADC to generate DMA triggers.")
        self.SAMPCNT = BitField(self, 0x0000F800, "SAMPCNT", "Number of ADC converted samples to be transferred on a DMA trigger")
        self.FIFOEN = BitField(self, 0x00000400, "FIFOEN", "Enable FIFO based operation")

class SA_ADC0_CLKFREQ(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKFREQ", "Sample Clock Frequency Range Register")
        self.FRANGE = BitField(self, 0x00000007, "FRANGE", "Frequency Range.")

class SA_ADC0_SCOMP0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SCOMP0", "Sample Time Compare 0 Register")
        self.VAL = BitField(self, 0x000003FF, "VAL", "Specifies the number of sample clocks.. When VAL = 0 or 1, number of sample clocks = Sample clock divide value. When VAL &gt; 1, number of sample clocks = VAL x Sample clock divide value. Note: Sample clock divide value is not the value written to SCLKDIV but the actual divide value (SCLKDIV = 2 implies divide value is 4). Example: VAL = 4, SCLKDIV = 3 implies 32 sample clock cycles.")

class SA_ADC0_SCOMP1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SCOMP1", "Sample Time Compare 1 Register")
        self.VAL = BitField(self, 0x000003FF, "VAL", "Specifies the number of sample clocks.. When VAL = 0 or 1, number of sample clocks = Sample clock divide value. When VAL &gt; 1, number of sample clocks = VAL x Sample clock divide value. Note: Sample clock divide value is not the value written to SCLKDIV but the actual divide value (SCLKDIV = 2 implies divide value is 4). Example: VAL = 4, SCLKDIV = 3 implies 32 sample clock cycles.")

class SA_ADC0_WCLOW(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "WCLOW", "Window Comparator Low Threshold Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "If DF = 0, unsigned binary format has to be used. . The value based on the resolution has to be right aligned with the MSB on the left. For 10-bits and 8-bits resolution, unused bits have to be 0s. If DF = 1, 2s-complement format has to be used. The value based on the resolution has to be left aligned with the LSB on the right. For 10-bits and 8-bits resolution, unused bits have to be 0s.")

class SA_ADC0_WCHIGH(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "WCHIGH", "Window Comparator High Threshold Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "If DF = 0, unsigned binary format has to be used.. The threshold value has to be right aligned, with the MSB on the left. For 10-bits and 8-bits resolution, unused bit have to be 0s. If DF = 1, 2s-complement format has to be used. The value based on the resolution has to be left aligned with the LSB on the right. For 10-bits and 8-bits resolution, unused bit have to be 0s.")

class SA_ADC0_MEMCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MEMCTL0", "Conversion Memory Control Register")
        self.CHANSEL = BitField(self, 0x0000001F, "CHANSEL", "Input channel select.")
        self.TRIG = BitField(self, 0x01000000, "TRIG", "Trigger policy. Indicates if a trigger will be needed to step to the next MEMCTL in the sequence or to perform next conversion in the case of repeat single channel conversions.")
        self.VRSEL = BitField(self, 0x00000300, "VRSEL", "Voltage reference selection. VEREFM must be connected to on-board ground when external reference option is selected.. Note: Writing value 0x3 defaults to INTREF.")
        self.WINCOMP = BitField(self, 0x10000000, "WINCOMP", "Enable window comparator.")
        self.BCSEN = BitField(self, 0x00100000, "BCSEN", "Enable burn out current source.")
        self.AVGEN = BitField(self, 0x00010000, "AVGEN", "Enable hardware averaging.")
        self.STIME = BitField(self, 0x00001000, "STIME", "Selects the source of sample timer period between SCOMP0 and SCOMP1.")

class SA_ADC0_STATUS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STATUS", "Status Register")
        self.BUSY = BitField(self, 0x00000001, "BUSY", "Busy. This bit indicates that an active ADC sample or conversion operation is in progress.")
        self.REFBUFRDY = BitField(self, 0x00000002, "REFBUFRDY", "Indicates reference buffer is powered up and ready.")

class SA_ADC0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_ADC0_FSUB_0(self, 0x400)
        self.FPUB_1 = SA_ADC0_FPUB_1(self, 0x444)
        self.PWREN = SA_ADC0_PWREN(self, 0x800)
        self.RSTCTL = SA_ADC0_RSTCTL(self, 0x804)
        self.CLKCFG = SA_ADC0_CLKCFG(self, 0x808)
        self.STAT = SA_ADC0_STAT(self, 0x814)
        self.INT_EVENT0_IIDX = SA_ADC0_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_ADC0_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_ADC0_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_ADC0_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_ADC0_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_ADC0_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_ADC0_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_ADC0_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_ADC0_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_ADC0_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_ADC0_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_ADC0_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_ADC0_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_ADC0_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_ADC0_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_ADC0_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_ADC0_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_ADC0_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_ADC0_EVT_MODE(self, 0x10E0)
        self.DESC = SA_ADC0_DESC(self, 0x10FC)
        self.CTL0 = SA_ADC0_CTL0(self, 0x1100)
        self.CTL1 = SA_ADC0_CTL1(self, 0x1104)
        self.CTL2 = SA_ADC0_CTL2(self, 0x1108)
        self.CLKFREQ = SA_ADC0_CLKFREQ(self, 0x1110)
        self.SCOMP0 = SA_ADC0_SCOMP0(self, 0x1114)
        self.SCOMP1 = SA_ADC0_SCOMP1(self, 0x1118)
        self.WCLOW = SA_ADC0_WCLOW(self, 0x1148)
        self.WCHIGH = SA_ADC0_WCHIGH(self, 0x1150)
        self.MEMCTL0 = SA_ADC0_MEMCTL0(self, 0x1180)
        self.MEMCTL1 = SA_ADC0_MEMCTL0(self, 0x1184)
        self.MEMCTL2 = SA_ADC0_MEMCTL0(self, 0x1188)
        self.MEMCTL3 = SA_ADC0_MEMCTL0(self, 0x118C)
        self.MEMCTL4 = SA_ADC0_MEMCTL0(self, 0x1190)
        self.MEMCTL5 = SA_ADC0_MEMCTL0(self, 0x1194)
        self.MEMCTL6 = SA_ADC0_MEMCTL0(self, 0x1198)
        self.MEMCTL7 = SA_ADC0_MEMCTL0(self, 0x119C)
        self.MEMCTL8 = SA_ADC0_MEMCTL0(self, 0x11A0)
        self.MEMCTL9 = SA_ADC0_MEMCTL0(self, 0x11A4)
        self.MEMCTL10 = SA_ADC0_MEMCTL0(self, 0x11A8)
        self.MEMCTL11 = SA_ADC0_MEMCTL0(self, 0x11AC)
        self.STATUS = SA_ADC0_STATUS(self, 0x1340)
        self.MEMCTL = Subscriptor(self, "MEMCTL{}")
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.CTL = Subscriptor(self, "CTL{}")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.SCOMP = Subscriptor(self, "SCOMP{}")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

ADC0 = SA_ADC0(0x40000000, "ADC0")

class SA_ADC0_SVT_FIFODATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FIFODATA", "FIFO Data Register")
        self.DATA = BitField(self, 0xFFFFFFFF, "DATA", "Read from this data field returns the ADC sample from FIFO.")

class SA_ADC0_SVT_MEMRES0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MEMRES0", "Memory Result Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "MEMRES result register.. If DF = 0, unsigned binary: The conversion results are right aligned. In 10 and 8 bit modes, the unused MSB bits are forced to 0. If DF = 1, 2s-complement format: The conversion results are left aligned. In 10 and 8 bit modes, the unused LSB bits are forced to 0. The data is stored in the right-justified format and is converted to the left-justified 2s-complement format during read back.")

class SA_ADC0_SVT(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGIONSVT")
        self.FIFODATA = SA_ADC0_SVT_FIFODATA(self, 0x160)
        self.MEMRES0 = SA_ADC0_SVT_MEMRES0(self, 0x280)
        self.MEMRES1 = SA_ADC0_SVT_MEMRES0(self, 0x284)
        self.MEMRES2 = SA_ADC0_SVT_MEMRES0(self, 0x288)
        self.MEMRES3 = SA_ADC0_SVT_MEMRES0(self, 0x28C)
        self.MEMRES4 = SA_ADC0_SVT_MEMRES0(self, 0x290)
        self.MEMRES5 = SA_ADC0_SVT_MEMRES0(self, 0x294)
        self.MEMRES6 = SA_ADC0_SVT_MEMRES0(self, 0x298)
        self.MEMRES7 = SA_ADC0_SVT_MEMRES0(self, 0x29C)
        self.MEMRES8 = SA_ADC0_SVT_MEMRES0(self, 0x2A0)
        self.MEMRES9 = SA_ADC0_SVT_MEMRES0(self, 0x2A4)
        self.MEMRES10 = SA_ADC0_SVT_MEMRES0(self, 0x2A8)
        self.MEMRES11 = SA_ADC0_SVT_MEMRES0(self, 0x2AC)
        self.MEMRES = Subscriptor(self, "MEMRES{}")

ADC0_SVT = SA_ADC0_SVT(0x40556000, "ADC0_SVT")

class SA_ADC1_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subscriber Configuration Register.")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_ADC1_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Configuration Register.")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_ADC1_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_ADC1_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_ADC1_CLKCFG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKCFG", "ADC clock configuration Register")
        self.SAMPCLK = BitField(self, 0x00000003, "SAMPCLK", "ADC sample clock source selection.")
        self.CCONRUN = BitField(self, 0x00000010, "CCONRUN", "CCONRUN: Forces SYSOSC to run at base frequency when device is in RUN mode which can be used as ADC sample or conversion clock source.")
        self.CCONSTOP = BitField(self, 0x00000020, "CCONSTOP", "CCONSTOP: Forces SYSOSC to run at base frequency when device is in STOP mode which can be used as ADC sample or conversion clock source.")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_ADC1_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_ADC1_INT_EVENT0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000003FF, "STAT", "Interrupt index status")

class SA_ADC1_INT_EVENT0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_IMASK", "Interrupt mask")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.OVIFG = BitField(self, 0x00000001, "OVIFG", "Raw interrupt flag for MEMRESx overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.UVIFG = BitField(self, 0x00000040, "UVIFG", "Raw interrupt flag for MEMRESx underflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR is set to 1.")
        self.TOVIFG = BitField(self, 0x00000002, "TOVIFG", "Raw interrupt flag for sequence conversion timeout overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.DMADONE = BitField(self, 0x00000020, "DMADONE", "Raw interrupt flag for DMADONE. . This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC1_INT_EVENT0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_RIS", "Raw interrupt status")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.OVIFG = BitField(self, 0x00000001, "OVIFG", "Raw interrupt flag for MEMRESx overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.UVIFG = BitField(self, 0x00000040, "UVIFG", "Raw interrupt flag for MEMRESx underflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR is set to 1.")
        self.TOVIFG = BitField(self, 0x00000002, "TOVIFG", "Raw interrupt flag for sequence conversion trigger overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.DMADONE = BitField(self, 0x00000020, "DMADONE", "Raw interrupt flag for DMADONE. . This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC1_INT_EVENT0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_MIS", "Masked interrupt status")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.OVIFG = BitField(self, 0x00000001, "OVIFG", "Raw interrupt flag for MEMRESx overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.UVIFG = BitField(self, 0x00000040, "UVIFG", "Raw interrupt flag for MEMRESx underflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR is set to 1.")
        self.TOVIFG = BitField(self, 0x00000002, "TOVIFG", "Raw interrupt flag for sequence conversion timeout overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.DMADONE = BitField(self, 0x00000020, "DMADONE", "Raw interrupt flag for DMADONE. . This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC1_INT_EVENT0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ISET", "Interrupt set")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.OVIFG = BitField(self, 0x00000001, "OVIFG", "Raw interrupt flag for MEMRESx overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.UVIFG = BitField(self, 0x00000040, "UVIFG", "Raw interrupt flag for MEMRESx underflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.TOVIFG = BitField(self, 0x00000002, "TOVIFG", "Raw interrupt flag for sequence conversion timeout overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.DMADONE = BitField(self, 0x00000020, "DMADONE", "Raw interrupt flag for DMADONE. . This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC1_INT_EVENT0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT0_ICLR", "Interrupt clear")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.OVIFG = BitField(self, 0x00000001, "OVIFG", "Raw interrupt flag for MEMRESx overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.UVIFG = BitField(self, 0x00000040, "UVIFG", "Raw interrupt flag for MEMRESx underflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.TOVIFG = BitField(self, 0x00000002, "TOVIFG", "Raw interrupt flag for sequence conversion timeout overflow.. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.DMADONE = BitField(self, 0x00000020, "DMADONE", "Raw interrupt flag for DMADONE. . This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC1_INT_EVENT1_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000003FF, "STAT", "Interrupt index status")

class SA_ADC1_INT_EVENT1_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_IMASK", "Interrupt mask")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")

class SA_ADC1_INT_EVENT1_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_RIS", "Raw interrupt status")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")

class SA_ADC1_INT_EVENT1_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_MIS", "Masked interrupt status")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")

class SA_ADC1_INT_EVENT1_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ISET", "Interrupt set")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")

class SA_ADC1_INT_EVENT1_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT1_ICLR", "Interrupt clear")
        self.INIFG = BitField(self, 0x00000010, "INIFG", "Mask INIFG in MIS_EX register.")
        self.LOWIFG = BitField(self, 0x00000008, "LOWIFG", "Raw interrupt flag for the MEMRESx result register being below. than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.HIGHIFG = BitField(self, 0x00000004, "HIGHIFG", "Raw interrupt flag for the MEMRESx result register being higher. than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1.")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")

class SA_ADC1_INT_EVENT2_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000003FF, "STAT", "Interrupt index status")

class SA_ADC1_INT_EVENT2_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_IMASK", "Interrupt mask extension")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC1_INT_EVENT2_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_RIS", "Raw interrupt status extension")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC1_INT_EVENT2_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_MIS", "Masked interrupt status extension")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC1_INT_EVENT2_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ISET", "Interrupt set extension")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC1_INT_EVENT2_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "INT_EVENT2_ICLR", "Interrupt clear extension")
        self.MEMRESIFG0 = BitField(self, 0x00000100, "MEMRESIFG0", "Raw interrupt status for MEMRES0.. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG1 = BitField(self, 0x00000200, "MEMRESIFG1", "Raw interrupt status for MEMRES1.. This bit is set to 1 when MEMRES1 is loaded with a new conversion result. Reading MEMRES1 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG2 = BitField(self, 0x00000400, "MEMRESIFG2", "Raw interrupt status for MEMRES2.. This bit is set to 1 when MEMRES2 is loaded with a new conversion result. Reading MEMRES2 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG3 = BitField(self, 0x00000800, "MEMRESIFG3", "Raw interrupt status for MEMRES3.. This bit is set to 1 when MEMRES3 is loaded with a new conversion result. Reading MEMRES3 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG4 = BitField(self, 0x00001000, "MEMRESIFG4", "Raw interrupt status for MEMRES4.. This bit is set to 1 when MEMRES4 is loaded with a new conversion result. Reading MEMRES4 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG5 = BitField(self, 0x00002000, "MEMRESIFG5", "Raw interrupt status for MEMRES5.. This bit is set to 1 when MEMRES5 is loaded with a new conversion result. Reading MEMRES5 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG6 = BitField(self, 0x00004000, "MEMRESIFG6", "Raw interrupt status for MEMRES6.. This bit is set to 1 when MEMRES6 is loaded with a new conversion result. Reading MEMRES6 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG7 = BitField(self, 0x00008000, "MEMRESIFG7", "Raw interrupt status for MEMRES7.. This bit is set to 1 when MEMRES7 is loaded with a new conversion result. Reading MEMRES7 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG9 = BitField(self, 0x00020000, "MEMRESIFG9", "Raw interrupt status for MEMRES9.. This bit is set to 1 when MEMRES9 is loaded with a new conversion result. Reading MEMRES9 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG10 = BitField(self, 0x00040000, "MEMRESIFG10", "Raw interrupt status for MEMRES10.. This bit is set to 1 when MEMRES10 is loaded with a new conversion result. Reading MEMRES10 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG11 = BitField(self, 0x00080000, "MEMRESIFG11", "Raw interrupt status for MEMRES11.. This bit is set to 1 when MEMRES11 is loaded with a new conversion result. Reading MEMRES11 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG8 = BitField(self, 0x00010000, "MEMRESIFG8", "Raw interrupt status for MEMRES8.. This bit is set to 1 when MEMRES8 is loaded with a new conversion result. Reading MEMRES8 register will clear this bit, or when the corresponding bit in ICLR is set to 1")
        self.MEMRESIFG = Subscriptor(self, "MEMRESIFG{}")

class SA_ADC1_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for event corresponding to IPSTANDARD.INT_EVENT0")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to IPSTANDARD.INT_EVENT1")

class SA_ADC1_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_ADC1_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL0", "Control Register 0")
        self.ENC = BitField(self, 0x00000001, "ENC", "Enable conversion")
        self.PWRDN = BitField(self, 0x00010000, "PWRDN", "Power down policy")
        self.SCLKDIV = BitField(self, 0x07000000, "SCLKDIV", "Sample clock divider")

class SA_ADC1_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL1", "Control Register 1")
        self.TRIGSRC = BitField(self, 0x00000001, "TRIGSRC", "Sample trigger source")
        self.SC = BitField(self, 0x00000100, "SC", "Start of conversion")
        self.CONSEQ = BitField(self, 0x00030000, "CONSEQ", "Conversion sequence mode")
        self.SAMPMODE = BitField(self, 0x00100000, "SAMPMODE", "Sample mode. This bit selects the source of the sampling signal. . MANUAL option is not valid when TRIGSRC is selected as hardware event trigger.")
        self.AVGN = BitField(self, 0x07000000, "AVGN", "Hardware averager numerator. Selects number of conversions to accumulate for current MEMCTLx and then it is divided by AVGD. Result will be stored in MEMRESx.")
        self.AVGD = BitField(self, 0x70000000, "AVGD", "Hardware averager denominator. The number to divide the accumulated value by (this is a shift). Note result register is maximum of 16-bits long so if not shifted appropirately result will be truncated.")

class SA_ADC1_CTL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL2", "Control Register 2")
        self.DF = BitField(self, 0x00000001, "DF", "Data read-back format. Data is always stored in binary unsigned format.")
        self.RES = BitField(self, 0x00000006, "RES", "Resolution. These bits define the resolutoin of ADC conversion result.. Note : A value of 3 defaults to 12-bits resolution.")
        self.STARTADD = BitField(self, 0x001F0000, "STARTADD", "Sequencer start address. These bits select which MEMCTLx is used for single conversion or as first MEMCTL for sequence mode. . The value of STARTADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23.")
        self.ENDADD = BitField(self, 0x1F000000, "ENDADD", "Sequence end address. These bits select which MEMCTLx is the last one for the sequence mode.. The value of ENDADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23.")
        self.DMAEN = BitField(self, 0x00000100, "DMAEN", "Enable DMA trigger for data transfer. . Note: DMAEN bit is cleared by hardware based on DMA done signal at the end of data transfer. Software has to re-enable DMAEN bit for ADC to generate DMA triggers.")
        self.SAMPCNT = BitField(self, 0x0000F800, "SAMPCNT", "Number of ADC converted samples to be transferred on a DMA trigger")
        self.FIFOEN = BitField(self, 0x00000400, "FIFOEN", "Enable FIFO based operation")

class SA_ADC1_CLKFREQ(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKFREQ", "Sample Clock Frequency Range Register")
        self.FRANGE = BitField(self, 0x00000007, "FRANGE", "Frequency Range.")

class SA_ADC1_SCOMP0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SCOMP0", "Sample Time Compare 0 Register")
        self.VAL = BitField(self, 0x000003FF, "VAL", "Specifies the number of sample clocks.. When VAL = 0 or 1, number of sample clocks = Sample clock divide value. When VAL &gt; 1, number of sample clocks = VAL x Sample clock divide value. Note: Sample clock divide value is not the value written to SCLKDIV but the actual divide value (SCLKDIV = 2 implies divide value is 4). Example: VAL = 4, SCLKDIV = 3 implies 32 sample clock cycles.")

class SA_ADC1_SCOMP1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "SCOMP1", "Sample Time Compare 1 Register")
        self.VAL = BitField(self, 0x000003FF, "VAL", "Specifies the number of sample clocks.. When VAL = 0 or 1, number of sample clocks = Sample clock divide value. When VAL &gt; 1, number of sample clocks = VAL x Sample clock divide value. Note: Sample clock divide value is not the value written to SCLKDIV but the actual divide value (SCLKDIV = 2 implies divide value is 4). Example: VAL = 4, SCLKDIV = 3 implies 32 sample clock cycles.")

class SA_ADC1_WCLOW(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "WCLOW", "Window Comparator Low Threshold Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "If DF = 0, unsigned binary format has to be used. . The value based on the resolution has to be right aligned with the MSB on the left. For 10-bits and 8-bits resolution, unused bits have to be 0s. If DF = 1, 2s-complement format has to be used. The value based on the resolution has to be left aligned with the LSB on the right. For 10-bits and 8-bits resolution, unused bits have to be 0s.")

class SA_ADC1_WCHIGH(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "WCHIGH", "Window Comparator High Threshold Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "If DF = 0, unsigned binary format has to be used.. The threshold value has to be right aligned, with the MSB on the left. For 10-bits and 8-bits resolution, unused bit have to be 0s. If DF = 1, 2s-complement format has to be used. The value based on the resolution has to be left aligned with the LSB on the right. For 10-bits and 8-bits resolution, unused bit have to be 0s.")

class SA_ADC1_MEMCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MEMCTL0", "Conversion Memory Control Register")
        self.CHANSEL = BitField(self, 0x0000001F, "CHANSEL", "Input channel select.")
        self.TRIG = BitField(self, 0x01000000, "TRIG", "Trigger policy. Indicates if a trigger will be needed to step to the next MEMCTL in the sequence or to perform next conversion in the case of repeat single channel conversions.")
        self.VRSEL = BitField(self, 0x00000300, "VRSEL", "Voltage reference selection. VEREFM must be connected to on-board ground when external reference option is selected.. Note: Writing value 0x3 defaults to INTREF.")
        self.WINCOMP = BitField(self, 0x10000000, "WINCOMP", "Enable window comparator.")
        self.BCSEN = BitField(self, 0x00100000, "BCSEN", "Enable burn out current source.")
        self.AVGEN = BitField(self, 0x00010000, "AVGEN", "Enable hardware averaging.")
        self.STIME = BitField(self, 0x00001000, "STIME", "Selects the source of sample timer period between SCOMP0 and SCOMP1.")

class SA_ADC1_STATUS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STATUS", "Status Register")
        self.BUSY = BitField(self, 0x00000001, "BUSY", "Busy. This bit indicates that an active ADC sample or conversion operation is in progress.")
        self.REFBUFRDY = BitField(self, 0x00000002, "REFBUFRDY", "Indicates reference buffer is powered up and ready.")

class SA_ADC1(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_ADC1_FSUB_0(self, 0x400)
        self.FPUB_1 = SA_ADC1_FPUB_1(self, 0x444)
        self.PWREN = SA_ADC1_PWREN(self, 0x800)
        self.RSTCTL = SA_ADC1_RSTCTL(self, 0x804)
        self.CLKCFG = SA_ADC1_CLKCFG(self, 0x808)
        self.STAT = SA_ADC1_STAT(self, 0x814)
        self.INT_EVENT0_IIDX = SA_ADC1_INT_EVENT0_IIDX(self, 0x1020)
        self.INT_EVENT0_IMASK = SA_ADC1_INT_EVENT0_IMASK(self, 0x1028)
        self.INT_EVENT0_RIS = SA_ADC1_INT_EVENT0_RIS(self, 0x1030)
        self.INT_EVENT0_MIS = SA_ADC1_INT_EVENT0_MIS(self, 0x1038)
        self.INT_EVENT0_ISET = SA_ADC1_INT_EVENT0_ISET(self, 0x1040)
        self.INT_EVENT0_ICLR = SA_ADC1_INT_EVENT0_ICLR(self, 0x1048)
        self.INT_EVENT1_IIDX = SA_ADC1_INT_EVENT1_IIDX(self, 0x1050)
        self.INT_EVENT1_IMASK = SA_ADC1_INT_EVENT1_IMASK(self, 0x1058)
        self.INT_EVENT1_RIS = SA_ADC1_INT_EVENT1_RIS(self, 0x1060)
        self.INT_EVENT1_MIS = SA_ADC1_INT_EVENT1_MIS(self, 0x1068)
        self.INT_EVENT1_ISET = SA_ADC1_INT_EVENT1_ISET(self, 0x1070)
        self.INT_EVENT1_ICLR = SA_ADC1_INT_EVENT1_ICLR(self, 0x1078)
        self.INT_EVENT2_IIDX = SA_ADC1_INT_EVENT2_IIDX(self, 0x1080)
        self.INT_EVENT2_IMASK = SA_ADC1_INT_EVENT2_IMASK(self, 0x1088)
        self.INT_EVENT2_RIS = SA_ADC1_INT_EVENT2_RIS(self, 0x1090)
        self.INT_EVENT2_MIS = SA_ADC1_INT_EVENT2_MIS(self, 0x1098)
        self.INT_EVENT2_ISET = SA_ADC1_INT_EVENT2_ISET(self, 0x10A0)
        self.INT_EVENT2_ICLR = SA_ADC1_INT_EVENT2_ICLR(self, 0x10A8)
        self.EVT_MODE = SA_ADC1_EVT_MODE(self, 0x10E0)
        self.DESC = SA_ADC1_DESC(self, 0x10FC)
        self.CTL0 = SA_ADC1_CTL0(self, 0x1100)
        self.CTL1 = SA_ADC1_CTL1(self, 0x1104)
        self.CTL2 = SA_ADC1_CTL2(self, 0x1108)
        self.CLKFREQ = SA_ADC1_CLKFREQ(self, 0x1110)
        self.SCOMP0 = SA_ADC1_SCOMP0(self, 0x1114)
        self.SCOMP1 = SA_ADC1_SCOMP1(self, 0x1118)
        self.WCLOW = SA_ADC1_WCLOW(self, 0x1148)
        self.WCHIGH = SA_ADC1_WCHIGH(self, 0x1150)
        self.MEMCTL0 = SA_ADC1_MEMCTL0(self, 0x1180)
        self.MEMCTL1 = SA_ADC1_MEMCTL0(self, 0x1184)
        self.MEMCTL2 = SA_ADC1_MEMCTL0(self, 0x1188)
        self.MEMCTL3 = SA_ADC1_MEMCTL0(self, 0x118C)
        self.MEMCTL4 = SA_ADC1_MEMCTL0(self, 0x1190)
        self.MEMCTL5 = SA_ADC1_MEMCTL0(self, 0x1194)
        self.MEMCTL6 = SA_ADC1_MEMCTL0(self, 0x1198)
        self.MEMCTL7 = SA_ADC1_MEMCTL0(self, 0x119C)
        self.MEMCTL8 = SA_ADC1_MEMCTL0(self, 0x11A0)
        self.MEMCTL9 = SA_ADC1_MEMCTL0(self, 0x11A4)
        self.MEMCTL10 = SA_ADC1_MEMCTL0(self, 0x11A8)
        self.MEMCTL11 = SA_ADC1_MEMCTL0(self, 0x11AC)
        self.STATUS = SA_ADC1_STATUS(self, 0x1340)
        self.MEMCTL = Subscriptor(self, "MEMCTL{}")
        self.INT_EVENT_ISET = Subscriptor(self, "INT_EVENT{}_ISET")
        self.CTL = Subscriptor(self, "CTL{}")
        self.INT_EVENT_IIDX = Subscriptor(self, "INT_EVENT{}_IIDX")
        self.SCOMP = Subscriptor(self, "SCOMP{}")
        self.INT_EVENT_ICLR = Subscriptor(self, "INT_EVENT{}_ICLR")
        self.INT_EVENT_RIS = Subscriptor(self, "INT_EVENT{}_RIS")
        self.INT_EVENT_MIS = Subscriptor(self, "INT_EVENT{}_MIS")
        self.INT_EVENT_IMASK = Subscriptor(self, "INT_EVENT{}_IMASK")

ADC1 = SA_ADC1(0x40002000, "ADC1")

class SA_ADC1_SVT_FIFODATA(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FIFODATA", "FIFO Data Register")
        self.DATA = BitField(self, 0xFFFFFFFF, "DATA", "Read from this data field returns the ADC sample from FIFO.")

class SA_ADC1_SVT_MEMRES0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MEMRES0", "Memory Result Register")
        self.DATA = BitField(self, 0x0000FFFF, "DATA", "MEMRES result register.. If DF = 0, unsigned binary: The conversion results are right aligned. In 10 and 8 bit modes, the unused MSB bits are forced to 0. If DF = 1, 2s-complement format: The conversion results are left aligned. In 10 and 8 bit modes, the unused LSB bits are forced to 0. The data is stored in the right-justified format and is converted to the left-justified 2s-complement format during read back.")

class SA_ADC1_SVT(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGIONSVT")
        self.FIFODATA = SA_ADC1_SVT_FIFODATA(self, 0x160)
        self.MEMRES0 = SA_ADC1_SVT_MEMRES0(self, 0x280)
        self.MEMRES1 = SA_ADC1_SVT_MEMRES0(self, 0x284)
        self.MEMRES2 = SA_ADC1_SVT_MEMRES0(self, 0x288)
        self.MEMRES3 = SA_ADC1_SVT_MEMRES0(self, 0x28C)
        self.MEMRES4 = SA_ADC1_SVT_MEMRES0(self, 0x290)
        self.MEMRES5 = SA_ADC1_SVT_MEMRES0(self, 0x294)
        self.MEMRES6 = SA_ADC1_SVT_MEMRES0(self, 0x298)
        self.MEMRES7 = SA_ADC1_SVT_MEMRES0(self, 0x29C)
        self.MEMRES8 = SA_ADC1_SVT_MEMRES0(self, 0x2A0)
        self.MEMRES9 = SA_ADC1_SVT_MEMRES0(self, 0x2A4)
        self.MEMRES10 = SA_ADC1_SVT_MEMRES0(self, 0x2A8)
        self.MEMRES11 = SA_ADC1_SVT_MEMRES0(self, 0x2AC)
        self.MEMRES = Subscriptor(self, "MEMRES{}")

ADC1_SVT = SA_ADC1_SVT(0x40558000, "ADC1_SVT")

class SA_TIMG0_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subsciber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG0_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG0_FPUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_0", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG0_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG0_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_TIMG0_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_TIMG0_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_TIMG0_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_TIMG0_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUSCLK as clock source if enabled")

class SA_TIMG0_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_TIMG0_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_TIMG0_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.Z = BitField(self, 0x00000001, "Z", "Zero Event mask")
        self.L = BitField(self, 0x00000002, "L", "Load Event mask")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or Compare DN event mask CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or Compare DN event mask CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or Compare UP event mask CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or Compare UP event mask CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow Event mask")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG0_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG0_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG0_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event SET")
        self.L = BitField(self, 0x00000002, "L", "Load event SET")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event SET")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event SET")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event SET")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event SET")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event SET")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG0_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event CLEAR")
        self.L = BitField(self, 0x00000002, "L", "Load event CLEAR")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event CLEAR")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event CLEAR")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event CLEAR")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event CLEAR")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event CLEAR")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG0_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x29, "EVT_MODE", "Event Mode")
        self.EVT0_CFG = BitField(self, 0x00000003, "EVT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_TIMG0_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_TIMG0_CCPD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCPD", "CCP Direction")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMG0_ODIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ODIS", "Output Disable")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMG0_CCLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCLKCTL", "Counter Clock Control Register")
        self.CLKEN = BitField(self, 0x00000001, "CLKEN", "Clock Enable. Disables the clock gating to the module. SW has to explicitly program the value to 0 to gate the clock.")

class SA_TIMG0_CPS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPS", "Clock Prescale Register")
        self.PCNT = BitField(self, 0x000000FF, "PCNT", "Pre-Scale Count. This field specifies the pre-scale count value. The selected TIMCLK source is divided by a value of (PCNT+1). A PCNT value of 0 divides TIMCLK by 1, effectively bypassing the divider. A PCNT value of greater than 0 divides the TIMCLK source generating a slower clock")

class SA_TIMG0_CPSV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPSV", "Clock prescale count status register")
        self.CPSVAL = BitField(self, 0x000000FF, "CPSVAL", "Current Prescale Count Value")

class SA_TIMG0_CTTRIGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIGCTL", "Timer Cross Trigger Control Register")
        self.CTEN = BitField(self, 0x00000001, "CTEN", "Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system.. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register.")
        self.EVTCTEN = BitField(self, 0x00000002, "EVTCTEN", "Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path")
        self.EVTCTTRIGSEL = BitField(self, 0x000F0000, "EVTCTTRIGSEL", "Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path")

class SA_TIMG0_CTTRIG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIG", "Timer Cross Trigger Register")
        self.TRIG = BitField(self, 0x00000001, "TRIG", "Generate Cross Trigger. This bit when programmed will generate a synchronized trigger condition all the cross trigger enabled Timer instances including current timer instance.")

class SA_TIMG0_CTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTR", "Counter Register")
        self.CCTR = BitField(self, 0x0000FFFF, "CCTR", "Current Counter value")

class SA_TIMG0_CTRCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF80, "CTRCTL", "Counter Control Register")
        self.EN = BitField(self, 0x00000001, "EN", "Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively.")
        self.REPEAT = BitField(self, 0x0000000E, "REPEAT", "Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended.")
        self.CM = BitField(self, 0x00000030, "CM", "Count Mode")
        self.CVAE = BitField(self, 0x30000000, "CVAE", "Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active.")
        self.DRB = BitField(self, 0x00020000, "DRB", "Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode.")
        self.CLC = BitField(self, 0x00000380, "CLC", "Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CAC = BitField(self, 0x00001C00, "CAC", "Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CZC = BitField(self, 0x0000E000, "CZC", "Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")

class SA_TIMG0_LOAD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LOAD", "Load Register")
        self.LD = BitField(self, 0x0000FFFF, "LD", "Load Value")

class SA_TIMG0_CC0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CC0", "Capture or Compare Register 0 to Capture or Compare Register 1")
        self.CCVAL = BitField(self, 0x0000FFFF, "CCVAL", "Capture or compare value")

class SA_TIMG0_CCCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCCTL0", "Capture or Compare Control Registers")
        self.CCOND = BitField(self, 0x00000007, "CCOND", "Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved")
        self.ACOND = BitField(self, 0x00000070, "ACOND", "Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved")
        self.LCOND = BitField(self, 0x00000700, "LCOND", "Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved")
        self.ZCOND = BitField(self, 0x00007000, "ZCOND", "Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved")
        self.COC = BitField(self, 0x00020000, "COC", "Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both).")
        self.CCACTUPD = BitField(self, 0x1C000000, "CCACTUPD", "CCACT shadow register Update Method. This field controls how updates to the CCCACT shadow register are performed")
        self.CC2SELU = BitField(self, 0x01C00000, "CC2SELU", "Selects the source second CCU event.")
        self.CC2SELD = BitField(self, 0xE0000000, "CC2SELD", "Selects the source second CCD event.")

class SA_TIMG0_OCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OCTL0", "CCP Output Control Registers")
        self.CCPOINV = BitField(self, 0x00000010, "CCPOINV", "CCP Output Invert The output as selected by CCPO is conditionally inverted.")
        self.CCPIV = BitField(self, 0x00000020, "CCPIV", "CCP Initial Value This bit specifies the logical value put on the signal generator state while the counter is disabled (CTRCTL.EN == 0).")
        self.CCPO = BitField(self, 0x0000000F, "CCPO", "CCP Output Source")

class SA_TIMG0_CCACT0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCACT0", "Capture or Compare Action Registers")
        self.ZACT = BitField(self, 0x00000003, "ZACT", "CCP Output Action on Zero Specifies what changes occur to CCP output as the result of a zero event.")
        self.LACT = BitField(self, 0x00000018, "LACT", "CCP Output Action on Load Specifies what changes occur to CCP output as the result of a load event.")
        self.CDACT = BitField(self, 0x000000C0, "CDACT", "CCP Output Action on Compare (Down) This field describes the resulting action of the signal generator upon detecting a compare event while counting down.")
        self.CUACT = BitField(self, 0x00000600, "CUACT", "CCP Output Action on Compare (Up) This field describes the resulting action of the signal generator upon detecting a compare event while counting up.")
        self.CC2DACT = BitField(self, 0x00003000, "CC2DACT", "CCP Output Action on CC2D event.")
        self.CC2UACT = BitField(self, 0x00018000, "CC2UACT", "CCP Output Action on CC2U event.")
        self.SWFRCACT = BitField(self, 0x30000000, "SWFRCACT", "CCP Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")

class SA_TIMG0_IFCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IFCTL0", "Input Filter Control Register")
        self.ISEL = BitField(self, 0x0000000F, "ISEL", "Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved")
        self.INV = BitField(self, 0x00000080, "INV", "Input Inversion This bit controls whether the selected input is inverted.")
        self.FP = BitField(self, 0x00000300, "FP", "Filter Period. This field specifies the sample period for the. input filter. I.e. The input is sampled for FP timer clocks during filtering.")
        self.CPV = BitField(self, 0x00000800, "CPV", "Consecutive Period/Voting Select. This bit controls whether the input filter uses a stricter consecutive period count or majority voting.")
        self.FE = BitField(self, 0x00001000, "FE", "Filter Enable. This bit controls whether the input is filtered by the input filter or bypasses to the edge detect.")

class SA_TIMG0_TSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TSEL", "Trigger Select")
        self.ETSEL = BitField(self, 0x0000001F, "ETSEL", "External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. . Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use.")
        self.TE = BitField(self, 0x00000200, "TE", "Trigger Enable.. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field")

class SA_TIMG0(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_TIMG0_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_TIMG0_FSUB_1(self, 0x404)
        self.FPUB_0 = SA_TIMG0_FPUB_0(self, 0x444)
        self.FPUB_1 = SA_TIMG0_FPUB_1(self, 0x448)
        self.PWREN = SA_TIMG0_PWREN(self, 0x800)
        self.RSTCTL = SA_TIMG0_RSTCTL(self, 0x804)
        self.STAT = SA_TIMG0_STAT(self, 0x814)
        self.CLKDIV = SA_TIMG0_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_TIMG0_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_TIMG0_PDBGCTL(self, 0x1018)
        self.IIDX = SA_TIMG0_IIDX(self, 0x1020)
        self.IMASK = SA_TIMG0_IMASK(self, 0x1028)
        self.RIS = SA_TIMG0_RIS(self, 0x1030)
        self.MIS = SA_TIMG0_MIS(self, 0x1038)
        self.ISET = SA_TIMG0_ISET(self, 0x1040)
        self.ICLR = SA_TIMG0_ICLR(self, 0x1048)
        self.EVT_MODE = SA_TIMG0_EVT_MODE(self, 0x10E0)
        self.DESC = SA_TIMG0_DESC(self, 0x10FC)
        self.CCPD = SA_TIMG0_CCPD(self, 0x1100)
        self.ODIS = SA_TIMG0_ODIS(self, 0x1104)
        self.CCLKCTL = SA_TIMG0_CCLKCTL(self, 0x1108)
        self.CPS = SA_TIMG0_CPS(self, 0x110C)
        self.CPSV = SA_TIMG0_CPSV(self, 0x1110)
        self.CTTRIGCTL = SA_TIMG0_CTTRIGCTL(self, 0x1114)
        self.CTTRIG = SA_TIMG0_CTTRIG(self, 0x111C)
        self.CTR = SA_TIMG0_CTR(self, 0x1800)
        self.CTRCTL = SA_TIMG0_CTRCTL(self, 0x1804)
        self.LOAD = SA_TIMG0_LOAD(self, 0x1808)
        self.CC0 = SA_TIMG0_CC0(self, 0x1810)
        self.CC1 = SA_TIMG0_CC0(self, 0x1814)
        self.CCCTL0 = SA_TIMG0_CCCTL0(self, 0x1830)
        self.CCCTL1 = SA_TIMG0_CCCTL0(self, 0x1834)
        self.OCTL0 = SA_TIMG0_OCTL0(self, 0x1850)
        self.OCTL1 = SA_TIMG0_OCTL0(self, 0x1854)
        self.CCACT0 = SA_TIMG0_CCACT0(self, 0x1870)
        self.CCACT1 = SA_TIMG0_CCACT0(self, 0x1874)
        self.IFCTL0 = SA_TIMG0_IFCTL0(self, 0x1880)
        self.IFCTL1 = SA_TIMG0_IFCTL0(self, 0x1884)
        self.TSEL = SA_TIMG0_TSEL(self, 0x18B0)
        self.IFCTL = Subscriptor(self, "IFCTL{}")
        self.CCACT = Subscriptor(self, "CCACT{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")
        self.OCTL = Subscriptor(self, "OCTL{}")
        self.CC = Subscriptor(self, "CC{}")
        self.FPUB = Subscriptor(self, "FPUB_{}")
        self.CCCTL = Subscriptor(self, "CCCTL{}")

TIMG0 = SA_TIMG0(0x40084000, "TIMG0")

class SA_VREF_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_VREF_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_VREF_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_VREF_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock to be used in sample and hold logic")

class SA_VREF_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Selection")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUSCLK as clock source if enabled")

class SA_VREF_CTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL0", "Control 0")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "This bit enables the VREF module.")
        self.BUFCONFIG = BitField(self, 0x00000080, "BUFCONFIG", "These bits configure output buffer.")
        self.SHMODE = BitField(self, 0x00000100, "SHMODE", "This bit enable sample and hold mode")

class SA_VREF_CTL1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL1", "Control 1")
        self.READY = BitField(self, 0x00000001, "READY", "These bits defines status of VREF")

class SA_VREF_CTL2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL2", "Control 2")
        self.SHCYCLE = BitField(self, 0x0000FFFF, "SHCYCLE", "Sample and Hold cycle count. Total cycles of module clock for sample and hold phase when VREF is working in sample and hold mode in STANDBY to save power. This field should be greater than HCYCLE field. The difference between this field and HCYCLE gives the number of cycles of sample phase. Please refer VREF section of datasheet for recommended values of sample and hold times.")
        self.HCYCLE = BitField(self, 0xFFFF0000, "HCYCLE", "Hold cycle count. Total cycles of module clock for hold phase when VREF is working in sample and hold mode in STANDBY to save power. Please refer VREF section of datasheet for recommended values of sample and hold times.")

class SA_VREF(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_VREF_PWREN(self, 0x800)
        self.RSTCTL = SA_VREF_RSTCTL(self, 0x804)
        self.STAT = SA_VREF_STAT(self, 0x814)
        self.CLKDIV = SA_VREF_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_VREF_CLKSEL(self, 0x1008)
        self.CTL0 = SA_VREF_CTL0(self, 0x1100)
        self.CTL1 = SA_VREF_CTL1(self, 0x1104)
        self.CTL2 = SA_VREF_CTL2(self, 0x1108)
        self.CTL = Subscriptor(self, "CTL{}")

VREF = SA_VREF(0x40030000, "VREF")

class SA_MATHACL_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_MATHACL_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_MATHACL_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_MATHACL_CTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTL", "Control Register")
        self.FUNC = BitField(self, 0x0000001F, "FUNC", "ULP_ADCHP Enable Conversions.")
        self.QVAL = BitField(self, 0x00001F00, "QVAL", "Indicates the fractional bits in the operands, ranges from 0 to 31. Applicable to DIV function.")
        self.OPTYPE = BitField(self, 0x00000020, "OPTYPE", "Operand type, could signed or unsigned. applicable to DIV function.")
        self.NUMITER = BitField(self, 0x1F000000, "NUMITER", "Number of iterations, applicable if the function does the computations iteratively, for example sine/cosine/atan2/sqrt.. Note: A value of 0 is interpreted as 31.")
        self.SFACTOR = BitField(self, 0x003F0000, "SFACTOR", "Scaling factor. In case of SQRT function, the input operand needs to be in a range. If not it has to be scaled to 2^(+/-n). This field should be written with the value 'n'.")
        self.SATEN = BitField(self, 0x00400000, "SATEN", "Saturation enable. This bit is shared among DIV, SQUARE32, MPY32, MAC and SAC functions. When enabled, it will make the result to saturate to maximum value in case of an overflow event When disabled, the result will overflow to an unknown value.")

class SA_MATHACL_OP2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OP2", "Operand 2 register.")
        self.DATA = BitField(self, 0xFFFFFFFF, "DATA", "Operand 2 Register")

class SA_MATHACL_OP1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OP1", "Operand 1 register.")
        self.DATA = BitField(self, 0xFFFFFFFF, "DATA", "Operand 1 register.")

class SA_MATHACL_RES1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RES1", "Result 1 register.")
        self.DATA = BitField(self, 0xFFFFFFFF, "DATA", "Result 1 register")

class SA_MATHACL_RES2(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RES2", "Result 2 register.")
        self.DATA = BitField(self, 0xFFFFFFFF, "DATA", "Result 2 register")

class SA_MATHACL_STATUS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STATUS", "Status Register")
        self.UF = BitField(self, 0x00000001, "UF", "Underflow Flag")
        self.OVF = BitField(self, 0x00000002, "OVF", "Overflow bit for MPY32, SQUARE32, DIV, MAC, and SAC functions. This bit will be set on overflow and will retain its value until cleared by writing 1 into CLR.CLR_OVF")
        self.ERR = BitField(self, 0x0000000C, "ERR", "Incorrect inputs/outputs.")
        self.BUSY = BitField(self, 0x00000100, "BUSY", "MATHACL busy bit.")

class SA_MATHACL_STATUSCLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STATUSCLR", "Status flag clear register")
        self.CLR_OVF = BitField(self, 0x00000002, "CLR_OVF", "Write 1 to this bit to clear STATUS.OVF bit")
        self.CLR_UF = BitField(self, 0x00000001, "CLR_UF", "Write 1 to this bit to clear STATUS.UF bit")
        self.CLR_ERR = BitField(self, 0x00000004, "CLR_ERR", "Write 1 to this bit to clear STATUS.ERR field")

class SA_MATHACL(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.PWREN = SA_MATHACL_PWREN(self, 0x800)
        self.RSTCTL = SA_MATHACL_RSTCTL(self, 0x804)
        self.STAT = SA_MATHACL_STAT(self, 0x814)
        self.CTL = SA_MATHACL_CTL(self, 0x1100)
        self.OP2 = SA_MATHACL_OP2(self, 0x1118)
        self.OP1 = SA_MATHACL_OP1(self, 0x111C)
        self.RES1 = SA_MATHACL_RES1(self, 0x1120)
        self.RES2 = SA_MATHACL_RES2(self, 0x1124)
        self.STATUS = SA_MATHACL_STATUS(self, 0x1130)
        self.STATUSCLR = SA_MATHACL_STATUSCLR(self, 0x1140)
        self.OP = Subscriptor(self, "OP{}")
        self.RES = Subscriptor(self, "RES{}")

MATHACL = SA_MATHACL(0x40410000, "MATHACL")

class SA_TIMG12_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subsciber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG12_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG12_FPUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_0", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG12_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG12_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_TIMG12_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_TIMG12_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_TIMG12_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_TIMG12_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUSCLK as clock source if enabled")

class SA_TIMG12_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_TIMG12_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_TIMG12_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.Z = BitField(self, 0x00000001, "Z", "Zero Event mask")
        self.L = BitField(self, 0x00000002, "L", "Load Event mask")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or Compare DN event mask CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or Compare DN event mask CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or Compare UP event mask CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or Compare UP event mask CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow Event mask")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG12_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG12_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event generated an interrupt CCP4")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event generated an interrupt CCP5")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event generated an interrupt CCP4")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event generated an interrupt CCP5")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG12_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event SET")
        self.L = BitField(self, 0x00000002, "L", "Load event SET")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event SET")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event SET")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event SET")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event SET")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event SET")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG12_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event CLEAR")
        self.L = BitField(self, 0x00000002, "L", "Load event CLEAR")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event CLEAR")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event CLEAR")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event CLEAR")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event CLEAR")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event CLEAR")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG12_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x29, "EVT_MODE", "Event Mode")
        self.EVT0_CFG = BitField(self, 0x00000003, "EVT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_TIMG12_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_TIMG12_CCPD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCPD", "CCP Direction")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMG12_ODIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ODIS", "Output Disable")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMG12_CCLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCLKCTL", "Counter Clock Control Register")
        self.CLKEN = BitField(self, 0x00000001, "CLKEN", "Clock Enable. Disables the clock gating to the module. SW has to explicitly program the value to 0 to gate the clock.")

class SA_TIMG12_CTTRIGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIGCTL", "Timer Cross Trigger Control Register")
        self.CTEN = BitField(self, 0x00000001, "CTEN", "Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system.. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register.")
        self.EVTCTEN = BitField(self, 0x00000002, "EVTCTEN", "Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path")
        self.EVTCTTRIGSEL = BitField(self, 0x000F0000, "EVTCTTRIGSEL", "Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path")

class SA_TIMG12_CTTRIG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIG", "Timer Cross Trigger Register")
        self.TRIG = BitField(self, 0x00000001, "TRIG", "Generate Cross Trigger. This bit when programmed will generate a synchronized trigger condition all the cross trigger enabled Timer instances including current timer instance.")

class SA_TIMG12_CTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTR", "Counter Register")
        self.CCTR = BitField(self, 0xFFFFFFFF, "CCTR", "Current Counter value")

class SA_TIMG12_CTRCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF80, "CTRCTL", "Counter Control Register")
        self.EN = BitField(self, 0x00000001, "EN", "Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively.")
        self.REPEAT = BitField(self, 0x0000000E, "REPEAT", "Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended.")
        self.CM = BitField(self, 0x00000030, "CM", "Count Mode")
        self.CVAE = BitField(self, 0x30000000, "CVAE", "Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active.")
        self.DRB = BitField(self, 0x00020000, "DRB", "Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode.")
        self.CLC = BitField(self, 0x00000380, "CLC", "Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CAC = BitField(self, 0x00001C00, "CAC", "Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CZC = BitField(self, 0x0000E000, "CZC", "Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")

class SA_TIMG12_LOAD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LOAD", "Load Register")
        self.LD = BitField(self, 0xFFFFFFFF, "LD", "Load Value")

class SA_TIMG12_CC0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CC0", "Capture or Compare Register 0 to Capture or Compare Register 1")
        self.CCVAL = BitField(self, 0xFFFFFFFF, "CCVAL", "Capture or compare value")

class SA_TIMG12_CCCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCCTL0", "Capture or Compare Control Registers")
        self.CCOND = BitField(self, 0x00000007, "CCOND", "Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved")
        self.ACOND = BitField(self, 0x00000070, "ACOND", "Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved")
        self.LCOND = BitField(self, 0x00000700, "LCOND", "Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved")
        self.ZCOND = BitField(self, 0x00007000, "ZCOND", "Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved")
        self.COC = BitField(self, 0x00020000, "COC", "Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both).")
        self.CCUPD = BitField(self, 0x001C0000, "CCUPD", "Capture and Compare Update Method. This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0).")
        self.CCACTUPD = BitField(self, 0x1C000000, "CCACTUPD", "CCACT shadow register Update Method. This field controls how updates to the CCCACT shadow register are performed")
        self.CC2SELU = BitField(self, 0x01C00000, "CC2SELU", "Selects the source second CCU event.")
        self.CC2SELD = BitField(self, 0xE0000000, "CC2SELD", "Selects the source second CCD event.")

class SA_TIMG12_OCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OCTL0", "CCP Output Control Registers")
        self.CCPOINV = BitField(self, 0x00000010, "CCPOINV", "CCP Output Invert The output as selected by CCPO is conditionally inverted.")
        self.CCPIV = BitField(self, 0x00000020, "CCPIV", "CCP Initial Value This bit specifies the logical value put on the signal generator state while the counter is disabled (CTRCTL.EN == 0).")
        self.CCPO = BitField(self, 0x0000000F, "CCPO", "CCP Output Source")

class SA_TIMG12_CCACT0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCACT0", "Capture or Compare Action Registers")
        self.ZACT = BitField(self, 0x00000003, "ZACT", "CCP Output Action on Zero Specifies what changes occur to CCP output as the result of a zero event.")
        self.LACT = BitField(self, 0x00000018, "LACT", "CCP Output Action on Load Specifies what changes occur to CCP output as the result of a load event.")
        self.CDACT = BitField(self, 0x000000C0, "CDACT", "CCP Output Action on Compare (Down) This field describes the resulting action of the signal generator upon detecting a compare event while counting down.")
        self.CUACT = BitField(self, 0x00000600, "CUACT", "CCP Output Action on Compare (Up) This field describes the resulting action of the signal generator upon detecting a compare event while counting up.")
        self.CC2DACT = BitField(self, 0x00003000, "CC2DACT", "CCP Output Action on CC2D event.")
        self.CC2UACT = BitField(self, 0x00018000, "CC2UACT", "CCP Output Action on CC2U event.")
        self.SWFRCACT = BitField(self, 0x30000000, "SWFRCACT", "CCP Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")

class SA_TIMG12_IFCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IFCTL0", "Input Filter Control Register")
        self.ISEL = BitField(self, 0x0000000F, "ISEL", "Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved")
        self.INV = BitField(self, 0x00000080, "INV", "Input Inversion This bit controls whether the selected input is inverted.")
        self.FP = BitField(self, 0x00000300, "FP", "Filter Period. This field specifies the sample period for the. input filter. I.e. The input is sampled for FP timer clocks during filtering.")
        self.CPV = BitField(self, 0x00000800, "CPV", "Consecutive Period/Voting Select. This bit controls whether the input filter uses a stricter consecutive period count or majority voting.")
        self.FE = BitField(self, 0x00001000, "FE", "Filter Enable. This bit controls whether the input is filtered by the input filter or bypasses to the edge detect.")

class SA_TIMG12_TSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TSEL", "Trigger Select")
        self.ETSEL = BitField(self, 0x0000001F, "ETSEL", "External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. . Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use.")
        self.TE = BitField(self, 0x00000200, "TE", "Trigger Enable.. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field")

class SA_TIMG12(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_TIMG12_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_TIMG12_FSUB_1(self, 0x404)
        self.FPUB_0 = SA_TIMG12_FPUB_0(self, 0x444)
        self.FPUB_1 = SA_TIMG12_FPUB_1(self, 0x448)
        self.PWREN = SA_TIMG12_PWREN(self, 0x800)
        self.RSTCTL = SA_TIMG12_RSTCTL(self, 0x804)
        self.STAT = SA_TIMG12_STAT(self, 0x814)
        self.CLKDIV = SA_TIMG12_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_TIMG12_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_TIMG12_PDBGCTL(self, 0x1018)
        self.IIDX = SA_TIMG12_IIDX(self, 0x1020)
        self.IMASK = SA_TIMG12_IMASK(self, 0x1028)
        self.RIS = SA_TIMG12_RIS(self, 0x1030)
        self.MIS = SA_TIMG12_MIS(self, 0x1038)
        self.ISET = SA_TIMG12_ISET(self, 0x1040)
        self.ICLR = SA_TIMG12_ICLR(self, 0x1048)
        self.EVT_MODE = SA_TIMG12_EVT_MODE(self, 0x10E0)
        self.DESC = SA_TIMG12_DESC(self, 0x10FC)
        self.CCPD = SA_TIMG12_CCPD(self, 0x1100)
        self.ODIS = SA_TIMG12_ODIS(self, 0x1104)
        self.CCLKCTL = SA_TIMG12_CCLKCTL(self, 0x1108)
        self.CTTRIGCTL = SA_TIMG12_CTTRIGCTL(self, 0x1114)
        self.CTTRIG = SA_TIMG12_CTTRIG(self, 0x111C)
        self.CTR = SA_TIMG12_CTR(self, 0x1800)
        self.CTRCTL = SA_TIMG12_CTRCTL(self, 0x1804)
        self.LOAD = SA_TIMG12_LOAD(self, 0x1808)
        self.CC0 = SA_TIMG12_CC0(self, 0x1810)
        self.CC1 = SA_TIMG12_CC0(self, 0x1814)
        self.CCCTL0 = SA_TIMG12_CCCTL0(self, 0x1830)
        self.CCCTL1 = SA_TIMG12_CCCTL0(self, 0x1834)
        self.OCTL0 = SA_TIMG12_OCTL0(self, 0x1850)
        self.OCTL1 = SA_TIMG12_OCTL0(self, 0x1854)
        self.CCACT0 = SA_TIMG12_CCACT0(self, 0x1870)
        self.CCACT1 = SA_TIMG12_CCACT0(self, 0x1874)
        self.IFCTL0 = SA_TIMG12_IFCTL0(self, 0x1880)
        self.IFCTL1 = SA_TIMG12_IFCTL0(self, 0x1884)
        self.TSEL = SA_TIMG12_TSEL(self, 0x18B0)
        self.IFCTL = Subscriptor(self, "IFCTL{}")
        self.CCACT = Subscriptor(self, "CCACT{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")
        self.OCTL = Subscriptor(self, "OCTL{}")
        self.CC = Subscriptor(self, "CC{}")
        self.FPUB = Subscriptor(self, "FPUB_{}")
        self.CCCTL = Subscriptor(self, "CCCTL{}")

TIMG12 = SA_TIMG12(0x40870000, "TIMG12")

class SA_TIMG6_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subsciber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG6_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG6_FPUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_0", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG6_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG6_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_TIMG6_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_TIMG6_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_TIMG6_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_TIMG6_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUSCLK as clock source if enabled")

class SA_TIMG6_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_TIMG6_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_TIMG6_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.Z = BitField(self, 0x00000001, "Z", "Zero Event mask")
        self.L = BitField(self, 0x00000002, "L", "Load Event mask")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or Compare DN event mask CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or Compare DN event mask CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or Compare UP event mask CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or Compare UP event mask CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow Event mask")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG6_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG6_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event generated an interrupt CCP4")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event generated an interrupt CCP5")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event generated an interrupt CCP4")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event generated an interrupt CCP5")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG6_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event SET")
        self.L = BitField(self, 0x00000002, "L", "Load event SET")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event SET")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event SET")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event SET")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event SET")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event SET")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG6_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event CLEAR")
        self.L = BitField(self, 0x00000002, "L", "Load event CLEAR")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event CLEAR")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event CLEAR")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event CLEAR")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event CLEAR")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event CLEAR")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG6_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x29, "EVT_MODE", "Event Mode")
        self.EVT0_CFG = BitField(self, 0x00000003, "EVT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_TIMG6_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_TIMG6_CCPD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCPD", "CCP Direction")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMG6_ODIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ODIS", "Output Disable")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMG6_CCLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCLKCTL", "Counter Clock Control Register")
        self.CLKEN = BitField(self, 0x00000001, "CLKEN", "Clock Enable. Disables the clock gating to the module. SW has to explicitly program the value to 0 to gate the clock.")

class SA_TIMG6_CPS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPS", "Clock Prescale Register")
        self.PCNT = BitField(self, 0x000000FF, "PCNT", "Pre-Scale Count. This field specifies the pre-scale count value. The selected TIMCLK source is divided by a value of (PCNT+1). A PCNT value of 0 divides TIMCLK by 1, effectively bypassing the divider. A PCNT value of greater than 0 divides the TIMCLK source generating a slower clock")

class SA_TIMG6_CPSV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPSV", "Clock prescale count status register")
        self.CPSVAL = BitField(self, 0x000000FF, "CPSVAL", "Current Prescale Count Value")

class SA_TIMG6_CTTRIGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIGCTL", "Timer Cross Trigger Control Register")
        self.CTEN = BitField(self, 0x00000001, "CTEN", "Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system.. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register.")
        self.EVTCTEN = BitField(self, 0x00000002, "EVTCTEN", "Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path")
        self.EVTCTTRIGSEL = BitField(self, 0x000F0000, "EVTCTTRIGSEL", "Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path")

class SA_TIMG6_CTTRIG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIG", "Timer Cross Trigger Register")
        self.TRIG = BitField(self, 0x00000001, "TRIG", "Generate Cross Trigger. This bit when programmed will generate a synchronized trigger condition all the cross trigger enabled Timer instances including current timer instance.")

class SA_TIMG6_GCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GCTL", "Shadow to active load mask")
        self.SHDWLDEN = BitField(self, 0x00000001, "SHDWLDEN", "Enables shadow to active load of bufferred registers and register fields.")

class SA_TIMG6_CTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTR", "Counter Register")
        self.CCTR = BitField(self, 0x0000FFFF, "CCTR", "Current Counter value")

class SA_TIMG6_CTRCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF80, "CTRCTL", "Counter Control Register")
        self.EN = BitField(self, 0x00000001, "EN", "Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively.")
        self.REPEAT = BitField(self, 0x0000000E, "REPEAT", "Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended.")
        self.CM = BitField(self, 0x00000030, "CM", "Count Mode")
        self.CVAE = BitField(self, 0x30000000, "CVAE", "Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active.")
        self.DRB = BitField(self, 0x00020000, "DRB", "Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode.")
        self.CLC = BitField(self, 0x00000380, "CLC", "Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CAC = BitField(self, 0x00001C00, "CAC", "Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CZC = BitField(self, 0x0000E000, "CZC", "Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")

class SA_TIMG6_LOAD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LOAD", "Load Register")
        self.LD = BitField(self, 0x0000FFFF, "LD", "Load Value")

class SA_TIMG6_CC0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CC0", "Capture or Compare Register 0 to Capture or Compare Register 1")
        self.CCVAL = BitField(self, 0x0000FFFF, "CCVAL", "Capture or compare value")

class SA_TIMG6_CCCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCCTL0", "Capture or Compare Control Registers")
        self.CCOND = BitField(self, 0x00000007, "CCOND", "Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved")
        self.ACOND = BitField(self, 0x00000070, "ACOND", "Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved")
        self.LCOND = BitField(self, 0x00000700, "LCOND", "Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved")
        self.ZCOND = BitField(self, 0x00007000, "ZCOND", "Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved")
        self.COC = BitField(self, 0x00020000, "COC", "Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both).")
        self.CCUPD = BitField(self, 0x001C0000, "CCUPD", "Capture and Compare Update Method. This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0).")
        self.CCACTUPD = BitField(self, 0x1C000000, "CCACTUPD", "CCACT shadow register Update Method. This field controls how updates to the CCCACT shadow register are performed")
        self.CC2SELU = BitField(self, 0x01C00000, "CC2SELU", "Selects the source second CCU event.")
        self.CC2SELD = BitField(self, 0xE0000000, "CC2SELD", "Selects the source second CCD event.")

class SA_TIMG6_OCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OCTL0", "CCP Output Control Registers")
        self.CCPOINV = BitField(self, 0x00000010, "CCPOINV", "CCP Output Invert The output as selected by CCPO is conditionally inverted.")
        self.CCPIV = BitField(self, 0x00000020, "CCPIV", "CCP Initial Value This bit specifies the logical value put on the signal generator state while the counter is disabled (CTRCTL.EN == 0).")
        self.CCPO = BitField(self, 0x0000000F, "CCPO", "CCP Output Source")

class SA_TIMG6_CCACT0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCACT0", "Capture or Compare Action Registers")
        self.ZACT = BitField(self, 0x00000003, "ZACT", "CCP Output Action on Zero Specifies what changes occur to CCP output as the result of a zero event.")
        self.LACT = BitField(self, 0x00000018, "LACT", "CCP Output Action on Load Specifies what changes occur to CCP output as the result of a load event.")
        self.CDACT = BitField(self, 0x000000C0, "CDACT", "CCP Output Action on Compare (Down) This field describes the resulting action of the signal generator upon detecting a compare event while counting down.")
        self.CUACT = BitField(self, 0x00000600, "CUACT", "CCP Output Action on Compare (Up) This field describes the resulting action of the signal generator upon detecting a compare event while counting up.")
        self.CC2DACT = BitField(self, 0x00003000, "CC2DACT", "CCP Output Action on CC2D event.")
        self.CC2UACT = BitField(self, 0x00018000, "CC2UACT", "CCP Output Action on CC2U event.")
        self.SWFRCACT = BitField(self, 0x30000000, "SWFRCACT", "CCP Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")

class SA_TIMG6_IFCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IFCTL0", "Input Filter Control Register")
        self.ISEL = BitField(self, 0x0000000F, "ISEL", "Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved")
        self.INV = BitField(self, 0x00000080, "INV", "Input Inversion This bit controls whether the selected input is inverted.")
        self.FP = BitField(self, 0x00000300, "FP", "Filter Period. This field specifies the sample period for the. input filter. I.e. The input is sampled for FP timer clocks during filtering.")
        self.CPV = BitField(self, 0x00000800, "CPV", "Consecutive Period/Voting Select. This bit controls whether the input filter uses a stricter consecutive period count or majority voting.")
        self.FE = BitField(self, 0x00001000, "FE", "Filter Enable. This bit controls whether the input is filtered by the input filter or bypasses to the edge detect.")

class SA_TIMG6_TSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TSEL", "Trigger Select")
        self.ETSEL = BitField(self, 0x0000001F, "ETSEL", "External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. . Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use.")
        self.TE = BitField(self, 0x00000200, "TE", "Trigger Enable.. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field")

class SA_TIMG6(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_TIMG6_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_TIMG6_FSUB_1(self, 0x404)
        self.FPUB_0 = SA_TIMG6_FPUB_0(self, 0x444)
        self.FPUB_1 = SA_TIMG6_FPUB_1(self, 0x448)
        self.PWREN = SA_TIMG6_PWREN(self, 0x800)
        self.RSTCTL = SA_TIMG6_RSTCTL(self, 0x804)
        self.STAT = SA_TIMG6_STAT(self, 0x814)
        self.CLKDIV = SA_TIMG6_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_TIMG6_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_TIMG6_PDBGCTL(self, 0x1018)
        self.IIDX = SA_TIMG6_IIDX(self, 0x1020)
        self.IMASK = SA_TIMG6_IMASK(self, 0x1028)
        self.RIS = SA_TIMG6_RIS(self, 0x1030)
        self.MIS = SA_TIMG6_MIS(self, 0x1038)
        self.ISET = SA_TIMG6_ISET(self, 0x1040)
        self.ICLR = SA_TIMG6_ICLR(self, 0x1048)
        self.EVT_MODE = SA_TIMG6_EVT_MODE(self, 0x10E0)
        self.DESC = SA_TIMG6_DESC(self, 0x10FC)
        self.CCPD = SA_TIMG6_CCPD(self, 0x1100)
        self.ODIS = SA_TIMG6_ODIS(self, 0x1104)
        self.CCLKCTL = SA_TIMG6_CCLKCTL(self, 0x1108)
        self.CPS = SA_TIMG6_CPS(self, 0x110C)
        self.CPSV = SA_TIMG6_CPSV(self, 0x1110)
        self.CTTRIGCTL = SA_TIMG6_CTTRIGCTL(self, 0x1114)
        self.CTTRIG = SA_TIMG6_CTTRIG(self, 0x111C)
        self.GCTL = SA_TIMG6_GCTL(self, 0x1124)
        self.CTR = SA_TIMG6_CTR(self, 0x1800)
        self.CTRCTL = SA_TIMG6_CTRCTL(self, 0x1804)
        self.LOAD = SA_TIMG6_LOAD(self, 0x1808)
        self.CC0 = SA_TIMG6_CC0(self, 0x1810)
        self.CC1 = SA_TIMG6_CC0(self, 0x1814)
        self.CCCTL0 = SA_TIMG6_CCCTL0(self, 0x1830)
        self.CCCTL1 = SA_TIMG6_CCCTL0(self, 0x1834)
        self.OCTL0 = SA_TIMG6_OCTL0(self, 0x1850)
        self.OCTL1 = SA_TIMG6_OCTL0(self, 0x1854)
        self.CCACT0 = SA_TIMG6_CCACT0(self, 0x1870)
        self.CCACT1 = SA_TIMG6_CCACT0(self, 0x1874)
        self.IFCTL0 = SA_TIMG6_IFCTL0(self, 0x1880)
        self.IFCTL1 = SA_TIMG6_IFCTL0(self, 0x1884)
        self.TSEL = SA_TIMG6_TSEL(self, 0x18B0)
        self.IFCTL = Subscriptor(self, "IFCTL{}")
        self.CCACT = Subscriptor(self, "CCACT{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")
        self.OCTL = Subscriptor(self, "OCTL{}")
        self.CC = Subscriptor(self, "CC{}")
        self.FPUB = Subscriptor(self, "FPUB_{}")
        self.CCCTL = Subscriptor(self, "CCCTL{}")

TIMG6 = SA_TIMG6(0x40868000, "TIMG6")

class SA_TIMG7_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subsciber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG7_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG7_FPUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_0", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG7_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG7_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_TIMG7_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_TIMG7_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_TIMG7_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_TIMG7_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUSCLK as clock source if enabled")

class SA_TIMG7_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_TIMG7_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_TIMG7_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.Z = BitField(self, 0x00000001, "Z", "Zero Event mask")
        self.L = BitField(self, 0x00000002, "L", "Load Event mask")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or Compare DN event mask CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or Compare DN event mask CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or Compare UP event mask CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or Compare UP event mask CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow Event mask")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG7_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG7_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.CCD4 = BitField(self, 0x00001000, "CCD4", "Compare down event generated an interrupt CCP4")
        self.CCD5 = BitField(self, 0x00002000, "CCD5", "Compare down event generated an interrupt CCP5")
        self.CCU4 = BitField(self, 0x00004000, "CCU4", "Compare up event generated an interrupt CCP4")
        self.CCU5 = BitField(self, 0x00008000, "CCU5", "Compare up event generated an interrupt CCP5")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG7_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event SET")
        self.L = BitField(self, 0x00000002, "L", "Load event SET")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event SET")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event SET")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event SET")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event SET")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event SET")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG7_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event CLEAR")
        self.L = BitField(self, 0x00000002, "L", "Load event CLEAR")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event CLEAR")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event CLEAR")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event CLEAR")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event CLEAR")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event CLEAR")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG7_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x29, "EVT_MODE", "Event Mode")
        self.EVT0_CFG = BitField(self, 0x00000003, "EVT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_TIMG7_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_TIMG7_CCPD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCPD", "CCP Direction")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMG7_ODIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ODIS", "Output Disable")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMG7_CCLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCLKCTL", "Counter Clock Control Register")
        self.CLKEN = BitField(self, 0x00000001, "CLKEN", "Clock Enable. Disables the clock gating to the module. SW has to explicitly program the value to 0 to gate the clock.")

class SA_TIMG7_CPS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPS", "Clock Prescale Register")
        self.PCNT = BitField(self, 0x000000FF, "PCNT", "Pre-Scale Count. This field specifies the pre-scale count value. The selected TIMCLK source is divided by a value of (PCNT+1). A PCNT value of 0 divides TIMCLK by 1, effectively bypassing the divider. A PCNT value of greater than 0 divides the TIMCLK source generating a slower clock")

class SA_TIMG7_CPSV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPSV", "Clock prescale count status register")
        self.CPSVAL = BitField(self, 0x000000FF, "CPSVAL", "Current Prescale Count Value")

class SA_TIMG7_CTTRIGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIGCTL", "Timer Cross Trigger Control Register")
        self.CTEN = BitField(self, 0x00000001, "CTEN", "Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system.. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register.")
        self.EVTCTEN = BitField(self, 0x00000002, "EVTCTEN", "Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path")
        self.EVTCTTRIGSEL = BitField(self, 0x000F0000, "EVTCTTRIGSEL", "Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path")

class SA_TIMG7_CTTRIG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIG", "Timer Cross Trigger Register")
        self.TRIG = BitField(self, 0x00000001, "TRIG", "Generate Cross Trigger. This bit when programmed will generate a synchronized trigger condition all the cross trigger enabled Timer instances including current timer instance.")

class SA_TIMG7_GCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "GCTL", "Shadow to active load mask")
        self.SHDWLDEN = BitField(self, 0x00000001, "SHDWLDEN", "Enables shadow to active load of bufferred registers and register fields.")

class SA_TIMG7_CTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTR", "Counter Register")
        self.CCTR = BitField(self, 0x0000FFFF, "CCTR", "Current Counter value")

class SA_TIMG7_CTRCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF80, "CTRCTL", "Counter Control Register")
        self.EN = BitField(self, 0x00000001, "EN", "Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively.")
        self.REPEAT = BitField(self, 0x0000000E, "REPEAT", "Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended.")
        self.CM = BitField(self, 0x00000030, "CM", "Count Mode")
        self.CVAE = BitField(self, 0x30000000, "CVAE", "Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active.")
        self.DRB = BitField(self, 0x00020000, "DRB", "Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode.")
        self.CLC = BitField(self, 0x00000380, "CLC", "Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CAC = BitField(self, 0x00001C00, "CAC", "Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CZC = BitField(self, 0x0000E000, "CZC", "Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")

class SA_TIMG7_LOAD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LOAD", "Load Register")
        self.LD = BitField(self, 0x0000FFFF, "LD", "Load Value")

class SA_TIMG7_CC0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CC0", "Capture or Compare Register 0 to Capture or Compare Register 1")
        self.CCVAL = BitField(self, 0x0000FFFF, "CCVAL", "Capture or compare value")

class SA_TIMG7_CCCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCCTL0", "Capture or Compare Control Registers")
        self.CCOND = BitField(self, 0x00000007, "CCOND", "Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved")
        self.ACOND = BitField(self, 0x00000070, "ACOND", "Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved")
        self.LCOND = BitField(self, 0x00000700, "LCOND", "Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved")
        self.ZCOND = BitField(self, 0x00007000, "ZCOND", "Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved")
        self.COC = BitField(self, 0x00020000, "COC", "Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both).")
        self.CCUPD = BitField(self, 0x001C0000, "CCUPD", "Capture and Compare Update Method. This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0).")
        self.CCACTUPD = BitField(self, 0x1C000000, "CCACTUPD", "CCACT shadow register Update Method. This field controls how updates to the CCCACT shadow register are performed")
        self.CC2SELU = BitField(self, 0x01C00000, "CC2SELU", "Selects the source second CCU event.")
        self.CC2SELD = BitField(self, 0xE0000000, "CC2SELD", "Selects the source second CCD event.")

class SA_TIMG7_OCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OCTL0", "CCP Output Control Registers")
        self.CCPOINV = BitField(self, 0x00000010, "CCPOINV", "CCP Output Invert The output as selected by CCPO is conditionally inverted.")
        self.CCPIV = BitField(self, 0x00000020, "CCPIV", "CCP Initial Value This bit specifies the logical value put on the signal generator state while the counter is disabled (CTRCTL.EN == 0).")
        self.CCPO = BitField(self, 0x0000000F, "CCPO", "CCP Output Source")

class SA_TIMG7_CCACT0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCACT0", "Capture or Compare Action Registers")
        self.ZACT = BitField(self, 0x00000003, "ZACT", "CCP Output Action on Zero Specifies what changes occur to CCP output as the result of a zero event.")
        self.LACT = BitField(self, 0x00000018, "LACT", "CCP Output Action on Load Specifies what changes occur to CCP output as the result of a load event.")
        self.CDACT = BitField(self, 0x000000C0, "CDACT", "CCP Output Action on Compare (Down) This field describes the resulting action of the signal generator upon detecting a compare event while counting down.")
        self.CUACT = BitField(self, 0x00000600, "CUACT", "CCP Output Action on Compare (Up) This field describes the resulting action of the signal generator upon detecting a compare event while counting up.")
        self.CC2DACT = BitField(self, 0x00003000, "CC2DACT", "CCP Output Action on CC2D event.")
        self.CC2UACT = BitField(self, 0x00018000, "CC2UACT", "CCP Output Action on CC2U event.")
        self.SWFRCACT = BitField(self, 0x30000000, "SWFRCACT", "CCP Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")

class SA_TIMG7_IFCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IFCTL0", "Input Filter Control Register")
        self.ISEL = BitField(self, 0x0000000F, "ISEL", "Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved")
        self.INV = BitField(self, 0x00000080, "INV", "Input Inversion This bit controls whether the selected input is inverted.")
        self.FP = BitField(self, 0x00000300, "FP", "Filter Period. This field specifies the sample period for the. input filter. I.e. The input is sampled for FP timer clocks during filtering.")
        self.CPV = BitField(self, 0x00000800, "CPV", "Consecutive Period/Voting Select. This bit controls whether the input filter uses a stricter consecutive period count or majority voting.")
        self.FE = BitField(self, 0x00001000, "FE", "Filter Enable. This bit controls whether the input is filtered by the input filter or bypasses to the edge detect.")

class SA_TIMG7_TSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TSEL", "Trigger Select")
        self.ETSEL = BitField(self, 0x0000001F, "ETSEL", "External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. . Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use.")
        self.TE = BitField(self, 0x00000200, "TE", "Trigger Enable.. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field")

class SA_TIMG7(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_TIMG7_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_TIMG7_FSUB_1(self, 0x404)
        self.FPUB_0 = SA_TIMG7_FPUB_0(self, 0x444)
        self.FPUB_1 = SA_TIMG7_FPUB_1(self, 0x448)
        self.PWREN = SA_TIMG7_PWREN(self, 0x800)
        self.RSTCTL = SA_TIMG7_RSTCTL(self, 0x804)
        self.STAT = SA_TIMG7_STAT(self, 0x814)
        self.CLKDIV = SA_TIMG7_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_TIMG7_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_TIMG7_PDBGCTL(self, 0x1018)
        self.IIDX = SA_TIMG7_IIDX(self, 0x1020)
        self.IMASK = SA_TIMG7_IMASK(self, 0x1028)
        self.RIS = SA_TIMG7_RIS(self, 0x1030)
        self.MIS = SA_TIMG7_MIS(self, 0x1038)
        self.ISET = SA_TIMG7_ISET(self, 0x1040)
        self.ICLR = SA_TIMG7_ICLR(self, 0x1048)
        self.EVT_MODE = SA_TIMG7_EVT_MODE(self, 0x10E0)
        self.DESC = SA_TIMG7_DESC(self, 0x10FC)
        self.CCPD = SA_TIMG7_CCPD(self, 0x1100)
        self.ODIS = SA_TIMG7_ODIS(self, 0x1104)
        self.CCLKCTL = SA_TIMG7_CCLKCTL(self, 0x1108)
        self.CPS = SA_TIMG7_CPS(self, 0x110C)
        self.CPSV = SA_TIMG7_CPSV(self, 0x1110)
        self.CTTRIGCTL = SA_TIMG7_CTTRIGCTL(self, 0x1114)
        self.CTTRIG = SA_TIMG7_CTTRIG(self, 0x111C)
        self.GCTL = SA_TIMG7_GCTL(self, 0x1124)
        self.CTR = SA_TIMG7_CTR(self, 0x1800)
        self.CTRCTL = SA_TIMG7_CTRCTL(self, 0x1804)
        self.LOAD = SA_TIMG7_LOAD(self, 0x1808)
        self.CC0 = SA_TIMG7_CC0(self, 0x1810)
        self.CC1 = SA_TIMG7_CC0(self, 0x1814)
        self.CCCTL0 = SA_TIMG7_CCCTL0(self, 0x1830)
        self.CCCTL1 = SA_TIMG7_CCCTL0(self, 0x1834)
        self.OCTL0 = SA_TIMG7_OCTL0(self, 0x1850)
        self.OCTL1 = SA_TIMG7_OCTL0(self, 0x1854)
        self.CCACT0 = SA_TIMG7_CCACT0(self, 0x1870)
        self.CCACT1 = SA_TIMG7_CCACT0(self, 0x1874)
        self.IFCTL0 = SA_TIMG7_IFCTL0(self, 0x1880)
        self.IFCTL1 = SA_TIMG7_IFCTL0(self, 0x1884)
        self.TSEL = SA_TIMG7_TSEL(self, 0x18B0)
        self.IFCTL = Subscriptor(self, "IFCTL{}")
        self.CCACT = Subscriptor(self, "CCACT{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")
        self.OCTL = Subscriptor(self, "OCTL{}")
        self.CC = Subscriptor(self, "CC{}")
        self.FPUB = Subscriptor(self, "FPUB_{}")
        self.CCCTL = Subscriptor(self, "CCCTL{}")

TIMG7 = SA_TIMG7(0x4086A000, "TIMG7")

class SA_TIMG8_FSUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_0", "Subsciber Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG8_FSUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FSUB_1", "Subscriber Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG8_FPUB_0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_0", "Publisher Port 0")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG8_FPUB_1(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "FPUB_1", "Publisher Port 1")
        self.CHANID = BitField(self, 0x0000000F, "CHANID", "0 = disconnected.. 1-15 = connected to channelID = CHANID.")

class SA_TIMG8_PWREN(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PWREN", "Power enable")
        self.ENABLE = BitField(self, 0x00000001, "ENABLE", "Enable the power")
        self.KEY = BitField(self, 0xFF000000, "KEY", "KEY to allow Power State Change")

class SA_TIMG8_RSTCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RSTCTL", "Reset Control")
        self.RESETSTKYCLR = BitField(self, 0x00000002, "RESETSTKYCLR", "Clear the RESETSTKY bit in the STAT register")
        self.RESETASSERT = BitField(self, 0x00000001, "RESETASSERT", "Assert reset to the peripheral")
        self.KEY = BitField(self, 0xFF000000, "KEY", "Unlock key")

class SA_TIMG8_STAT(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "STAT", "Status Register")
        self.RESETSTKY = BitField(self, 0x00010000, "RESETSTKY", "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register")

class SA_TIMG8_CLKDIV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKDIV", "Clock Divider")
        self.RATIO = BitField(self, 0x00000007, "RATIO", "Selects divide ratio of module clock")

class SA_TIMG8_CLKSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CLKSEL", "Clock Select for Ultra Low Power peripherals")
        self.LFCLK_SEL = BitField(self, 0x00000002, "LFCLK_SEL", "Selects LFCLK as clock source if enabled")
        self.MFCLK_SEL = BitField(self, 0x00000004, "MFCLK_SEL", "Selects MFCLK as clock source if enabled")
        self.BUSCLK_SEL = BitField(self, 0x00000008, "BUSCLK_SEL", "Selects BUSCLK as clock source if enabled")

class SA_TIMG8_PDBGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "PDBGCTL", "Peripheral Debug Control")
        self.FREE = BitField(self, 0x00000001, "FREE", "Free run control")
        self.SOFT = BitField(self, 0x00000002, "SOFT", "Soft halt boundary control. This function is only available, if [FREE] is set to 'STOP'")

class SA_TIMG8_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_TIMG8_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.Z = BitField(self, 0x00000001, "Z", "Zero Event mask")
        self.L = BitField(self, 0x00000002, "L", "Load Event mask")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or Compare DN event mask CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or Compare DN event mask CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or Compare UP event mask CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or Compare UP event mask CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow Event mask")
        self.DC = BitField(self, 0x08000000, "DC", "Direction Change Event mask")
        self.QEIERR = BitField(self, 0x10000000, "QEIERR", "QEIERR Event mask")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG8_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.DC = BitField(self, 0x08000000, "DC", "Direction Change")
        self.QEIERR = BitField(self, 0x10000000, "QEIERR", "QEIERR, set on an incorrect state transition on the encoder interface.")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG8_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event generated an interrupt.")
        self.L = BitField(self, 0x00000002, "L", "Load event generated an interrupt.")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event generated an interrupt CCP0")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event generated an interrupt CCP1")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event generated an interrupt CCP0")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event generated an interrupt CCP1")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger overflow")
        self.DC = BitField(self, 0x08000000, "DC", "Direction Change")
        self.QEIERR = BitField(self, 0x10000000, "QEIERR", "QEIERR")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG8_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event SET")
        self.L = BitField(self, 0x00000002, "L", "Load event SET")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event SET")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event SET")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event SET")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event SET")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event SET")
        self.DC = BitField(self, 0x08000000, "DC", "Direction Change event SET")
        self.QEIERR = BitField(self, 0x10000000, "QEIERR", "QEIERR event SET")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG8_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.Z = BitField(self, 0x00000001, "Z", "Zero event CLEAR")
        self.L = BitField(self, 0x00000002, "L", "Load event CLEAR")
        self.CCD0 = BitField(self, 0x00000010, "CCD0", "Capture or compare down event CLEAR")
        self.CCD1 = BitField(self, 0x00000020, "CCD1", "Capture or compare down event CLEAR")
        self.CCU0 = BitField(self, 0x00000100, "CCU0", "Capture or compare up event CLEAR")
        self.CCU1 = BitField(self, 0x00000200, "CCU1", "Capture or compare up event CLEAR")
        self.TOV = BitField(self, 0x02000000, "TOV", "Trigger Overflow event CLEAR")
        self.DC = BitField(self, 0x08000000, "DC", "Direction Change event CLEAR")
        self.QEIERR = BitField(self, 0x10000000, "QEIERR", "QEIERR event CLEAR")
        self.CCD = Subscriptor(self, "CCD{}")
        self.CCU = Subscriptor(self, "CCU{}")

class SA_TIMG8_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x29, "EVT_MODE", "Event Mode")
        self.EVT0_CFG = BitField(self, 0x00000003, "EVT0_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][0]")
        self.EVT1_CFG = BitField(self, 0x0000000C, "EVT1_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT2_CFG = BitField(self, 0x00000030, "EVT2_CFG", "Event line mode select for event corresponding to [IPSTANDARD.INT_EVENT][1]")
        self.EVT_CFG = Subscriptor(self, "EVT{}_CFG")

class SA_TIMG8_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_TIMG8_CCPD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCPD", "CCP Direction")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMG8_ODIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ODIS", "Output Disable")
        self.C0CCP0 = BitField(self, 0x00000001, "C0CCP0", "Counter CCP0 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP1 = BitField(self, 0x00000002, "C0CCP1", "Counter CCP1 Disable Mask. Defines whether CCP0 of Counter n is forced low or not")
        self.C0CCP = Subscriptor(self, "C0CCP{}")

class SA_TIMG8_CCLKCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCLKCTL", "Counter Clock Control Register")
        self.CLKEN = BitField(self, 0x00000001, "CLKEN", "Clock Enable. Disables the clock gating to the module. SW has to explicitly program the value to 0 to gate the clock.")

class SA_TIMG8_CPS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPS", "Clock Prescale Register")
        self.PCNT = BitField(self, 0x000000FF, "PCNT", "Pre-Scale Count. This field specifies the pre-scale count value. The selected TIMCLK source is divided by a value of (PCNT+1). A PCNT value of 0 divides TIMCLK by 1, effectively bypassing the divider. A PCNT value of greater than 0 divides the TIMCLK source generating a slower clock")

class SA_TIMG8_CPSV(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CPSV", "Clock prescale count status register")
        self.CPSVAL = BitField(self, 0x000000FF, "CPSVAL", "Current Prescale Count Value")

class SA_TIMG8_CTTRIGCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIGCTL", "Timer Cross Trigger Control Register")
        self.CTEN = BitField(self, 0x00000001, "CTEN", "Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system.. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register.")
        self.EVTCTEN = BitField(self, 0x00000002, "EVTCTEN", "Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path")
        self.EVTCTTRIGSEL = BitField(self, 0x000F0000, "EVTCTTRIGSEL", "Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path")

class SA_TIMG8_CTTRIG(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTTRIG", "Timer Cross Trigger Register")
        self.TRIG = BitField(self, 0x00000001, "TRIG", "Generate Cross Trigger. This bit when programmed will generate a synchronized trigger condition all the cross trigger enabled Timer instances including current timer instance.")

class SA_TIMG8_CTR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CTR", "Counter Register")
        self.CCTR = BitField(self, 0x0000FFFF, "CCTR", "Current Counter value")

class SA_TIMG8_CTRCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0xFF80, "CTRCTL", "Counter Control Register")
        self.EN = BitField(self, 0x00000001, "EN", "Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively.")
        self.REPEAT = BitField(self, 0x0000000E, "REPEAT", "Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended.")
        self.CM = BitField(self, 0x00000030, "CM", "Count Mode")
        self.CVAE = BitField(self, 0x30000000, "CVAE", "Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active.")
        self.DRB = BitField(self, 0x00020000, "DRB", "Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode.")
        self.CLC = BitField(self, 0x00000380, "CLC", "Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CAC = BitField(self, 0x00001C00, "CAC", "Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")
        self.CZC = BitField(self, 0x0000E000, "CZC", "Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. . Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.")

class SA_TIMG8_LOAD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "LOAD", "Load Register")
        self.LD = BitField(self, 0x0000FFFF, "LD", "Load Value")

class SA_TIMG8_CC0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CC0", "Capture or Compare Register 0 to Capture or Compare Register 1")
        self.CCVAL = BitField(self, 0x0000FFFF, "CCVAL", "Capture or compare value")

class SA_TIMG8_CCCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCCTL0", "Capture or Compare Control Registers")
        self.CCOND = BitField(self, 0x00000007, "CCOND", "Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved")
        self.ACOND = BitField(self, 0x00000070, "ACOND", "Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved")
        self.LCOND = BitField(self, 0x00000700, "LCOND", "Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved")
        self.ZCOND = BitField(self, 0x00007000, "ZCOND", "Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved")
        self.COC = BitField(self, 0x00020000, "COC", "Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both).")
        self.CCACTUPD = BitField(self, 0x1C000000, "CCACTUPD", "CCACT shadow register Update Method. This field controls how updates to the CCCACT shadow register are performed")
        self.CC2SELU = BitField(self, 0x01C00000, "CC2SELU", "Selects the source second CCU event.")
        self.CC2SELD = BitField(self, 0xE0000000, "CC2SELD", "Selects the source second CCD event.")

class SA_TIMG8_OCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "OCTL0", "CCP Output Control Registers")
        self.CCPOINV = BitField(self, 0x00000010, "CCPOINV", "CCP Output Invert The output as selected by CCPO is conditionally inverted.")
        self.CCPIV = BitField(self, 0x00000020, "CCPIV", "CCP Initial Value This bit specifies the logical value put on the signal generator state while the counter is disabled (CTRCTL.EN == 0).")
        self.CCPO = BitField(self, 0x0000000F, "CCPO", "CCP Output Source")

class SA_TIMG8_CCACT0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "CCACT0", "Capture or Compare Action Registers")
        self.ZACT = BitField(self, 0x00000003, "ZACT", "CCP Output Action on Zero Specifies what changes occur to CCP output as the result of a zero event.")
        self.LACT = BitField(self, 0x00000018, "LACT", "CCP Output Action on Load Specifies what changes occur to CCP output as the result of a load event.")
        self.CDACT = BitField(self, 0x000000C0, "CDACT", "CCP Output Action on Compare (Down) This field describes the resulting action of the signal generator upon detecting a compare event while counting down.")
        self.CUACT = BitField(self, 0x00000600, "CUACT", "CCP Output Action on Compare (Up) This field describes the resulting action of the signal generator upon detecting a compare event while counting up.")
        self.CC2DACT = BitField(self, 0x00003000, "CC2DACT", "CCP Output Action on CC2D event.")
        self.CC2UACT = BitField(self, 0x00018000, "CC2UACT", "CCP Output Action on CC2U event.")
        self.SWFRCACT = BitField(self, 0x30000000, "SWFRCACT", "CCP Output Action on Software Froce Output. This field describes the resulting action of software force. This action has a shadow register, which will be updated under specific condition. So that this register cannot take into effect immediately.")

class SA_TIMG8_IFCTL0(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IFCTL0", "Input Filter Control Register")
        self.ISEL = BitField(self, 0x0000000F, "ISEL", "Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved")
        self.INV = BitField(self, 0x00000080, "INV", "Input Inversion This bit controls whether the selected input is inverted.")
        self.FP = BitField(self, 0x00000300, "FP", "Filter Period. This field specifies the sample period for the. input filter. I.e. The input is sampled for FP timer clocks during filtering.")
        self.CPV = BitField(self, 0x00000800, "CPV", "Consecutive Period/Voting Select. This bit controls whether the input filter uses a stricter consecutive period count or majority voting.")
        self.FE = BitField(self, 0x00001000, "FE", "Filter Enable. This bit controls whether the input is filtered by the input filter or bypasses to the edge detect.")

class SA_TIMG8_TSEL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TSEL", "Trigger Select")
        self.ETSEL = BitField(self, 0x0000001F, "ETSEL", "External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. . Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use.")
        self.TE = BitField(self, 0x00000200, "TE", "Trigger Enable.. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field")

class SA_TIMG8_QDIR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "QDIR", "Count Direction Register")
        self.DIR = BitField(self, 0x00000001, "DIR", "Direction of count")

class SA_TIMG8(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "PERIPHERALREGION")
        self.FSUB_0 = SA_TIMG8_FSUB_0(self, 0x400)
        self.FSUB_1 = SA_TIMG8_FSUB_1(self, 0x404)
        self.FPUB_0 = SA_TIMG8_FPUB_0(self, 0x444)
        self.FPUB_1 = SA_TIMG8_FPUB_1(self, 0x448)
        self.PWREN = SA_TIMG8_PWREN(self, 0x800)
        self.RSTCTL = SA_TIMG8_RSTCTL(self, 0x804)
        self.STAT = SA_TIMG8_STAT(self, 0x814)
        self.CLKDIV = SA_TIMG8_CLKDIV(self, 0x1000)
        self.CLKSEL = SA_TIMG8_CLKSEL(self, 0x1008)
        self.PDBGCTL = SA_TIMG8_PDBGCTL(self, 0x1018)
        self.IIDX = SA_TIMG8_IIDX(self, 0x1020)
        self.IMASK = SA_TIMG8_IMASK(self, 0x1028)
        self.RIS = SA_TIMG8_RIS(self, 0x1030)
        self.MIS = SA_TIMG8_MIS(self, 0x1038)
        self.ISET = SA_TIMG8_ISET(self, 0x1040)
        self.ICLR = SA_TIMG8_ICLR(self, 0x1048)
        self.EVT_MODE = SA_TIMG8_EVT_MODE(self, 0x10E0)
        self.DESC = SA_TIMG8_DESC(self, 0x10FC)
        self.CCPD = SA_TIMG8_CCPD(self, 0x1100)
        self.ODIS = SA_TIMG8_ODIS(self, 0x1104)
        self.CCLKCTL = SA_TIMG8_CCLKCTL(self, 0x1108)
        self.CPS = SA_TIMG8_CPS(self, 0x110C)
        self.CPSV = SA_TIMG8_CPSV(self, 0x1110)
        self.CTTRIGCTL = SA_TIMG8_CTTRIGCTL(self, 0x1114)
        self.CTTRIG = SA_TIMG8_CTTRIG(self, 0x111C)
        self.CTR = SA_TIMG8_CTR(self, 0x1800)
        self.CTRCTL = SA_TIMG8_CTRCTL(self, 0x1804)
        self.LOAD = SA_TIMG8_LOAD(self, 0x1808)
        self.CC0 = SA_TIMG8_CC0(self, 0x1810)
        self.CC1 = SA_TIMG8_CC0(self, 0x1814)
        self.CCCTL0 = SA_TIMG8_CCCTL0(self, 0x1830)
        self.CCCTL1 = SA_TIMG8_CCCTL0(self, 0x1834)
        self.OCTL0 = SA_TIMG8_OCTL0(self, 0x1850)
        self.OCTL1 = SA_TIMG8_OCTL0(self, 0x1854)
        self.CCACT0 = SA_TIMG8_CCACT0(self, 0x1870)
        self.CCACT1 = SA_TIMG8_CCACT0(self, 0x1874)
        self.IFCTL0 = SA_TIMG8_IFCTL0(self, 0x1880)
        self.IFCTL1 = SA_TIMG8_IFCTL0(self, 0x1884)
        self.TSEL = SA_TIMG8_TSEL(self, 0x18B0)
        self.QDIR = SA_TIMG8_QDIR(self, 0x18BC)
        self.IFCTL = Subscriptor(self, "IFCTL{}")
        self.CCACT = Subscriptor(self, "CCACT{}")
        self.FSUB = Subscriptor(self, "FSUB_{}")
        self.OCTL = Subscriptor(self, "OCTL{}")
        self.CC = Subscriptor(self, "CC{}")
        self.FPUB = Subscriptor(self, "FPUB_{}")
        self.CCCTL = Subscriptor(self, "CCCTL{}")

TIMG8 = SA_TIMG8(0x40090000, "TIMG8")

class SA_DEBUGSS_IIDX(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IIDX", "Interrupt index")
        self.STAT = BitField(self, 0x000000FF, "STAT", "Interrupt index status")

class SA_DEBUGSS_IMASK(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "IMASK", "Interrupt mask")
        self.TXIFG = BitField(self, 0x00000001, "TXIFG", "Masks TXIFG in MIS register")
        self.RXIFG = BitField(self, 0x00000002, "RXIFG", "Masks RXIFG in MIS register")
        self.PWRUPIFG = BitField(self, 0x00000004, "PWRUPIFG", "Masks PWRUPIFG in MIS register")
        self.PWRDWNIFG = BitField(self, 0x00000008, "PWRDWNIFG", "Masks PWRDWNIFG in MIS register")

class SA_DEBUGSS_RIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RIS", "Raw interrupt status")
        self.TXIFG = BitField(self, 0x00000001, "TXIFG", "Raw interrupt status for TXIFG")
        self.RXIFG = BitField(self, 0x00000002, "RXIFG", "Raw interrupt status for RXIFG")
        self.PWRUPIFG = BitField(self, 0x00000004, "PWRUPIFG", "Raw interrupt status for PWRUPIFG")
        self.PWRDWNIFG = BitField(self, 0x00000008, "PWRDWNIFG", "Raw interrupt status for PWRDWNIFG")

class SA_DEBUGSS_MIS(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "MIS", "Masked interrupt status")
        self.TXIFG = BitField(self, 0x00000001, "TXIFG", "Masked interrupt status for TXIFG")
        self.RXIFG = BitField(self, 0x00000002, "RXIFG", "Masked interrupt status for RXIFG")
        self.PWRUPIFG = BitField(self, 0x00000004, "PWRUPIFG", "Masked interrupt status for PWRUPIFG")
        self.PWRDWNIFG = BitField(self, 0x00000008, "PWRDWNIFG", "Masked interrupt status for PWRDWNIFG")

class SA_DEBUGSS_ISET(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ISET", "Interrupt set")
        self.TXIFG = BitField(self, 0x00000001, "TXIFG", "Sets TXIFG in RIS register")
        self.RXIFG = BitField(self, 0x00000002, "RXIFG", "Sets RXIFG in RIS register")
        self.PWRUPIFG = BitField(self, 0x00000004, "PWRUPIFG", "Sets PWRUPIFG in RIS register")
        self.PWRDWNIFG = BitField(self, 0x00000008, "PWRDWNIFG", "Sets PWRDWNIFG in RIS register")

class SA_DEBUGSS_ICLR(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "ICLR", "Interrupt clear")
        self.TXIFG = BitField(self, 0x00000001, "TXIFG", "Clears TXIFG in RIS register")
        self.RXIFG = BitField(self, 0x00000002, "RXIFG", "Clears RXIFG in RIS register")
        self.PWRUPIFG = BitField(self, 0x00000004, "PWRUPIFG", "Clears PWRUPIFG in RIS register")
        self.PWRDWNIFG = BitField(self, 0x00000008, "PWRDWNIFG", "Clears PWRDWNIFG in RIS register")

class SA_DEBUGSS_EVT_MODE(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "EVT_MODE", "Event Mode")
        self.INT0_CFG = BitField(self, 0x00000003, "INT0_CFG", "Event line mode select for peripheral events")

class SA_DEBUGSS_DESC(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "DESC", "Module Description")
        self.MINREV = BitField(self, 0x0000000F, "MINREV", "Minor rev of the IP")
        self.MAJREV = BitField(self, 0x000000F0, "MAJREV", "Major rev of the IP")
        self.INSTNUM = BitField(self, 0x00000F00, "INSTNUM", "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances")
        self.FEATUREVER = BitField(self, 0x0000F000, "FEATUREVER", "Feature Set for the module *instance*")
        self.MODULEID = BitField(self, 0xFFFF0000, "MODULEID", "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness.")

class SA_DEBUGSS_TXD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TXD", "Transmit data register")
        self.TX_DATA = BitField(self, 0xFFFFFFFF, "TX_DATA", "Contains data written by an external debug tool to the SEC-AP TXDATA register")

class SA_DEBUGSS_TXCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "TXCTL", "Transmit control register")
        self.TRANSMIT = BitField(self, 0x00000001, "TRANSMIT", "Indicates data request in DSSM.TXD, set on write via Debug AP to DSSM.TXD.. A read of the DSSM.TXD register by SW will clear the TX field. The tool can check that TXD is empty by reading this field.")
        self.TRANSMIT_FLAGS = BitField(self, 0xFFFFFFFE, "TRANSMIT_FLAGS", "Generic TX flags that can be set by external debug tool. Functionality is defined by SW.")

class SA_DEBUGSS_RXD(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RXD", "Receive data register")
        self.RX_DATA = BitField(self, 0xFFFFFFFF, "RX_DATA", "Contains data written by SM/OW.")

class SA_DEBUGSS_RXCTL(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "RXCTL", "Receive control register")
        self.RECEIVE = BitField(self, 0x00000001, "RECEIVE", "Indicates SW write to the DSSM.RXD register.. A read of the DSSM.RXD register by SWD Access Port will clear the RX field.")
        self.RECEIVE_FLAGS = BitField(self, 0x000000FE, "RECEIVE_FLAGS", "Generic RX flags that can be set by SW and read by external debug tool. Functionality is defined by SW.")

class SA_DEBUGSS_SPECIAL_AUTH(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, 0x13, "SPECIAL_AUTH", "Special enable authorization register")
        self.SECAPEN = BitField(self, 0x00000001, "SECAPEN", "An active high input. When asserted (and SWD access is also permitted), the debug tools can use the Security-AP to communicate with security control logic. When deasserted, a DAPBUS firewall will isolate the AP and prevent access to the Security-AP.")
        self.SWDPORTEN = BitField(self, 0x00000002, "SWDPORTEN", "When asserted, the SW-DP functions normally. . When deasserted, the SW-DP effectively disables all external debug access.")
        self.DFTAPEN = BitField(self, 0x00000004, "DFTAPEN", "An active high input. When asserted (and SWD access is also permitted), the debug tools can then access the DFT-AP external to the DebugSS lite. When deasserted, a DAPBUS firewall will isolate the AP and prevent access.")
        self.ETAPEN = BitField(self, 0x00000008, "ETAPEN", "An active high input. When asserted (and SWD access is also permitted), the debug tools can then access an ET-AP external to the DebugSS lite. When deasserted, a DAPBUS firewall will isolate the AP and prevent access.")
        self.CFGAPEN = BitField(self, 0x00000010, "CFGAPEN", "An active high input. When asserted (and SWD access is also permitted), the debug tools can use the Config-AP to read device configuration information. When deasserted, a DAPBUS firewall will isolate the AP and prevent access to the Config-AP.")
        self.AHBAPEN = BitField(self, 0x00000020, "AHBAPEN", "Disabling / enabling debug access to the M0+ Core via the AHB-AP DAP bus isolation.")
        self.PWRAPEN = BitField(self, 0x00000040, "PWRAPEN", "An active high input. When asserted (and SWD access is also permitted), the debug tools can then access the PWR-AP to power and reset state of the CPU. When deasserted, a DAPBUS firewall will isolate the AP and prevent access.")

class SA_DEBUGSS_APP_AUTH(RegisterBase):
    
    def __init__(self, peripheral, offset):
        super().__init__(peripheral, offset, None, "APP_AUTH", "Application CPU0 authorization register")
        self.DBGEN = BitField(self, 0x00000001, "DBGEN", "Controls invasive debug enable.")
        self.NIDEN = BitField(self, 0x00000002, "NIDEN", "Controls non-invasive debug enable.")
        self.SPIDEN = BitField(self, 0x00000004, "SPIDEN", "Secure invasive debug enable.")
        self.SPNIDEN = BitField(self, 0x00000008, "SPNIDEN", "Secure non-invasive debug enable.")

class SA_DEBUGSS(PeripheralBase):

    def __init__(self, base, name):
        super().__init__(base, name, "DSSM")
        self.IIDX = SA_DEBUGSS_IIDX(self, 0x1020)
        self.IMASK = SA_DEBUGSS_IMASK(self, 0x1028)
        self.RIS = SA_DEBUGSS_RIS(self, 0x1030)
        self.MIS = SA_DEBUGSS_MIS(self, 0x1038)
        self.ISET = SA_DEBUGSS_ISET(self, 0x1040)
        self.ICLR = SA_DEBUGSS_ICLR(self, 0x1048)
        self.EVT_MODE = SA_DEBUGSS_EVT_MODE(self, 0x10E0)
        self.DESC = SA_DEBUGSS_DESC(self, 0x10FC)
        self.TXD = SA_DEBUGSS_TXD(self, 0x1100)
        self.TXCTL = SA_DEBUGSS_TXCTL(self, 0x1104)
        self.RXD = SA_DEBUGSS_RXD(self, 0x1108)
        self.RXCTL = SA_DEBUGSS_RXCTL(self, 0x110C)
        self.SPECIAL_AUTH = SA_DEBUGSS_SPECIAL_AUTH(self, 0x1200)
        self.APP_AUTH = SA_DEBUGSS_APP_AUTH(self, 0x1210)

DEBUGSS = SA_DEBUGSS(0x400C7000, "DEBUGSS")
